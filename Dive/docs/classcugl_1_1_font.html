<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::Font Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_font.html">Font</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcugl_1_1_font-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Font Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_font_8h_source.html">CUFont.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a964dd2f6eca55047bb3a336c9c743448"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">Style</a> : int { <br />
&#160;&#160;<a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448a1e23852820b9154316c7c06e2b7ba051">Style::NORMAL</a> = TTF_STYLE_NORMAL, 
<a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448a2909dd0e0336f10b6da9735b859a3d19">Style::BOLD</a> = TTF_STYLE_BOLD, 
<a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448a25093123b8943308104129e1d762f3b7">Style::ITALIC</a> = TTF_STYLE_ITALIC, 
<a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448a0086c73c90c261db630b4dc8aea09bcf">Style::UNDERLINE</a> = TTF_STYLE_UNDERLINE, 
<br />
&#160;&#160;<a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448a5905b4eb58f29544f9c0ccd1a72548c2">Style::STRIKE</a> = TTF_STYLE_STRIKETHROUGH
<br />
 }<tr class="separator:a964dd2f6eca55047bb3a336c9c743448"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a49ba6d1effb51058ff7894a2e82c8402"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">Hinting</a> : int { <a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402a1e23852820b9154316c7c06e2b7ba051">Hinting::NORMAL</a> = TTF_HINTING_NORMAL, 
<a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402af8589806bbf66241917092b2a6e18c6f">Hinting::LIGHT</a> = TTF_HINTING_LIGHT, 
<a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402af5f75f1b95652443e4398974b82c3f7c">Hinting::MONO</a> = TTF_HINTING_MONO, 
<a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402ab50339a10e1de285ac99d4c3990b8693">Hinting::NONE</a> = TTF_HINTING_NONE
 }<tr class="separator:a49ba6d1effb51058ff7894a2e82c8402"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a79cd1cd3a7f758706e4c17db362c2e1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">Resolution</a> : int { <a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1fad0dea69649a83749aa6bdf176092e8c9">Resolution::SOLID</a> = 0, 
<a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1fa2f170e03078f938d5a3daf3da0ad3572">Resolution::SHADED</a> = 1, 
<a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1fa3ba39f6fa64f612db49d92e6f893d098">Resolution::BLENDED</a> = 2
 }<tr class="separator:a79cd1cd3a7f758706e4c17db362c2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a012d3dacfeab8415c6b94ef74a1c04e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a012d3dacfeab8415c6b94ef74a1c04e4">Font</a> ()</td></tr>
<tr class="separator:a012d3dacfeab8415c6b94ef74a1c04e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423b47ba9ddc35256107a040b4308fc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a423b47ba9ddc35256107a040b4308fc7">~Font</a> ()</td></tr>
<tr class="separator:a423b47ba9ddc35256107a040b4308fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427ffa8e161cf20e7558ae0f5fc18d02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a427ffa8e161cf20e7558ae0f5fc18d02">dispose</a> ()</td></tr>
<tr class="separator:a427ffa8e161cf20e7558ae0f5fc18d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a243b70d9bbafbf8079bdda79cd5c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a67a243b70d9bbafbf8079bdda79cd5c5">init</a> (const std::string &amp;file, int size)</td></tr>
<tr class="separator:a67a243b70d9bbafbf8079bdda79cd5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57da614b343fb05239ca28946824314c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a57da614b343fb05239ca28946824314c">init</a> (const char *file, int size)</td></tr>
<tr class="separator:a57da614b343fb05239ca28946824314c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e47f4a8530baf44a5f9dd8eb4e3600a"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a4e47f4a8530baf44a5f9dd8eb4e3600a">getName</a> () const </td></tr>
<tr class="separator:a4e47f4a8530baf44a5f9dd8eb4e3600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd2272a19e205b7211ab12de1b78e31"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a2bd2272a19e205b7211ab12de1b78e31">getStyleName</a> () const </td></tr>
<tr class="separator:a2bd2272a19e205b7211ab12de1b78e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d7dc4b23fdcb18a8b3f3c53b095cc1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ad2d7dc4b23fdcb18a8b3f3c53b095cc1">getHeight</a> () const </td></tr>
<tr class="separator:ad2d7dc4b23fdcb18a8b3f3c53b095cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de883cb7d748ed6781b1bb164bbfd81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a6de883cb7d748ed6781b1bb164bbfd81">getDescent</a> () const </td></tr>
<tr class="separator:a6de883cb7d748ed6781b1bb164bbfd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2397a1e24b99b3b0f85a0dfdc9f7ff0a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a2397a1e24b99b3b0f85a0dfdc9f7ff0a">getAscent</a> () const </td></tr>
<tr class="separator:a2397a1e24b99b3b0f85a0dfdc9f7ff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad592492197886c781fe4272b6b204b54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ad592492197886c781fe4272b6b204b54">getLineSkip</a> () const </td></tr>
<tr class="separator:ad592492197886c781fe4272b6b204b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064a767706128d937f22170de2df2479"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a064a767706128d937f22170de2df2479">isFixedWidth</a> () const </td></tr>
<tr class="separator:a064a767706128d937f22170de2df2479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320e38b9ae79a36b3244a11a71bf162d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a320e38b9ae79a36b3244a11a71bf162d">usesKerning</a> () const </td></tr>
<tr class="separator:a320e38b9ae79a36b3244a11a71bf162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981455a63a5617c50cdeaf62f5e3d681"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a981455a63a5617c50cdeaf62f5e3d681">setKerning</a> (bool kerning)</td></tr>
<tr class="separator:a981455a63a5617c50cdeaf62f5e3d681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef13d46a64f9374b8ad1b95f270fc5a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aef13d46a64f9374b8ad1b95f270fc5a4">hasGlyph</a> (char a) const </td></tr>
<tr class="separator:aef13d46a64f9374b8ad1b95f270fc5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dac9c0da5cf5ee0cc64fd4e6607a5d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a7dac9c0da5cf5ee0cc64fd4e6607a5d0">hasGlyph</a> (Uint32 a) const </td></tr>
<tr class="separator:a7dac9c0da5cf5ee0cc64fd4e6607a5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a10f20a61b0c06b5c501866ab25f3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ad0a10f20a61b0c06b5c501866ab25f3d">hasString</a> (const std::string &amp;text) const </td></tr>
<tr class="separator:ad0a10f20a61b0c06b5c501866ab25f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa237d8ed36326a33765f9e7b2836c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a7aa237d8ed36326a33765f9e7b2836c0">hasString</a> (const char *text) const </td></tr>
<tr class="separator:a7aa237d8ed36326a33765f9e7b2836c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc697f1397f7f3e49b9fb61aa8745167"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">Style</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#afc697f1397f7f3e49b9fb61aa8745167">getStyle</a> () const </td></tr>
<tr class="separator:afc697f1397f7f3e49b9fb61aa8745167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42819a5fe501b629211731f9293926b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ac42819a5fe501b629211731f9293926b">setStyle</a> (<a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">Style</a> style)</td></tr>
<tr class="separator:ac42819a5fe501b629211731f9293926b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e58bef0d43328633ec1e03c42906b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">Hinting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ae0e58bef0d43328633ec1e03c42906b6">getHinting</a> () const </td></tr>
<tr class="separator:ae0e58bef0d43328633ec1e03c42906b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1746ce764084b49610118b73835db2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ac1746ce764084b49610118b73835db2d">setHinting</a> (<a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">Hinting</a> hinting)</td></tr>
<tr class="separator:ac1746ce764084b49610118b73835db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1909eb3cef5bfc18f6923de2a1100d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">Resolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ac1909eb3cef5bfc18f6923de2a1100d4">getResolution</a> () const </td></tr>
<tr class="separator:ac1909eb3cef5bfc18f6923de2a1100d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60d1b44b1ef29f2fabf9eb1fa249509"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aa60d1b44b1ef29f2fabf9eb1fa249509">setResolution</a> (<a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">Resolution</a> resolution)</td></tr>
<tr class="separator:aa60d1b44b1ef29f2fabf9eb1fa249509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebaf5246df4124da405c094502fb517"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a0ebaf5246df4124da405c094502fb517">getMetrics</a> (char thechar) const </td></tr>
<tr class="separator:a0ebaf5246df4124da405c094502fb517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4ccd7ccd1af1eaeb658e2c7da43055"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#acf4ccd7ccd1af1eaeb658e2c7da43055">getMetrics</a> (Uint32 thechar) const </td></tr>
<tr class="separator:acf4ccd7ccd1af1eaeb658e2c7da43055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbc665ff23ae0151080c6a8df4a8403"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a2bbc665ff23ae0151080c6a8df4a8403">getKerning</a> (char a, char b) const </td></tr>
<tr class="separator:a2bbc665ff23ae0151080c6a8df4a8403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab870c300b08bd4d80ae814ca93dc7cf9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ab870c300b08bd4d80ae814ca93dc7cf9">getKerning</a> (Uint32 a, Uint32 b) const </td></tr>
<tr class="separator:ab870c300b08bd4d80ae814ca93dc7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f8e5221b5a11d09d3ac3f1b946978f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a46f8e5221b5a11d09d3ac3f1b946978f">getSize</a> (const std::string &amp;text, bool utf8=true) const </td></tr>
<tr class="separator:a46f8e5221b5a11d09d3ac3f1b946978f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740aa1f729b7ec82268ed10cc47d3e2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a740aa1f729b7ec82268ed10cc47d3e2e">getSize</a> (const char *text, bool utf8=true) const </td></tr>
<tr class="separator:a740aa1f729b7ec82268ed10cc47d3e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5656110ba7400cc2991650ad4c4fd61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ad5656110ba7400cc2991650ad4c4fd61">getInternalBounds</a> (const std::string &amp;text, bool utf8=true) const </td></tr>
<tr class="separator:ad5656110ba7400cc2991650ad4c4fd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11df624b77537db7faf166423192cb87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a11df624b77537db7faf166423192cb87">getInternalBounds</a> (const char *text, bool utf8=true) const </td></tr>
<tr class="separator:a11df624b77537db7faf166423192cb87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9b159424ac0de23eae599c1b83deef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#afe9b159424ac0de23eae599c1b83deef">clearAtlas</a> ()</td></tr>
<tr class="separator:afe9b159424ac0de23eae599c1b83deef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa938e59ca1d898e3065109d4bc1e2fd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aa938e59ca1d898e3065109d4bc1e2fd9">buildAtlas</a> ()</td></tr>
<tr class="separator:aa938e59ca1d898e3065109d4bc1e2fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5540f3d0160793ca638d8cedfbef5c16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a5540f3d0160793ca638d8cedfbef5c16">buildAtlas</a> (const std::string &amp;charset)</td></tr>
<tr class="separator:a5540f3d0160793ca638d8cedfbef5c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245f990565dffc5e293e1bbcc944a809"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a245f990565dffc5e293e1bbcc944a809">buildAtlas</a> (const char *charset)</td></tr>
<tr class="separator:a245f990565dffc5e293e1bbcc944a809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1a6cb71fed63a75537fc07a9e6f318"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aaf1a6cb71fed63a75537fc07a9e6f318">buildAtlasAsync</a> ()</td></tr>
<tr class="separator:aaf1a6cb71fed63a75537fc07a9e6f318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718deb382ee5ae841ddd35aaedf8421"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a7718deb382ee5ae841ddd35aaedf8421">buildAtlasAsync</a> (const std::string &amp;charset)</td></tr>
<tr class="separator:a7718deb382ee5ae841ddd35aaedf8421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b808921f973f83dc284a9f6a3813cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ab1b808921f973f83dc284a9f6a3813cc">buildAtlasAsync</a> (const char *charset)</td></tr>
<tr class="separator:ab1b808921f973f83dc284a9f6a3813cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d1e49ac0df46cff75c556713d06fa9"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas</a> ()</td></tr>
<tr class="separator:a12d1e49ac0df46cff75c556713d06fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77aedf078e66dcef212f12fbdb4c9731"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a77aedf078e66dcef212f12fbdb4c9731">hasAtlas</a> () const </td></tr>
<tr class="separator:a77aedf078e66dcef212f12fbdb4c9731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0935d1137dd48ff233a2e21004afc2c1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a0935d1137dd48ff233a2e21004afc2c1">getQuads</a> (const std::string &amp;text, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, bool utf8=true)</td></tr>
<tr class="separator:a0935d1137dd48ff233a2e21004afc2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342d37788e3d47f590c061d5c5528648"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a342d37788e3d47f590c061d5c5528648">getQuads</a> (const char *text, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, bool utf8=true)</td></tr>
<tr class="separator:a342d37788e3d47f590c061d5c5528648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3442c33f9bfec14bfedf95cb0bca5c9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#af3442c33f9bfec14bfedf95cb0bca5c9">getQuads</a> (const std::string &amp;text, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, bool utf8=true)</td></tr>
<tr class="separator:af3442c33f9bfec14bfedf95cb0bca5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2ac51dce00c34fcbb5c5077e981aec"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a8c2ac51dce00c34fcbb5c5077e981aec">getQuads</a> (const char *text, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, bool utf8=true)</td></tr>
<tr class="separator:a8c2ac51dce00c34fcbb5c5077e981aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd223ed9cd08f71f322540ec3ea87285"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#abd223ed9cd08f71f322540ec3ea87285">getQuad</a> (Uint32 thechar, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices)</td></tr>
<tr class="separator:abd223ed9cd08f71f322540ec3ea87285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1764052f38325f6181f56da92fe102f1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a1764052f38325f6181f56da92fe102f1">getQuad</a> (Uint32 thechar, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices)</td></tr>
<tr class="separator:a1764052f38325f6181f56da92fe102f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7c63b58192a8cc9e288b5135e350c01d"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_font.html">Font</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a7c63b58192a8cc9e288b5135e350c01d">alloc</a> (const std::string &amp;file, int size)</td></tr>
<tr class="separator:a7c63b58192a8cc9e288b5135e350c01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ebef32107ba0d0b6edb688c7263317"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_font.html">Font</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a51ebef32107ba0d0b6edb688c7263317">alloc</a> (const char *file, int size)</td></tr>
<tr class="separator:a51ebef32107ba0d0b6edb688c7263317"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acab748dc42ee9ad3fad417b5547f027e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#acab748dc42ee9ad3fad417b5547f027e">getAtlasQuads</a> (const std::string &amp;text, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, bool utf8)</td></tr>
<tr class="separator:acab748dc42ee9ad3fad417b5547f027e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae261e744c0584aa1f84b13a47d73d72c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ae261e744c0584aa1f84b13a47d73d72c">getRenderedQuads</a> (const std::string &amp;text, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, bool utf8)</td></tr>
<tr class="separator:ae261e744c0584aa1f84b13a47d73d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a9e9152aaaacdd1978d8f1017144f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a49a9e9152aaaacdd1978d8f1017144f7">getAtlasQuad</a> (Uint32 thechar, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices)</td></tr>
<tr class="separator:a49a9e9152aaaacdd1978d8f1017144f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9969235dae093dd28936fb3fb9141c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a3c9969235dae093dd28936fb3fb9141c">getRenderedQuad</a> (Uint32 thechar, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices)</td></tr>
<tr class="separator:a3c9969235dae093dd28936fb3fb9141c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b0df3694a3801c8369b1189c3939f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a05b0df3694a3801c8369b1189c3939f2">getSizeASCII</a> (const std::string &amp;text) const </td></tr>
<tr class="separator:a05b0df3694a3801c8369b1189c3939f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366eb72d1f77850b5168bc10c934898d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a366eb72d1f77850b5168bc10c934898d">getSizeUTF8</a> (const std::string &amp;text) const </td></tr>
<tr class="separator:a366eb72d1f77850b5168bc10c934898d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bd0e972978f4c201e1d8009607cc71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#af0bd0e972978f4c201e1d8009607cc71">getInternalBoundsASCII</a> (const std::string &amp;text) const </td></tr>
<tr class="separator:af0bd0e972978f4c201e1d8009607cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9138548b3160dd2184ba35d9b9710bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#af9138548b3160dd2184ba35d9b9710bc">getInternalBoundsUTF8</a> (const std::string &amp;text) const </td></tr>
<tr class="separator:af9138548b3160dd2184ba35d9b9710bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f3853837ef5c3fcf66e4110c5a5bcd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a17f3853837ef5c3fcf66e4110c5a5bcd">prepareAtlas</a> ()</td></tr>
<tr class="separator:a17f3853837ef5c3fcf66e4110c5a5bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee492ad1587767f29312c42216656c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a0ee492ad1587767f29312c42216656c7">prepareAtlas</a> (std::string charset)</td></tr>
<tr class="separator:a0ee492ad1587767f29312c42216656c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd13b18046709de9df2bbecd96b2699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#abcd13b18046709de9df2bbecd96b2699">prepareAtlasKerning</a> ()</td></tr>
<tr class="separator:abcd13b18046709de9df2bbecd96b2699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20efeb5a4eae5362ee7ebc884a5ea917"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a20efeb5a4eae5362ee7ebc884a5ea917">computeMetrics</a> (Uint32 thechar) const </td></tr>
<tr class="separator:a20efeb5a4eae5362ee7ebc884a5ea917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadeccf5aa001f886253e27cb17bd97e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aadeccf5aa001f886253e27cb17bd97e0">computeKerning</a> (Uint32 a, Uint32 b) const </td></tr>
<tr class="separator:aadeccf5aa001f886253e27cb17bd97e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4676c3fe48ce77f880dfe3221854add3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a4676c3fe48ce77f880dfe3221854add3">computeAtlasSize</a> (int *width, int *height)</td></tr>
<tr class="separator:a4676c3fe48ce77f880dfe3221854add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1713d7035d5c071950eb8017596be9fc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Uint32 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a1713d7035d5c071950eb8017596be9fc">planAtlas</a> (int width, int height)</td></tr>
<tr class="separator:a1713d7035d5c071950eb8017596be9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d55a17726fdfa91309996a0ff2224d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a12d55a17726fdfa91309996a0ff2224d">layoutAtlas</a> (const std::vector&lt; std::vector&lt; Uint32 &gt; &gt; &amp;rectangle)</td></tr>
<tr class="separator:a12d55a17726fdfa91309996a0ff2224d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3d4f4e3cd8c0ffb8f6aff18ece9b27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ace3d4f4e3cd8c0ffb8f6aff18ece9b27">generateSurface</a> (int width, int height)</td></tr>
<tr class="separator:ace3d4f4e3cd8c0ffb8f6aff18ece9b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081d6dbad98ff671cc479781903de037"><td class="memItemLeft" align="right" valign="top">SDL_Surface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a081d6dbad98ff671cc479781903de037">allocSurface</a> (int width, int height)</td></tr>
<tr class="separator:a081d6dbad98ff671cc479781903de037"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af3c089eb485a8f6f9c05dda9325fb89e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#af3c089eb485a8f6f9c05dda9325fb89e">_name</a></td></tr>
<tr class="separator:af3c089eb485a8f6f9c05dda9325fb89e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5c3b622c8fbfeb70e145c494158eda"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a7e5c3b622c8fbfeb70e145c494158eda">_stylename</a></td></tr>
<tr class="separator:a7e5c3b622c8fbfeb70e145c494158eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669a630a5a6410207042b8f8b58cd03"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a9669a630a5a6410207042b8f8b58cd03">_size</a></td></tr>
<tr class="separator:a9669a630a5a6410207042b8f8b58cd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b39548de9faa8d511674b53824793b"><td class="memItemLeft" align="right" valign="top">TTF_Font *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ab1b39548de9faa8d511674b53824793b">_data</a></td></tr>
<tr class="separator:ab1b39548de9faa8d511674b53824793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d93b0b0506b506de010f799360554f9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a3d93b0b0506b506de010f799360554f9">_fontHeight</a></td></tr>
<tr class="separator:a3d93b0b0506b506de010f799360554f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6dd95aa65b6cb99999934ba1e9052f5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ae6dd95aa65b6cb99999934ba1e9052f5">_fontDescent</a></td></tr>
<tr class="separator:ae6dd95aa65b6cb99999934ba1e9052f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff1d74d40b9628234090ecad4481774"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a1ff1d74d40b9628234090ecad4481774">_fontAscent</a></td></tr>
<tr class="separator:a1ff1d74d40b9628234090ecad4481774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180d9760bdf4ed605ac7eaabe986f53d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a180d9760bdf4ed605ac7eaabe986f53d">_fontLineSkip</a></td></tr>
<tr class="separator:a180d9760bdf4ed605ac7eaabe986f53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3f7f702c86e8220b9bedb44a9a8688"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#abd3f7f702c86e8220b9bedb44a9a8688">_fixedWidth</a></td></tr>
<tr class="separator:abd3f7f702c86e8220b9bedb44a9a8688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da79431f6a97419e02898ac1e92d296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a9da79431f6a97419e02898ac1e92d296">_useKerning</a></td></tr>
<tr class="separator:a9da79431f6a97419e02898ac1e92d296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bdae721c92bfdc19dad474c4634b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">Style</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aa2bdae721c92bfdc19dad474c4634b1b">_style</a></td></tr>
<tr class="separator:aa2bdae721c92bfdc19dad474c4634b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d437bebfd37db189209040d328ad61d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">Hinting</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a0d437bebfd37db189209040d328ad61d">_hints</a></td></tr>
<tr class="separator:a0d437bebfd37db189209040d328ad61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f2e355dc3967b189e46563a3da9cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">Resolution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a34f2e355dc3967b189e46563a3da9cdc">_render</a></td></tr>
<tr class="separator:a34f2e355dc3967b189e46563a3da9cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80e81489fd5ab235a799e59003e6d18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aa80e81489fd5ab235a799e59003e6d18">_hasAtlas</a></td></tr>
<tr class="separator:aa80e81489fd5ab235a799e59003e6d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb4f0648ca0e43d16a46b9bb6767485"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#adbb4f0648ca0e43d16a46b9bb6767485">_glyphset</a></td></tr>
<tr class="separator:adbb4f0648ca0e43d16a46b9bb6767485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03595f99abada65a0735911d2ba70291"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Uint32, <a class="el" href="classcugl_1_1_rect.html">Rect</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a03595f99abada65a0735911d2ba70291">_glyphmap</a></td></tr>
<tr class="separator:a03595f99abada65a0735911d2ba70291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4224352c76e062f28f186cc9d21eeb"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Uint32, <a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aca4224352c76e062f28f186cc9d21eeb">_glyphsize</a></td></tr>
<tr class="separator:aca4224352c76e062f28f186cc9d21eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6d0766c0b3db7cd97debfc96a81410"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; Uint32, std::unordered_map&lt; Uint32, Uint32 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#aab6d0766c0b3db7cd97debfc96a81410">_kernmap</a></td></tr>
<tr class="separator:aab6d0766c0b3db7cd97debfc96a81410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae929a330902280385a2c5a3e38e3888c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#ae929a330902280385a2c5a3e38e3888c">_texture</a></td></tr>
<tr class="separator:ae929a330902280385a2c5a3e38e3888c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebe91c5b596e5335ec15879ed0879dd"><td class="memItemLeft" align="right" valign="top">SDL_Surface *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_font.html#a2ebe91c5b596e5335ec15879ed0879dd">_surface</a></td></tr>
<tr class="separator:a2ebe91c5b596e5335ec15879ed0879dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a true type font at a fixed size.</p>
<p>It is possible to change many of the font settings after loading. However, the size is fixed and cannot be changed. If you want a different size of the same font, you must load it as a new asset.</p>
<p>This font can be used to generate textures and quads for rendering text to the screen. This is typically done via the <a class="el" href="classcugl_1_1_label.html">Label</a> class, though the methods are available for any rendering pipeline.</p>
<p>Rendering ASCII text is easy. For unicode support however, you need to encode you text properly. the only unicode encoding that we support is UTF8. For the reason why, see </p><pre class="fragment"> http://utf8everywhere.org/#how
</pre><p>This font can also support an atlas. This is a texture with all of the avaliable characters prerendered. This single texture is then used to render the font on screen. This is a potentially fast way of rendering fonts, because it uses only one call to the graphics card.</p>
<p>However, there are disadvantages to a font atlas, and so you should be aware of how to use them properly. First of all, you are trading one texture with many vertices, while rendering the font directly only needs four vertices. If you have a static label that never changes, it may be faster to pay the initial rendering cost of a font with no atlas.</p>
<p>More importantly, font atlas textures can be huge if all glyphs are included. For example, if we include all the unicode characters in Times New Roman at 48 point font, the resulting atlas texture is 2048x4096, which is too much for mobile devices.</p>
<p>For this reason, the method <a class="el" href="classcugl_1_1_font.html#aa938e59ca1d898e3065109d4bc1e2fd9">buildAtlas()</a> and its variants require that you explicitly specify a character set for the atlas. Indeed, a character set is the only way to get unicode support; the basic atlas only includes ASCII characters. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a49ba6d1effb51058ff7894a2e82c8402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">cugl::Font::Hinting</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This enum represents the hints for rasterization.</p>
<p>Hinting is used to align the font to a rasterized grid. At low screen resolutions, hinting is critical for producing clear, legible text (particularly if you are not supporting antialiasing). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a49ba6d1effb51058ff7894a2e82c8402a1e23852820b9154316c7c06e2b7ba051"></a>NORMAL&#160;</td><td class="fielddoc">
<p>This corresponds to the default hinting algorithm, optimized for standard gray-level rendering </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a49ba6d1effb51058ff7894a2e82c8402af8589806bbf66241917092b2a6e18c6f"></a>LIGHT&#160;</td><td class="fielddoc">
<p>This is a lighter hinting algorithm for non-monochrome modes. Many generated glyphs are more fuzzy but better resemble its original shape. This is a bit like rendering on Mac OS X. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a49ba6d1effb51058ff7894a2e82c8402af5f75f1b95652443e4398974b82c3f7c"></a>MONO&#160;</td><td class="fielddoc">
<p>This is a strong hinting algorithm that should only be used for monochrome output. The result is probably unpleasant if the glyph is rendered in non-monochrome modes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a49ba6d1effb51058ff7894a2e82c8402ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc">
<p>In this case, no hinting is usedm so the font may become very blurry or messy at smaller sizes. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a79cd1cd3a7f758706e4c17db362c2e1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">cugl::Font::Resolution</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This enum represents the font resolution for rendering.</p>
<p>The option SOLID is only useful for the case where there is no atlas. The preferred value for atlases and high quality fonts is BLENDED. However, when you need a font to "pop" out from a background, you may want SHADED instead. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a79cd1cd3a7f758706e4c17db362c2e1fad0dea69649a83749aa6bdf176092e8c9"></a>SOLID&#160;</td><td class="fielddoc">
<p>The text is renderized with no antialiasing.</p>
<p>When rendering with this option, the font will have a very hard edge. Rendering is faster than the other options, but this only matters when the font has no atlas. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a79cd1cd3a7f758706e4c17db362c2e1fa2f170e03078f938d5a3daf3da0ad3572"></a>SHADED&#160;</td><td class="fielddoc">
<p>The text is renderized smoothly with a hard edge</p>
<p>When rendering with this option, the font will have smooth edges, but there will be a dark border around the font (regardless of the font color). This acts as a form of outlining and guarantees the font will always pop out from its background.</p>
<p>Rendering fonts this way is much slower than SOLID, but has no serious effects when using an atlas. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a79cd1cd3a7f758706e4c17db362c2e1fa3ba39f6fa64f612db49d92e6f893d098"></a>BLENDED&#160;</td><td class="fielddoc">
<p>The text is renderized with a 32-bit RGBA surface.</p>
<p>When rendering with this option, the font will have an antialiased edge that blends in with its background. This is the preferred option for rendering high quality fonts.</p>
<p>Rendering fonts this way is much slower than SOLID, but has no serious effects when using an atlas. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a964dd2f6eca55047bb3a336c9c743448"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">cugl::Font::Style</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This enum represents the possible font styles.</p>
<p>Generally, these styles would be encoded in the font face, but they are provided to allow the user some flexibility with any font.</p>
<p>With the exception of normal style (which is an absent of any style), all of the styles may be combined. So it is possible to have a bold, italic, underline font with strikethrough. To combine styles, simply treat the Style value as a bitmask, and combine them with bitwise operations. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a964dd2f6eca55047bb3a336c9c743448a1e23852820b9154316c7c06e2b7ba051"></a>NORMAL&#160;</td><td class="fielddoc">
<p>The default style provided by this face </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a964dd2f6eca55047bb3a336c9c743448a2909dd0e0336f10b6da9735b859a3d19"></a>BOLD&#160;</td><td class="fielddoc">
<p>An adhoc created bold style </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a964dd2f6eca55047bb3a336c9c743448a25093123b8943308104129e1d762f3b7"></a>ITALIC&#160;</td><td class="fielddoc">
<p>An adhoc created italics style </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a964dd2f6eca55047bb3a336c9c743448a0086c73c90c261db630b4dc8aea09bcf"></a>UNDERLINE&#160;</td><td class="fielddoc">
<p>An adhoc created underline style </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a964dd2f6eca55047bb3a336c9c743448a5905b4eb58f29544f9c0ccd1a72548c2"></a>STRIKE&#160;</td><td class="fielddoc">
<p>An adhoc created strike-through style </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a012d3dacfeab8415c6b94ef74a1c04e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Font::Font </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a degenerate font with no data.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate an object on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a class="anchor" id="a423b47ba9ddc35256107a040b4308fc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Font::~Font </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this font, disposing of all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7c63b58192a8cc9e288b5135e350c01d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_font.html">Font</a>&gt; cugl::Font::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated font of the given size from the file.</p>
<p>The font size is fixed on creation. It cannot be changed without creating a new font asset. However, all other attributes may be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file with the font asset </td></tr>
    <tr><td class="paramname">size</td><td>The font size in points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated font of the given size from the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a51ebef32107ba0d0b6edb688c7263317"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_font.html">Font</a>&gt; cugl::Font::alloc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated font of the given size from the file.</p>
<p>The font size is fixed on creation. It cannot be changed without creating a new font asset. However, all other attributes may be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file with the font asset </td></tr>
    <tr><td class="paramname">size</td><td>The font size in points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated font of the given size from the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a081d6dbad98ff671cc479781903de037"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDL_Surface* cugl::Font::allocSurface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a blank surface of the given size.</p>
<p>This method is necessary because SDL surface allocation is quite involved when you want proper alpha support.</p>
<dl class="section return"><dt>Returns</dt><dd>a blank surface of the given size. </dd></dl>

</div>
</div>
<a class="anchor" id="aa938e59ca1d898e3065109d4bc1e2fd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::buildAtlas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an atlas for the ASCII characters in this font.</p>
<p>Only the ASCII characters are added to the atlas, even if the font has support for more characters. You should use a character set method if you want Unicode characters supported.</p>
<p>The character atlas texture is generated immediately, so the method <a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas()</a> may be called with no delay.</p>
<p>WARNING: This initializer is not thread safe. It generates an OpenGL texture, which means that it may only be called in the main thread.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the atlas was successfully created. </dd></dl>

</div>
</div>
<a class="anchor" id="a5540f3d0160793ca638d8cedfbef5c16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::buildAtlas </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>charset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an for the given character set.</p>
<p>The atlas only contains characters in the provided character set, and will omit all other chacters. This includes ASCII characters that may be missing from the character set. The character set string must either be in ASCII or UTF8 encoding. It will handle both automatically, but no other encoding (e.g. Latin1) is accepted.</p>
<p>The character atlas texture is generated immediately, so the method <a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas()</a> may be called with no delay.</p>
<p>WARNING: This initializer is not thread safe. It generates an OpenGL texture, which means that it may only be called in the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charset</td><td>The set of characters in the atlas</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the atlas was successfully created. </dd></dl>

</div>
</div>
<a class="anchor" id="a245f990565dffc5e293e1bbcc944a809"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::buildAtlas </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an for the given character set.</p>
<p>The atlas only contains characters in the provided character set, and will omit all other chacters. This includes ASCII characters that may be missing from the character set. The character set string must either be in ASCII or UTF8 encoding. It will handle both automatically, but no other encoding (e.g. Latin1) is accepted.</p>
<p>The character atlas texture is generated immediately, so the method <a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas()</a> may be called with no delay.</p>
<p>WARNING: This initializer is not thread safe. It generates an OpenGL texture, which means that it may only be called in the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charset</td><td>The set of characters in the atlas</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the atlas was successfully created. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf1a6cb71fed63a75537fc07a9e6f318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::buildAtlasAsync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an atlas for the ASCII characters in this font.</p>
<p>Only the ASCII characters are added to the atlas, even if the font has support for more characters. You should use a character set method if you want Unicode characters supported.</p>
<p>This method does not generate the OpenGL texture, but does all other work in creates the atlas. In particular it creates the image buffer so that texture creation is just one OpenGL call. This creation will happen the first time that <a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas()</a> is called.</p>
<p>As a result, this method is thread safe. It may be called in any thread, including threads other than the main one.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the atlas was successfully created. </dd></dl>

</div>
</div>
<a class="anchor" id="a7718deb382ee5ae841ddd35aaedf8421"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::buildAtlasAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>charset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an for the given character set.</p>
<p>The atlas only contains characters in the provided character set, and will omit all other chacters. This includes ASCII characters that may be missing from the character set. The character set string must either be in ASCII or UTF8 encoding. It will handle both automatically, but no other encoding (e.g. Latin1) is accepted.</p>
<p>This method does not generate the OpenGL texture, but does all other work in creates the atlas. In particular it creates the image buffer so that texture creation is just one OpenGL call. This creation will happen the first time that <a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas()</a> is called.</p>
<p>As a result, this method is thread safe. It may be called in any thread, including threads other than the main one.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the atlas was successfully created. </dd></dl>

</div>
</div>
<a class="anchor" id="ab1b808921f973f83dc284a9f6a3813cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::buildAtlasAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an for the given character set.</p>
<p>The atlas only contains characters in the provided character set, and will omit all other chacters. This includes ASCII characters that may be missing from the character set. The character set string must either be in ASCII or UTF8 encoding. It will handle both automatically, but no other encoding (e.g. Latin1) is accepted.</p>
<p>This method does not generate the OpenGL texture, but does all other work in creates the atlas. In particular it creates the image buffer so that texture creation is just one OpenGL call. This creation will happen the first time that <a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas()</a> is called.</p>
<p>As a result, this method is thread safe. It may be called in any thread, including threads other than the main one.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the atlas was successfully created. </dd></dl>

</div>
</div>
<a class="anchor" id="afe9b159424ac0de23eae599c1b83deef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::clearAtlas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the current atlas</p>
<p>The font will use direct rendering until a new atlas is created. </p>

</div>
</div>
<a class="anchor" id="a4676c3fe48ce77f880dfe3221854add3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::computeAtlasSize </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the size of the atlas texture</p>
<p>This method computes the minimum bounding box that will contain all of the glyphs in this atlas. The bounding box is guaranteed to have dimensions that are a power of 2, so that the texture is compatible with all graphics cards.</p>
<p>The dimensions are store in the provided pointers. The width should be a value &gt; 1. For best results, the width should be the size of the maximum character width.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Integer to store the width in </td></tr>
    <tr><td class="paramname">height</td><td>Integer to store the height in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aadeccf5aa001f886253e27cb17bd97e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::computeKerning </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the kerning between the two characters if available.</p>
<p>The method will return -1 if there either of the two characters are not supported by this font.</p>
<dl class="section return"><dt>Returns</dt><dd>the kerning between the two characters if available. </dd></dl>

</div>
</div>
<a class="anchor" id="a20efeb5a4eae5362ee7ebc884a5ea917"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a> cugl::Font::computeMetrics </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>thechar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the metrics for the given character if available.</p>
<p>This method returns a metric with all zeroes if no data is fount.</p>
<dl class="section return"><dt>Returns</dt><dd>the metrics for the given character if available. </dd></dl>

</div>
</div>
<a class="anchor" id="a427ffa8e161cf20e7558ae0f5fc18d02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Font::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the font resources and resets all attributes.</p>
<p>This will delete the original font information in addition to any generating atlases.</p>
<p>You must reinitialize the font to use it. </p>

</div>
</div>
<a class="anchor" id="ace3d4f4e3cd8c0ffb8f6aff18ece9b27"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::generateSurface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generates an SDL surface for the font atlas.</p>
<p>The data from this surface can be used to generate the OpenGL texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the bounding box </td></tr>
    <tr><td class="paramname">height</td><td>The height of the bounding box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the surface was successfully generated. </dd></dl>

</div>
</div>
<a class="anchor" id="a2397a1e24b99b3b0f85a0dfdc9f7ff0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::getAscent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum distance from the baseline to the top of a glyph.</p>
<p>This value will always be positive.</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum distance from the baseline to the top of a glyph. </dd></dl>

</div>
</div>
<a class="anchor" id="a12d1e49ac0df46cff75c556713d06fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::Font::getAtlas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the OpenGL texture for the associated atlas.</p>
<p>When combined with a quad sequence generated by this font, this texture can be used to draw a font in a <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>. If there is no atlas, this method returns nullptr.</p>
<dl class="section return"><dt>Returns</dt><dd>the OpenGL texture for the associated atlas. </dd></dl>

</div>
</div>
<a class="anchor" id="a49a9e9152aaaacdd1978d8f1017144f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::getAtlasQuad </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>thechar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a single quad to render this character and stores it in vertices</p>
<p>This method will append the vertices to the given vertex list. The quad is adjusted so that all of the vertices fit in the provided rectangle. This may mean that no quad is generated at all.</p>
<p>This method will return false if the right edge of the glyph is not rendered. This lets us know if a character has exceeded the bounding rectangle. Without this, kerning may move the next character back into range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thechar</td><td>The character to convert to render data </td></tr>
    <tr><td class="paramname">offset</td><td>The (unkerned) starting position of the quad </td></tr>
    <tr><td class="paramname">rect</td><td>The bounding box for the quad </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the right edge of the glyph was generated </dd></dl>

</div>
</div>
<a class="anchor" id="acab748dc42ee9ad3fad417b5547f027e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::getAtlasQuads </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates quads to render this string and stores them in vertices.</p>
<p>This method will append the vertices to the given vertex list. The quad sequence is adjusted so that all of the vertices fit in the provided rectangle. This may mean that some of the glyphs are truncated or even omitted.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>To use the quad sequence with <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>, you will also need a sequence of indices, which this method does not provide. However, the indices should be obvious, as the vertices are all a sequence of quads. Just create two triangles for each quad. The quad vertices are in the following order: top left, top right, bottom left, bottom right.</p>
<p>The origin value determines the position of the bottom of the glyph, including the descent. It is not the position of the baseline.</p>
<p>This method does not return anything because the quads use the atlas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to convert to render data. </td></tr>
    <tr><td class="paramname">origin</td><td>The position of the first character </td></tr>
    <tr><td class="paramname">rect</td><td>The bounding box for the quads. </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6de883cb7d748ed6781b1bb164bbfd81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::getDescent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum distance from the baseline to the bottom of a glyph.</p>
<p>This value will always be negative. You should add this value to the y position to shift the baseline down to the rendering origin.</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum distance from the baseline to the bottom of a glyph. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2d7dc4b23fdcb18a8b3f3c53b095cc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum height of this font.</p>
<p>This is the sum of the ascent and the negative descent. Any box that is this many characters high can sucessfully hold a glyph from this font.</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum height of this font. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0e58bef0d43328633ec1e03c42906b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">Hinting</a> cugl::Font::getHinting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rasterization hints</p>
<p>Hinting is used to align the font to a rasterized grid. At low screen resolutions, hinting is critical for producing clear, legible text (particularly if you are not supporting antialiasing).</p>
<dl class="section return"><dt>Returns</dt><dd>the rasterization hints </dd></dl>

</div>
</div>
<a class="anchor" id="ad5656110ba7400cc2991650ad4c4fd61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Font::getInternalBounds </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pixel offset of the glyphs inside a rendered string.</p>
<p>The result of <a class="el" href="">getSize(const std::string&amp;, bool)</a> is very conservative. Even if no character uses the maximum height, it provides the full height of the font. Furthermore, if the last character does not use the full advance, there will be padding after that character.</p>
<p>The rectangle returned by this method provide the internal bounds of the rendered text. The value is in "text space". If a string is rendered at position (0,0), this is the bounding box for all of the glyphs that are actually rendered. It is the tightest bounding box that can fit all of the generated glyph. You can use this rectangle to eliminate any font-specific spacing that may have been placed around the glyphs.</p>
<p>For example, suppose the string is "ah". In many fonts, these two glyphs would not dip below the baseline. Therefore, the y value of the returned rectangle would be at the font baseline, indicating that it is safe to start rendering there.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to measure. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the quad sequence generated for this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a11df624b77537db7faf166423192cb87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Font::getInternalBounds </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the pixel offset of the glyphs inside a rendered string.</p>
<p>The result of <a class="el" href="">getSize(const std::string&amp;, bool)</a> is very conservative. Even if no character uses the maximum height, it provides the full height of the font. Furthermore, if the last character does not use the full advance, there will be padding after that character.</p>
<p>The rectangle returned by this method provide the internal bounds of the rendered text. The value is in "text space". If a string is rendered at position (0,0), this is the bounding box for all of the glyphs that are actually rendered. It is the tightest bounding box that can fit all of the generated glyph. You can use this rectangle to eliminate any font-specific spacing that may have been placed around the glyphs.</p>
<p>For example, suppose the string is "ah". In many fonts, these two glyphs would not dip below the baseline. Therefore, the y value of the returned rectangle would be at the font baseline, indicating that it is safe to start rendering there.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to measure. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the quad sequence generated for this string. </dd></dl>

</div>
</div>
<a class="anchor" id="af0bd0e972978f4c201e1d8009607cc71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Font::getInternalBoundsASCII </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the pixel offset of the glyphs inside a rendered string.</p>
<p>The result of <a class="el" href="">getSize(const std::string&amp;, bool)</a> is very conservative. Even if no character uses the maximum height, it provides the full height of the font. Furthermore, if the last character does not use the full advance, there will be padding after that character.</p>
<p>The rectangle returned by this method provide the internal bounds of the rendered text. The value is in "text space". If a string is rendered at position (0,0), this is the bounding box for all of the glyphs that are actually rendered. It is the tightest bounding box that can fit all of the generated glyph. You can use this rectangle to eliminate any font-specific spacing that may have been placed around the glyphs.</p>
<p>For example, suppose the string is "ah". In many fonts, these two glyphs would not dip below the baseline. Therefore, the y value of the returned rectangle would be at the font baseline, indicating that it is safe to start rendering there.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The ASCII string to measure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the quad sequence generated for this string. </dd></dl>

</div>
</div>
<a class="anchor" id="af9138548b3160dd2184ba35d9b9710bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Font::getInternalBoundsUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the pixel offset of the glyphs inside a rendered string.</p>
<p>The result of <a class="el" href="">getSize(const std::string&amp;, bool)</a> is very conservative. Even if no character uses the maximum height, it provides the full height of the font. Furthermore, if the last character does not use the full advance, there will be padding after that character.</p>
<p>The rectangle returned by this method provide the internal bounds of the rendered text. The value is in "text space". If a string is rendered at position (0,0), this is the bounding box for all of the glyphs that are actually rendered. It is the tightest bounding box that can fit all of the generated glyph. You can use this rectangle to eliminate any font-specific spacing that may have been placed around the glyphs.</p>
<p>For example, suppose the string is "ah". In many fonts, these two glyphs would not dip below the baseline. Therefore, the y value of the returned rectangle would be at the font baseline, indicating that it is safe to start rendering there.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The UTF8 string to measure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the quad sequence generated for this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bbc665ff23ae0151080c6a8df4a8403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Font::getKerning </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the kerning adjustment between the two (ASCII) characters.</p>
<p>This value is the amount of overlap (in pixels) between any two adjacent character glyphs rendered by this font. If the value is 0, there is no kerning for this pair.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first ASCII character in the pair </td></tr>
    <tr><td class="paramname">b</td><td>The second ASCII character in the pair</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kerning adjustment between the two (ASCII) characters. </dd></dl>

</div>
</div>
<a class="anchor" id="ab870c300b08bd4d80ae814ca93dc7cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Font::getKerning </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the kerning adjustment between the two (Unicode) characters.</p>
<p>This value is the amount of overlap (in pixels) between any two adjacent character glyphs rendered by this font. If the value is 0, there is no kerning for this pair.</p>
<p>The Unicode representation uses the endianness native to the platform. Therefore, this value should not be serialized. Use UTF8 to represent unicode in a platform-independent manner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first Unicode character in the pair </td></tr>
    <tr><td class="paramname">b</td><td>The second Unicode character in the pair</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the kerning adjustment between the two (Unicode) characters. </dd></dl>

</div>
</div>
<a class="anchor" id="ad592492197886c781fe4272b6b204b54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::getLineSkip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the recommended lineskip of this font.</p>
<p>The line skip is the recommended height of a line of text. It is often larger than the font height.</p>
<dl class="section return"><dt>Returns</dt><dd>the recommended lineskip of this font. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ebaf5246df4124da405c094502fb517"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a> cugl::Font::getMetrics </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>thechar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the glyph metrics for the given (ASCII) character.</p>
<p>See <a class="el" href="">FontGlyphMetrics</a> for an explanation of the data provided by this method. This method will fail if the glyph is not in this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thechar</td><td>The ASCII character to measure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the glyph metrics for the given (ASCII) character. </dd></dl>

</div>
</div>
<a class="anchor" id="acf4ccd7ccd1af1eaeb658e2c7da43055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a> cugl::Font::getMetrics </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>thechar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the glyph metrics for the given (Unicode) character.</p>
<p>See <a class="el" href="">FontGlyphMetrics</a> for an explanation of the data provided by this method. This method will fail if the glyph is not in this font.</p>
<p>The Unicode representation uses the endianness native to the platform. Therefore, this value should not be serialized. Use UTF8 to represent unicode in a platform-independent manner.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thechar</td><td>The Unicode character to measure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the glyph metrics for the given (Unicode) character. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e47f4a8530baf44a5f9dd8eb4e3600a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::Font::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the family name of this font.</p>
<p>This method may return an empty string, meaning the information is not available.</p>
<dl class="section return"><dt>Returns</dt><dd>the family name of this font. </dd></dl>

</div>
</div>
<a class="anchor" id="abd223ed9cd08f71f322540ec3ea87285"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getQuad </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>thechar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a single quad to render this character and stores it in vertices</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>Once the font is generated, offset will be adjusted to contain the next place to render a character. This method will not generate anything if the character is not supported by this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thechar</td><td>The character to convert to render data </td></tr>
    <tr><td class="paramname">offset</td><td>The (unkerned) starting position of the quad </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to</td></tr>
  </table>
  </dd>
</dl>
<p>If this font has an atlas, it will return the atlas texture. Otherwise, it is returning a unique texture specifically generated for this string.</p>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quad </dd></dl>

</div>
</div>
<a class="anchor" id="a1764052f38325f6181f56da92fe102f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getQuad </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>thechar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a single quad to render this character and stores it in vertices</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>The quad is adjusted so that all of the vertices fit in the provided rectangle. This may mean that no quad is generated at all.</p>
<p>Once the font is generated, offset will be adjusted to contain the next place to render a character. This method will not generate anything if the character is not supported by this font.</p>
<p>If this font has an atlas, it will return the atlas texture. Otherwise, it is returning a unique texture specifically generated for this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thechar</td><td>The character to convert to render data </td></tr>
    <tr><td class="paramname">offset</td><td>The (unkerned) starting position of the quad </td></tr>
    <tr><td class="paramname">rect</td><td>The bounding box for the quad </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quad </dd></dl>

</div>
</div>
<a class="anchor" id="a0935d1137dd48ff233a2e21004afc2c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getQuads </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates quads to render this string and stores them in vertices.</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>To use the quad sequence with <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>, you will also need a sequence of indices, which this method does not provide. However, the indices should be obvious, as the vertices are all a sequence of quads. Just create two triangles for each quad. The quad vertices are in the following order: top left, top right, bottom left, bottom right.</p>
<p>The origin value determines the position of the bottom of the glyph, including the descent. It is not the position of the baseline.</p>
<p>If this font has an atlas, it will return the atlas texture. Otherwise, it is returning a unique texture specifically generated for this string.</p>
<p>This method will fail if the string is not supported by this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to convert to render data. </td></tr>
    <tr><td class="paramname">origin</td><td>The position of the first character </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quads </dd></dl>

</div>
</div>
<a class="anchor" id="a342d37788e3d47f590c061d5c5528648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getQuads </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates quads to render this string and stores them in vertices.</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>To use the quad sequence with <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>, you will also need a sequence of indices, which this method does not provide. However, the indices should be obvious, as the vertices are all a sequence of quads. Just create two triangles for each quad. The quad vertices are in the following order: top left, top right, bottom left, bottom right.</p>
<p>The origin value determines the position of the bottom of the glyph, including the descent. It is not the position of the baseline.</p>
<p>If this font has an atlas, it will return the atlas texture. Otherwise, it is returning a unique texture specifically generated for this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to convert to render data. </td></tr>
    <tr><td class="paramname">origin</td><td>The position of the first character </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quads </dd></dl>

</div>
</div>
<a class="anchor" id="af3442c33f9bfec14bfedf95cb0bca5c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getQuads </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates quads to render this string and stores them in vertices.</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>The quad sequence is adjusted so that all of the vertices fit in the provided rectangle. This may mean that some of the glyphs are truncated or even omitted.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>To use the quad sequence with <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>, you will also need a sequence of indices, which this method does not provide. However, the indices should be obvious, as the vertices are all a sequence of quads. Just create two triangles for each quad. The quad vertices are in the following order: top left, top right, bottom left, bottom right.</p>
<p>The origin value determines the position of the bottom of the glyph, including the descent. It is not the position of the baseline.</p>
<p>If this font has an atlas, it will return the atlas texture. Otherwise, it is returning a unique texture specifically generated for this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to convert to render data. </td></tr>
    <tr><td class="paramname">origin</td><td>The position of the first character </td></tr>
    <tr><td class="paramname">rect</td><td>The bounding box for the quads. </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quads </dd></dl>

</div>
</div>
<a class="anchor" id="a8c2ac51dce00c34fcbb5c5077e981aec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getQuads </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates quads to render this string and stores them in vertices.</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>The quad sequence is adjusted so that all of the vertices fit in the provided rectangle. This may mean that some of the glyphs are truncated or even omitted.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>To use the quad sequence with <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>, you will also need a sequence of indices, which this method does not provide. However, the indices should be obvious, as the vertices are all a sequence of quads. Just create two triangles for each quad. The quad vertices are in the following order: top left, top right, bottom left, bottom right.</p>
<p>The origin value determines the position of the bottom of the glyph, including the descent. It is not the position of the baseline.</p>
<p>If this font has an atlas, it will return the atlas texture. Otherwise, it is returning a unique texture specifically generated for this string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to convert to render data. </td></tr>
    <tr><td class="paramname">origin</td><td>The position of the first character </td></tr>
    <tr><td class="paramname">rect</td><td>The bounding box for the quads. </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quads </dd></dl>

</div>
</div>
<a class="anchor" id="a3c9969235dae093dd28936fb3fb9141c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getRenderedQuad </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>thechar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a single quad to render this character and stores it in vertices</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>The quad is adjusted so that all of the vertices fit in the provided rectangle. This may mean that no quad is generated at all.</p>
<p>Once the font is generated, offset will be adjusted to contain the next place to render a character. This method will not generate anything if the character is not supported by this font.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thechar</td><td>The character to convert to render data </td></tr>
    <tr><td class="paramname">offset</td><td>The (unkerned) starting position of the quad </td></tr>
    <tr><td class="paramname">rect</td><td>The bounding box for the quad </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quads </dd></dl>

</div>
</div>
<a class="anchor" id="ae261e744c0584aa1f84b13a47d73d72c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::getRenderedQuads </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates quads to render this string and stores them in vertices.</p>
<p>This method will append the vertices to the given vertex list. In addition, it will return the texture that should be used with these vertices. If this is an atlas, the texture will be that atlas.</p>
<p>The quad sequence is adjusted so that all of the vertices fit in the provided rectangle. This may mean that some of the glyphs are truncated or even omitted.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>To use the quad sequence with <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>, you will also need a sequence of indices, which this method does not provide. However, the indices should be obvious, as the vertices are all a sequence of quads. Just create two triangles for each quad. The quad vertices are in the following order: top left, top right, bottom left, bottom right.</p>
<p>The origin value determines the position of the bottom of the glyph, including the descent. It is not the position of the baseline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to convert to render data. </td></tr>
    <tr><td class="paramname">origin</td><td>The position of the first character </td></tr>
    <tr><td class="paramname">rect</td><td>The bounding box for the quads. </td></tr>
    <tr><td class="paramname">vertices</td><td>The list to append the vertices to. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture associated with the quads </dd></dl>

</div>
</div>
<a class="anchor" id="ac1909eb3cef5bfc18f6923de2a1100d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">Resolution</a> cugl::Font::getResolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rendering resolution for this font.</p>
<p>The option SOLID is only useful for the case where there is no atlas. The preferred value for atlases and high quality fonts is BLENDED. However, when you need a font to "pop" out from a background, you may want SHADED instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the rendering resolution for this font. </dd></dl>

</div>
</div>
<a class="anchor" id="a46f8e5221b5a11d09d3ac3f1b946978f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Font::getSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size (in pixels) necessary to render this string.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>This size is a conservative estimate to render the string. The height is guaranteed to be the maximum height of the font, regardless of the text measured. In addition, the measurement will include the full advance of the both the first and last characters. This means that there may be some font-specific padding around these characters.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to measure. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in pixels) necessary to render this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a740aa1f729b7ec82268ed10cc47d3e2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Font::getSize </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>utf8</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size (in pixels) necessary to render this string.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically. However, by setting the optional value 'utf8' to false, you can speed up the method by skipping the text conversion.</p>
<p>This size is a conservative estimate to render the string. The height is guaranteed to be the maximum height of the font, regardless of the text measured. In addition, the measurement will include the full advance of the both the first and last characters. This means that there may be some font-specific padding around these characters.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to measure. </td></tr>
    <tr><td class="paramname">utf8</td><td>Whether the string is a UTF8 that must be decoded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in pixels) necessary to render this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a05b0df3694a3801c8369b1189c3939f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Font::getSizeASCII </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size (in pixels) necessary to render this string.</p>
<p>This size is a conservative estimate to render the string. The height is guaranteed to be the maximum height of the font, regardless of the text measured. In addition, the measurement will include the full advance of the both the first and last characters. This means that there may be some font-specific padding around these characters.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The ASCII string to measure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in pixels) necessary to render this string. </dd></dl>

</div>
</div>
<a class="anchor" id="a366eb72d1f77850b5168bc10c934898d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Font::getSizeUTF8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size (in pixels) necessary to render this string.</p>
<p>This size is a conservative estimate to render the string. The height is guaranteed to be the maximum height of the font, regardless of the text measured. In addition, the measurement will include the full advance of the both the first and last characters. This means that there may be some font-specific padding around these characters.</p>
<p>This measure does not actually render the string. This method will not fail if it includes glyphs not present in the font, but it will drop them when measuring the size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The UTF8 string to measure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in pixels) necessary to render this string. </dd></dl>

</div>
</div>
<a class="anchor" id="afc697f1397f7f3e49b9fb61aa8745167"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">Style</a> cugl::Font::getStyle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the style for this font.</p>
<p>With the exception of normal style (which is an absent of any style), all of the styles may be combined. So it is possible to have a bold, italic, underline font with strikethrough. To combine styles, simply treat the Style value as a bitmask, and combine them with bitwise operations.</p>
<dl class="section return"><dt>Returns</dt><dd>the style for this font. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bd2272a19e205b7211ab12de1b78e31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::Font::getStyleName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the style name of this font.</p>
<p>This method may return an empty string, meaning the information is not available.</p>
<dl class="section return"><dt>Returns</dt><dd>the style name of this font. </dd></dl>

</div>
</div>
<a class="anchor" id="a77aedf078e66dcef212f12fbdb4c9731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::hasAtlas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this font has an active atlas.</p>
<p>If this method is true, then <a class="el" href="classcugl_1_1_font.html#a12d1e49ac0df46cff75c556713d06fa9">getAtlas()</a> can be used to draw a font in a <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this font has an active atlas. </dd></dl>

</div>
</div>
<a class="anchor" id="aef13d46a64f9374b8ad1b95f270fc5a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::hasGlyph </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this font has a glyph for the given (ASCII) character.</p>
<p>If the font has an associated atlas, this will return true only if the character is in the atlas. You will need to clear the atlas to get the full range of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The ASCII character to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this font has a glyph for the given (ASCII) character. </dd></dl>

</div>
</div>
<a class="anchor" id="a7dac9c0da5cf5ee0cc64fd4e6607a5d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::hasGlyph </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this font has a glyph for the given (UNICODE) character.</p>
<p>The Unicode representation uses the endianness native to the platform. Therefore, this value should not be serialized. Use UTF8 to represent unicode in a platform-independent manner.</p>
<p>If the font has an associated atlas, this will return true only if the character is in the atlas. You will need to clear the atlas to get the full range of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The Unicode character to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this font has a glyph for the given (UNICODE) character. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0a10f20a61b0c06b5c501866ab25f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::hasString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this font can successfuly render the given string.</p>
<p>The string may either be in UTF8 or ASCII; the method will handle conversion automatically.</p>
<p>If the font has an associated atlas, this will return true only if the string characters are in the atlas. You will need to clear the atlas to get the full range of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this font can successfuly render the given string. </dd></dl>

</div>
</div>
<a class="anchor" id="a7aa237d8ed36326a33765f9e7b2836c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::hasString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this font can successfuly render the given string.</p>
<p>If the font has an associated atlas, this will return true only if the string characters are in the atlas. You will need to clear the atlas to get the full range of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The string to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this font can successfuly render the given string. </dd></dl>

</div>
</div>
<a class="anchor" id="a67a243b70d9bbafbf8079bdda79cd5c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a font of the given size from the file.</p>
<p>The font size is fixed on initialization. It cannot be changed without disposing of the entire font. However, all other attributes may be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file with the font asset </td></tr>
    <tr><td class="paramname">size</td><td>The font size in points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization is successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a57da614b343fb05239ca28946824314c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a font of the given size from the file.</p>
<p>The font size is fixed on initialization. It cannot be changed without disposing of the entire font. However, all other attributes may be changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The file with the font asset </td></tr>
    <tr><td class="paramname">size</td><td>The font size in points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization is successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a064a767706128d937f22170de2df2479"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::isFixedWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the font is a fixed width font.</p>
<p>Fixed width fonts are monospace, meaning every character that exists in the font is the same width. In this case you can assume that a rendered string's width is going to be the result of a simple calculation: </p><pre class="fragment"> glyph_width * string_length
</pre><dl class="section return"><dt>Returns</dt><dd>true if the font is a fixed width font. </dd></dl>

</div>
</div>
<a class="anchor" id="a12d55a17726fdfa91309996a0ff2224d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::layoutAtlas </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; Uint32 &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rectangle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Takes the rectangular plan and arranges the glyphs in the SDL surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rectangle</td><td>A plan for the atlas as a rectangular array of characters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1713d7035d5c071950eb8017596be9fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt;Uint32&gt; &gt; cugl::Font::planAtlas </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a plan for the atlas as a rectangular array of characters.</p>
<p>These characters are organized to fit in the size predicted by computeSize.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the bounding box </td></tr>
    <tr><td class="paramname">height</td><td>The height of the bounding box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a plan for the atlas as a rectangular array of characters. </dd></dl>

</div>
</div>
<a class="anchor" id="a17f3853837ef5c3fcf66e4110c5a5bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::prepareAtlas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepares an atlas of all of the ASCII glyphs in this font</p>
<p>This method records what glyphs are available in the atlas. It also stores the metrics and initializes the bounding rectangles.</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum width of this font atlas </dd></dl>

</div>
</div>
<a class="anchor" id="a0ee492ad1587767f29312c42216656c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::prepareAtlas </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>charset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prepares an atlas of the font glyphs from the given charset.</p>
<p>This method records what glyphs are available in the atlas. It also stores the metrics and initializes the bounding rectangles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charset</td><td>The set of characters to support</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the maximum width of this font atlas </dd></dl>

</div>
</div>
<a class="anchor" id="abcd13b18046709de9df2bbecd96b2699"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::prepareAtlasKerning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gathers the kerning information for the atlas. </p>

</div>
</div>
<a class="anchor" id="ac1746ce764084b49610118b73835db2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::setHinting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">Hinting</a>&#160;</td>
          <td class="paramname"><em>hinting</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the rasterization hints</p>
<p>Changing this value will delete any atlas that is present. The atlas must be regenerated.</p>
<p>Hinting is used to align the font to a rasterized grid. At low screen resolutions, hinting is critical for producing clear, legible text (particularly if you are not supporting antialiasing).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hinting</td><td>The rasterization hints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a981455a63a5617c50cdeaf62f5e3d681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::setKerning </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>kerning</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether this font atlas uses kerning when rendering.</p>
<p>Without kerning, each character is guaranteed to take up its enitre advance when rendered. This may make spacing look awkard. This value is true by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kerning</td><td>Whether this font atlas uses kerning when rendering. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa60d1b44b1ef29f2fabf9eb1fa249509"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::setResolution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">Resolution</a>&#160;</td>
          <td class="paramname"><em>resolution</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the rendering resolution for this font.</p>
<p>Changing this value will delete any atlas that is present. The atlas must be regenerated.</p>
<p>The option SOLID is only useful for the case where there is no atlas. The preferred value for atlases and high quality fonts is BLENDED. However, when you need a font to "pop" out from a background, you may want SHADED instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>The rendering resolution for this font. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac42819a5fe501b629211731f9293926b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Font::setStyle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">Style</a>&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the style for this font.</p>
<p>Changing this value will delete any atlas that is present. The atlas must be regenerated.</p>
<p>With the exception of normal style (which is an absent of any style), all of the styles may be combined. So it is possible to have a bold, italic, underline font with strikethrough. To combine styles, simply treat the Style value as a bitmask, and combine them with bitwise operations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>The style for this font. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a320e38b9ae79a36b3244a11a71bf162d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::usesKerning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this font atlas uses kerning when rendering.</p>
<p>Without kerning, each character is guaranteed to take up its enitre advance when rendered. This may make spacing look awkard. This value is true by default.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this font atlas uses kerning when rendering. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab1b39548de9faa8d511674b53824793b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TTF_Font* cugl::Font::_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The underlying SDL data </p>

</div>
</div>
<a class="anchor" id="abd3f7f702c86e8220b9bedb44a9a8688"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::_fixedWidth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this is a fixed width font </p>

</div>
</div>
<a class="anchor" id="a1ff1d74d40b9628234090ecad4481774"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Font::_fontAscent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum distance from the baseline to the glyph top (always positive) </p>

</div>
</div>
<a class="anchor" id="ae6dd95aa65b6cb99999934ba1e9052f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Font::_fontDescent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum distance from the baseline to the glyph bottom (always negative) </p>

</div>
</div>
<a class="anchor" id="a3d93b0b0506b506de010f799360554f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Font::_fontHeight</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (maximum) height of this font. It is the sum of ascent and descent. </p>

</div>
</div>
<a class="anchor" id="a180d9760bdf4ed605ac7eaabe986f53d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Font::_fontLineSkip</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The recommended line skip for this font </p>

</div>
</div>
<a class="anchor" id="a03595f99abada65a0735911d2ba70291"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;Uint32, <a class="el" href="classcugl_1_1_rect.html">Rect</a>&gt; cugl::Font::_glyphmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The location of each glyph in the atlas texture </p>

</div>
</div>
<a class="anchor" id="adbb4f0648ca0e43d16a46b9bb6767485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Uint32&gt; cugl::Font::_glyphset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The set of (unicode) glyphs supported by this atlas </p>

</div>
</div>
<a class="anchor" id="aca4224352c76e062f28f186cc9d21eeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;Uint32, <a class="el" href="classcugl_1_1_font_1_1_metrics.html">Metrics</a>&gt; cugl::Font::_glyphsize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cached metrics for each font glyph </p>

</div>
</div>
<a class="anchor" id="aa80e81489fd5ab235a799e59003e6d18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::_hasAtlas</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this font has an active atlas </p>

</div>
</div>
<a class="anchor" id="a0d437bebfd37db189209040d328ad61d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_font.html#a49ba6d1effb51058ff7894a2e82c8402">Hinting</a> cugl::Font::_hints</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The rasterization hints </p>

</div>
</div>
<a class="anchor" id="aab6d0766c0b3db7cd97debfc96a81410"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;Uint32, std::unordered_map&lt;Uint32, Uint32&gt; &gt; cugl::Font::_kernmap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The kerning for each pair of characters </p>

</div>
</div>
<a class="anchor" id="af3c089eb485a8f6f9c05dda9325fb89e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Font::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of this font (typically the family name if known) </p>

</div>
</div>
<a class="anchor" id="a34f2e355dc3967b189e46563a3da9cdc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_font.html#a79cd1cd3a7f758706e4c17db362c2e1f">Resolution</a> cugl::Font::_render</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The rendering resolution (when there is no atlas) </p>

</div>
</div>
<a class="anchor" id="a9669a630a5a6410207042b8f8b58cd03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Font::_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The font size in points </p>

</div>
</div>
<a class="anchor" id="aa2bdae721c92bfdc19dad474c4634b1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_font.html#a964dd2f6eca55047bb3a336c9c743448">Style</a> cugl::Font::_style</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The font face style </p>

</div>
</div>
<a class="anchor" id="a7e5c3b622c8fbfeb70e145c494158eda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Font::_stylename</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of this font style </p>

</div>
</div>
<a class="anchor" id="a2ebe91c5b596e5335ec15879ed0879dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDL_Surface* cugl::Font::_surface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A (temporary) SDL surface for computing the atlas texture </p>

</div>
</div>
<a class="anchor" id="ae929a330902280385a2c5a3e38e3888c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Font::_texture</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The OpenGL texture representing this atlas </p>

</div>
</div>
<a class="anchor" id="a9da79431f6a97419e02898ac1e92d296"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Font::_useKerning</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to use kerning when rendering </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/2d/<a class="el" href="_c_u_font_8h_source.html">CUFont.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::SpriteBatch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_sprite_batch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::SpriteBatch Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_sprite_batch_8h_source.html">CUSpriteBatch.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd2b8d2c9ab34b5c03f32019d1f6872b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#acd2b8d2c9ab34b5c03f32019d1f6872b">SpriteBatch</a> ()</td></tr>
<tr class="separator:acd2b8d2c9ab34b5c03f32019d1f6872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3434a113d7eadc5ce10194fa6d4b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ae9a3434a113d7eadc5ce10194fa6d4b1">~SpriteBatch</a> ()</td></tr>
<tr class="separator:ae9a3434a113d7eadc5ce10194fa6d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241abb9a7e9c1f3d06a6a0b519ce56cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a241abb9a7e9c1f3d06a6a0b519ce56cf">dispose</a> ()</td></tr>
<tr class="separator:a241abb9a7e9c1f3d06a6a0b519ce56cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5370fa1d9e46913ae2845173231481f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5370fa1d9e46913ae2845173231481f9">init</a> ()</td></tr>
<tr class="separator:a5370fa1d9e46913ae2845173231481f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0d14df8d3791dc1beb1af4dca4256d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aff0d14df8d3791dc1beb1af4dca4256d">init</a> (std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a> &gt; shader)</td></tr>
<tr class="separator:aff0d14df8d3791dc1beb1af4dca4256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e11a9542a2524a16d50ead5d67c31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ac14e11a9542a2524a16d50ead5d67c31">init</a> (unsigned int capacity)</td></tr>
<tr class="separator:ac14e11a9542a2524a16d50ead5d67c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae9fc9ab09df39eb9edc284a4295ef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aaae9fc9ab09df39eb9edc284a4295ef2">init</a> (unsigned int capacity, std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a> &gt; shader)</td></tr>
<tr class="separator:aaae9fc9ab09df39eb9edc284a4295ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3338ec0127ab953178260c641ba696c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ab3338ec0127ab953178260c641ba696c">isReady</a> () const </td></tr>
<tr class="separator:ab3338ec0127ab953178260c641ba696c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2ba1a0478cfeaca38170f8a28c9184"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5c2ba1a0478cfeaca38170f8a28c9184">isDrawing</a> () const </td></tr>
<tr class="separator:a5c2ba1a0478cfeaca38170f8a28c9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846c9766b8689988a4e8537a9bbcc2a6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a846c9766b8689988a4e8537a9bbcc2a6">getVerticesDrawn</a> () const </td></tr>
<tr class="separator:a846c9766b8689988a4e8537a9bbcc2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0af300ee75a71a80b040fe98cefefc8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ae0af300ee75a71a80b040fe98cefefc8">getCallsMade</a> () const </td></tr>
<tr class="separator:ae0af300ee75a71a80b040fe98cefefc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b0ee91a480b347501aafd5b5216c28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa3b0ee91a480b347501aafd5b5216c28">setShader</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a> &gt; &amp;shader)</td></tr>
<tr class="separator:aa3b0ee91a480b347501aafd5b5216c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7808fe7798ca0957daaec3394b2918fb"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a7808fe7798ca0957daaec3394b2918fb">getShader</a> () const </td></tr>
<tr class="separator:a7808fe7798ca0957daaec3394b2918fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb765e19a962101a78cc1b9bb9a7f328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#acb765e19a962101a78cc1b9bb9a7f328">setColor</a> (<a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:acb765e19a962101a78cc1b9bb9a7f328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf39ff76cd3a7141d1acd57f6ed7e395"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#adf39ff76cd3a7141d1acd57f6ed7e395">getColor</a> () const </td></tr>
<tr class="separator:adf39ff76cd3a7141d1acd57f6ed7e395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dec0c947f5bbbe0a63eefeb3456ab04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4dec0c947f5bbbe0a63eefeb3456ab04">setTexture</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture)</td></tr>
<tr class="separator:a4dec0c947f5bbbe0a63eefeb3456ab04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbaf5769ca3592dfd8899ed6b0d986d0"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#abbaf5769ca3592dfd8899ed6b0d986d0">getTexture</a> () const </td></tr>
<tr class="separator:abbaf5769ca3592dfd8899ed6b0d986d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223ec040a1ea222e00ad113168bee32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a223ec040a1ea222e00ad113168bee32f">setPerspective</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;perspective)</td></tr>
<tr class="separator:a223ec040a1ea222e00ad113168bee32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a763e79863e330e869290a7b44caed08f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a763e79863e330e869290a7b44caed08f">getPerspective</a> () const </td></tr>
<tr class="separator:a763e79863e330e869290a7b44caed08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1eb99b5196d5dbff63c0bba1fd6f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a3c1eb99b5196d5dbff63c0bba1fd6f5e">setBlendFunc</a> (GLenum srcFactor, GLenum dstFactor)</td></tr>
<tr class="separator:a3c1eb99b5196d5dbff63c0bba1fd6f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f0dcac8456aaf2951d37c809a6043b"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad5f0dcac8456aaf2951d37c809a6043b">getSourceBlendFactor</a> () const </td></tr>
<tr class="separator:ad5f0dcac8456aaf2951d37c809a6043b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73ea70831d9243606efb4c2ce79f85f"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#af73ea70831d9243606efb4c2ce79f85f">getDestinationBlendFactor</a> () const </td></tr>
<tr class="separator:af73ea70831d9243606efb4c2ce79f85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0113bb43b31702ad5a0cd2817db6938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ac0113bb43b31702ad5a0cd2817db6938">setBlendEquation</a> (GLenum equation)</td></tr>
<tr class="separator:ac0113bb43b31702ad5a0cd2817db6938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbac9febe09174f0614cbd24b3785365"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#abbac9febe09174f0614cbd24b3785365">getBlendEquation</a> () const </td></tr>
<tr class="separator:abbac9febe09174f0614cbd24b3785365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631a3759f253a59c79000f0736792dcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin</a> ()</td></tr>
<tr class="separator:a631a3759f253a59c79000f0736792dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57f31767c1e3dd4c1bda07a01348aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#af57f31767c1e3dd4c1bda07a01348aca">begin</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;perspective)</td></tr>
<tr class="separator:af57f31767c1e3dd4c1bda07a01348aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19d39209e70a6be006c2371de0c63a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end</a> ()</td></tr>
<tr class="separator:aa19d39209e70a6be006c2371de0c63a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4865921fb83cef24981dba2c1799934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad4865921fb83cef24981dba2c1799934">flush</a> ()</td></tr>
<tr class="separator:ad4865921fb83cef24981dba2c1799934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abf29896f0d95e85281ee4322f2f8cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a1abf29896f0d95e85281ee4322f2f8cd">fill</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a1abf29896f0d95e85281ee4322f2f8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97790349b13de080ae910422dc6edf41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a97790349b13de080ae910422dc6edf41">fill</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a97790349b13de080ae910422dc6edf41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263689b6096ed3dd6ca173f9b3498500"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a263689b6096ed3dd6ca173f9b3498500">fill</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a263689b6096ed3dd6ca173f9b3498500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f1ad2ae6d7efe1d7c8e25bed3d2e95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a02f1ad2ae6d7efe1d7c8e25bed3d2e95">fill</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a02f1ad2ae6d7efe1d7c8e25bed3d2e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29b9d75dd9fbc971eeef37b4d5bafc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa29b9d75dd9fbc971eeef37b4d5bafc5">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:aa29b9d75dd9fbc971eeef37b4d5bafc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e400dc01fac24121a6715053affc142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4e400dc01fac24121a6715053affc142">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a4e400dc01fac24121a6715053affc142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01189480c94f5999ca067434f6605fe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a01189480c94f5999ca067434f6605fe4">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a01189480c94f5999ca067434f6605fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e89a9b8619673e53d60896658077c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a9e89a9b8619673e53d60896658077c3c">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a9e89a9b8619673e53d60896658077c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b85875d2796115451a8cff88ffb605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a33b85875d2796115451a8cff88ffb605">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a33b85875d2796115451a8cff88ffb605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d326fce46384307e51d66e5cda76d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a9d326fce46384307e51d66e5cda76d5d">fill</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a9d326fce46384307e51d66e5cda76d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad988a08d3c747120d9a3386ecd75df5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad988a08d3c747120d9a3386ecd75df5a">fill</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:ad988a08d3c747120d9a3386ecd75df5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f466d012250a35d906225d1dae0738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a82f466d012250a35d906225d1dae0738">fill</a> (const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *vertices, unsigned int vsize, unsigned int voffset, const unsigned short *indices, unsigned int isize, unsigned int ioffset, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a82f466d012250a35d906225d1dae0738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2935dbccbf9861f006c3eee4532d0fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a2935dbccbf9861f006c3eee4532d0fe8">fill</a> (const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *vertices, unsigned int vsize, unsigned int voffset, const unsigned short *indices, unsigned int isize, unsigned int ioffset, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a2935dbccbf9861f006c3eee4532d0fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16861f1138f35644b5aaf639645b19f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a16861f1138f35644b5aaf639645b19f8">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a16861f1138f35644b5aaf639645b19f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921e1b059e28bd1d7f440e3b51f9123f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a921e1b059e28bd1d7f440e3b51f9123f">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a921e1b059e28bd1d7f440e3b51f9123f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69078bb30e579716e94db16565107d8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a69078bb30e579716e94db16565107d8e">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a69078bb30e579716e94db16565107d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806c2ccf6e63193f6a29daa6f4504fff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a806c2ccf6e63193f6a29daa6f4504fff">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a806c2ccf6e63193f6a29daa6f4504fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f40e476e271b1b77649584f3e220393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a2f40e476e271b1b77649584f3e220393">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a2f40e476e271b1b77649584f3e220393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145f8902599cbec2176ee2f82514e01d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a145f8902599cbec2176ee2f82514e01d">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a145f8902599cbec2176ee2f82514e01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa879b66d7e8fbf819ccf541338d25912"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa879b66d7e8fbf819ccf541338d25912">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:aa879b66d7e8fbf819ccf541338d25912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67df1cbb4203943bf0af67ede5a0a34b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a67df1cbb4203943bf0af67ede5a0a34b">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a67df1cbb4203943bf0af67ede5a0a34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c5620c2f99391305187f8592eae12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a367c5620c2f99391305187f8592eae12">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a367c5620c2f99391305187f8592eae12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7915925d0102a92fe433f4f634d634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5e7915925d0102a92fe433f4f634d634">outline</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a5e7915925d0102a92fe433f4f634d634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976736578885e0c1b729870476a2ae61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a976736578885e0c1b729870476a2ae61">outline</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a976736578885e0c1b729870476a2ae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be8a8db878147182861d52a531ab149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a0be8a8db878147182861d52a531ab149">outline</a> (const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *vertices, unsigned int vsize, unsigned int voffset, const unsigned short *indices, unsigned int isize, unsigned int ioffset, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a0be8a8db878147182861d52a531ab149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06674b8eba3002786a466c5abaa9e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa06674b8eba3002786a466c5abaa9e0c">outline</a> (const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *vertices, unsigned int vsize, unsigned int voffset, const unsigned short *indices, unsigned int isize, unsigned int ioffset, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:aa06674b8eba3002786a466c5abaa9e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8413f9dbf98dd481d57a25a6a3adeb5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a8413f9dbf98dd481d57a25a6a3adeb5b">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="separator:a8413f9dbf98dd481d57a25a6a3adeb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6666d1cac024c7c6c8b80db6f55ab6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aca6666d1cac024c7c6c8b80db6f55ab6">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="separator:aca6666d1cac024c7c6c8b80db6f55ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956aaf9536c33ee7417bbd39c03ab758"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a956aaf9536c33ee7417bbd39c03ab758">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds)</td></tr>
<tr class="separator:a956aaf9536c33ee7417bbd39c03ab758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33f38dda24639455efb2803a1fa4282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad33f38dda24639455efb2803a1fa4282">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds)</td></tr>
<tr class="separator:ad33f38dda24639455efb2803a1fa4282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e15c94f4cae29b71d5cd70595809670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4e15c94f4cae29b71d5cd70595809670">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a4e15c94f4cae29b71d5cd70595809670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e9934c11f6bb82ce56f468f8e232bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a19e9934c11f6bb82ce56f468f8e232bc">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a19e9934c11f6bb82ce56f468f8e232bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecb61c3bdd4801e63031c218cf129a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a8ecb61c3bdd4801e63031c218cf129a7">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a8ecb61c3bdd4801e63031c218cf129a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cbc4077d1e34d15f4524096060f37e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a06cbc4077d1e34d15f4524096060f37e">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a06cbc4077d1e34d15f4524096060f37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5966fee30fe842a958c9ffc1c5c656"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aef5966fee30fe842a958c9ffc1c5c656">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:aef5966fee30fe842a958c9ffc1c5c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562dc50c339f4cbfd4dfbe6b8c2e78bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a562dc50c339f4cbfd4dfbe6b8c2e78bd">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a562dc50c339f4cbfd4dfbe6b8c2e78bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85b88137a93f779ad9df3011425b6af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad85b88137a93f779ad9df3011425b6af">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:ad85b88137a93f779ad9df3011425b6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6130ca6e5e06e1c506b79723b54bbcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ac6130ca6e5e06e1c506b79723b54bbcf">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:ac6130ca6e5e06e1c506b79723b54bbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a6685999a280beb68e35cd4835323e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a83a6685999a280beb68e35cd4835323e">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a83a6685999a280beb68e35cd4835323e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e82f46c2ebdb656e3d02ad2168532d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a87e82f46c2ebdb656e3d02ad2168532d">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a87e82f46c2ebdb656e3d02ad2168532d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60330c54fb014c4f64d91be1c184b99e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a60330c54fb014c4f64d91be1c184b99e">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a60330c54fb014c4f64d91be1c184b99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5252a2a05241f5eabe006c99085be109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5252a2a05241f5eabe006c99085be109">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a5252a2a05241f5eabe006c99085be109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf7bd429a5a69210e0e16b537048d44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#afcf7bd429a5a69210e0e16b537048d44">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:afcf7bd429a5a69210e0e16b537048d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687a2d58d66e98373a6ddd056afe456b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a687a2d58d66e98373a6ddd056afe456b">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a687a2d58d66e98373a6ddd056afe456b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548faf20e1c35a8337d3db7be7af0685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a548faf20e1c35a8337d3db7be7af0685">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a548faf20e1c35a8337d3db7be7af0685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd147d2860a497f335817d18c9866f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a3dd147d2860a497f335817d18c9866f8">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a3dd147d2860a497f335817d18c9866f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91f851a5af07fad1bf878a27449f921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad91f851a5af07fad1bf878a27449f921">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:ad91f851a5af07fad1bf878a27449f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138fb76ccc370abc68242b056c185cb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a138fb76ccc370abc68242b056c185cb8">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a138fb76ccc370abc68242b056c185cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592f991987b2784061d458cc700035f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a592f991987b2784061d458cc700035f7">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a592f991987b2784061d458cc700035f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0662755a20e8be2e15d6756c69b9b46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ab0662755a20e8be2e15d6756c69b9b46">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, <a class="el" href="classcugl_1_1_color4.html">Color4</a> color, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:ab0662755a20e8be2e15d6756c69b9b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a668bcfcf2bb45136717251a662bc0711"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a668bcfcf2bb45136717251a662bc0711">alloc</a> ()</td></tr>
<tr class="separator:a668bcfcf2bb45136717251a662bc0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e57475eb54f204f5887d13af6c4909"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ab4e57475eb54f204f5887d13af6c4909">alloc</a> (unsigned int capacity)</td></tr>
<tr class="separator:ab4e57475eb54f204f5887d13af6c4909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc29b83c1ae6e9d59955b892528ff85"><td class="memItemLeft" align="right" valign="top">static const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a7bc29b83c1ae6e9d59955b892528ff85">getBlankTexture</a> ()</td></tr>
<tr class="separator:a7bc29b83c1ae6e9d59955b892528ff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a sprite batch for drawing 2d graphics.</p>
<p>A sprite batch gathers together sprites and draws them as a single mesh whenever possible. Changing the active texture requires that the sprite batch flush the mesh. Hence, using a single texture atlas can significantly improve drawing speed.</p>
<p>This is sprite batch is different from a classic sprite batch in that it can draw both solid shapes and outlines. Outlines use the same texturing rules that solids do.</p>
<p>In addition, this sprite batch is capable of drawing without an active texture. In that case, the shape will be drawn with a solid color. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acd2b8d2c9ab34b5c03f32019d1f6872b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::SpriteBatch::SpriteBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a degenerate sprite batch with no buffers.</p>
<p>You must initialize the buffer before using it. </p>

</div>
</div>
<a class="anchor" id="ae9a3434a113d7eadc5ce10194fa6d4b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::SpriteBatch::~SpriteBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the sprite batch, disposing all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a668bcfcf2bb45136717251a662bc0711"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>&gt; cugl::SpriteBatch::alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new sprite batch with the default vertex capacity.</p>
<p>The default vertex capacity is 8192 vertices and 8192*3 = 24576 indices. If the mesh exceeds these values, the sprite batch will flush before before continuing to draw. If you wish to increase (or decrease) the capacity, use the alternate initializer.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>a new sprite batch with the default vertex capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4e57475eb54f204f5887d13af6c4909"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>&gt; cugl::SpriteBatch::alloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new sprite batch with the given vertex capacity.</p>
<p>The index capacity will be 3 times the vertex capacity. The maximum number of possible indices is the maximum size_t, so the vertex size must be a third that.</p>
<p>If the mesh exceeds the capacity, the sprite batch will flush before before continuing to draw. You should tune your system to have the appropriate capacity. To small a capacity will cause the system to thrash. However, too large a capacity could stall on memory transfers.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>a new sprite batch with the given vertex capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="a631a3759f253a59c79000f0736792dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts drawing with the current perspective matrix.</p>
<p>This call will disable depth buffer writing. It enables blending and texturing. You must call <a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end()</a> to complete drawing.</p>
<p>Calling this method will reset the vertex and OpenGL call counters to 0. </p>

</div>
</div>
<a class="anchor" id="af57f31767c1e3dd4c1bda07a01348aca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>perspective</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts drawing with the given perspective matrix.</p>
<p>This call will disable depth buffer writing. It enables blending and texturing. You must call <a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end()</a> to complete drawing.</p>
<p>Calling this method will reset the vertex and OpenGL call counters to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perspective</td><td>The perspective matrix to draw with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a241abb9a7e9c1f3d06a6a0b519ce56cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the vertex buffers and resets all attributes.</p>
<p>You must reinitialize the sprite batch to use it. </p>

</div>
</div>
<a class="anchor" id="a8413f9dbf98dd481d57a25a6a3adeb5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a rectangle of the size of the texture, with bottom left corner at the given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">position</td><td>The bottom left corner of the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca6666d1cac024c7c6c8b80db6f55ab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a rectangle of the size of the texture, with bottom left corner at the given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">position</td><td>The bottom left corner of the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a956aaf9536c33ee7417bbd39c03ab758"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the texture (without tint) inside the given bounds</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the specified rectangle filled with the texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad33f38dda24639455efb2803a1fa4282"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted texture at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the specified rectangle filled with the texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e15c94f4cae29b71d5cd70595809670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given parameters.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in texture pixel coordinates (e.g from the bottom) left corner).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The texture origin offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a19e9934c11f6bb82ce56f468f8e232bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given parameters.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in texture pixel coordinates (e.g from the bottom) left corner).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The texture origin offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ecb61c3bdd4801e63031c218cf129a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the rectangle centered at the given origin, and transformed by the given parameters.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle). A rectangle should be centered on the origin to rotate properly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The texture origin offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06cbc4077d1e34d15f4524096060f37e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the rectangle centered at the given origin, and transformed by the given parameters.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle). A rectangle should be centered on the origin to rotate properly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The texture origin offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef5966fee30fe842a958c9ffc1c5c656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a562dc50c339f4cbfd4dfbe6b8c2e78bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad85b88137a93f779ad9df3011425b6af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the rectangle centered at the given origin, and transformed by the given matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6130ca6e5e06e1c506b79723b54bbcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the rectangle centered at the given origin, and transformed by the given matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a83a6685999a280beb68e35cd4835323e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the affine matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given affine matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a87e82f46c2ebdb656e3d02ad2168532d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the affine matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given affine matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60330c54fb014c4f64d91be1c184b99e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the affine matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the rectangle centered at the given origin, and transformed by the given affine matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5252a2a05241f5eabe006c99085be109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the affine matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the rectangle centered at the given origin, and transformed by the given affine matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcf7bd429a5a69210e0e16b537048d44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the textured polygon (without tint) at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, offset by the given value.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a687a2d58d66e98373a6ddd056afe456b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted, textured polygon at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, offset by the given value.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a548faf20e1c35a8337d3db7be7af0685"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the textured polygon (without tint) transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given parameters.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle) a rectangle should be centered on the origin to rotate properly.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3dd147d2860a497f335817d18c9866f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted, textured polygon transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given parameters.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle) a rectangle should be centered on the origin to rotate properly.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad91f851a5af07fad1bf878a27449f921"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the textured polygon (without tint) transformed by the given matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a138fb76ccc370abc68242b056c185cb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted, textured polygon transformed by the given matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a592f991987b2784061d458cc700035f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the textured polygon (without tint) transformed by the given affine matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given affine matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab0662755a20e8be2e15d6756c69b9b46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws the tinted, textured polygon transformed by the given affine matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given affine matrix.</p>
<p>The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa19d39209e70a6be006c2371de0c63a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes the drawing pass for this sprite batch, flushing the buffer.</p>
<p>This method enables depth writes and disables blending and texturing. It Must always be called after a call to <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin()</a>. </p>

</div>
</div>
<a class="anchor" id="a1abf29896f0d95e85281ee4322f2f8cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The texture will fill the entire rectangle with texture coordinate (0,1) at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97790349b13de080ae910422dc6edf41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle). A rectangle should be centered on the origin to rotate properly.</p>
<p>The texture will fill the entire rectangle before being transformed. <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) will at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the rectangle </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the rectangle </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a263689b6096ed3dd6ca173f9b3498500"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The rectangle will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<p>The texture will fill the entire rectangle with texture coordinate (0,1) at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a { <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>} for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02f1ad2ae6d7efe1d7c8e25bed3d2e95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The rectangle will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<p>The texture will fill the entire rectangle with texture coordinate (0,1) at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a { <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>} for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa29b9d75dd9fbc971eeef37b4d5bafc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e400dc01fac24121a6715053affc142"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon will be offset by the given position.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01189480c94f5999ca067434f6605fe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle) a rectangle should be centered on the origin to rotate properly.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e89a9b8619673e53d60896658077c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33b85875d2796115451a8cff88ffb605"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d326fce46384307e51d66e5cda76d5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the triangulated vertices with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space.</p>
<p>The triangulation will be determined by the given indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The list of vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation list </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad988a08d3c747120d9a3386ecd75df5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the triangulated vertices with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space.</p>
<p>The triangulation will be determined by the given indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The list of vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation list </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a82f466d012250a35d906225d1dae0738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>voffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>isize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ioffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the triangulated vertices with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space.</p>
<p>The triangulation will be determined by the given indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices </td></tr>
    <tr><td class="paramname">vsize</td><td>The size of the vertex array </td></tr>
    <tr><td class="paramname">voffset</td><td>The first element of the vertex array </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation array </td></tr>
    <tr><td class="paramname">isize</td><td>The size of the index array </td></tr>
    <tr><td class="paramname">ioffset</td><td>The first element of the index array </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2935dbccbf9861f006c3eee4532d0fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>voffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>isize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ioffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the triangulated vertices with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space.</p>
<p>The triangulation will be determined by the given indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="">ComplexTriangulator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices </td></tr>
    <tr><td class="paramname">vsize</td><td>The size of the vertex array </td></tr>
    <tr><td class="paramname">voffset</td><td>The first element of the vertex array </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation array </td></tr>
    <tr><td class="paramname">isize</td><td>The size of the index array </td></tr>
    <tr><td class="paramname">ioffset</td><td>The first element of the index array </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4865921fb83cef24981dba2c1799934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes the current mesh without completing the drawing pass.</p>
<p>This method is called whenever you change any attribute other than color mid-pass. It prevents the attribute change from retoactively affecting previuosly drawn shapes. </p>

</div>
</div>
<a class="anchor" id="a7bc29b83c1ae6e9d59955b892528ff85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::SpriteBatch::getBlankTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the blank texture used to make solid shapes</p>
<p>This is the texture used when the active texture is nullptr. Using this texture means that all shapes and outlines will be drawn with a solid color instead.</p>
<dl class="section return"><dt>Returns</dt><dd>the blank texture used to make solid shapes </dd></dl>

</div>
</div>
<a class="anchor" id="abbac9febe09174f0614cbd24b3785365"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::SpriteBatch::getBlendEquation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the blending equation for this sprite batch</p>
<p>By default this value is GL_FUNC_ADD. For other options, see </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendEquation.xhtml
</pre><dl class="section return"><dt>Returns</dt><dd>the blending equation for this sprite batch </dd></dl>

</div>
</div>
<a class="anchor" id="ae0af300ee75a71a80b040fe98cefefc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::SpriteBatch::getCallsMade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of OpenGL calls in the latest pass (so far).</p>
<p>This value will be reset to 0 whenever <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of OpenGL calls in the latest pass (so far). </dd></dl>

</div>
</div>
<a class="anchor" id="adf39ff76cd3a7141d1acd57f6ed7e395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::SpriteBatch::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the active color of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will be tinted by this color. This color is white by default.</p>
<dl class="section return"><dt>Returns</dt><dd>the active color of this sprite batch </dd></dl>

</div>
</div>
<a class="anchor" id="af73ea70831d9243606efb4c2ce79f85f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::SpriteBatch::getDestinationBlendFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the destination blending factor</p>
<p>By default this value is GL_ONE_MINUS_SRC_ALPHA. For other options, see </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml
</pre><dl class="section return"><dt>Returns</dt><dd>the destination blending factor </dd></dl>

</div>
</div>
<a class="anchor" id="a763e79863e330e869290a7b44caed08f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&amp; cugl::SpriteBatch::getPerspective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the active perspective matrix of this sprite batch</p>
<p>The perspective matrix is the combined modelview-projection from the camera. By default, this is the identity matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the active perspective matrix of this sprite batch </dd></dl>

</div>
</div>
<a class="anchor" id="a7808fe7798ca0957daaec3394b2918fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a>&gt;&amp; cugl::SpriteBatch::getShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the shader for this sprite batch</p>
<p>This value may NOT be changed during a drawing pass.</p>
<dl class="section return"><dt>Returns</dt><dd>the shader for this sprite batch </dd></dl>

</div>
</div>
<a class="anchor" id="ad5f0dcac8456aaf2951d37c809a6043b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::SpriteBatch::getSourceBlendFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the source blending factor</p>
<p>By default this value is GL_SRC_ALPHA. For other options, see </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml
</pre><dl class="section return"><dt>Returns</dt><dd>the source blending factor </dd></dl>

</div>
</div>
<a class="anchor" id="abbaf5769ca3592dfd8899ed6b0d986d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::SpriteBatch::getTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the active texture of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will use this texture. If the value is nullptr, all shapes and outlines will be drawn with a solid color instead. This value is nullptr by default.</p>
<dl class="section return"><dt>Returns</dt><dd>the active texture of this sprite batch </dd></dl>

</div>
</div>
<a class="anchor" id="a846c9766b8689988a4e8537a9bbcc2a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::SpriteBatch::getVerticesDrawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of vertices drawn in the latest pass (so far).</p>
<p>This value will be reset to 0 whenever <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of vertices drawn in the latest pass (so far). </dd></dl>

</div>
</div>
<a class="anchor" id="a5370fa1d9e46913ae2845173231481f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the default vertex capacity.</p>
<p>The default vertex capacity is 8192 vertices and 8192*3 = 24576 indices. If the mesh exceeds these values, the sprite batch will flush before before continuing to draw. If you wish to increase (or decrease) the capacity, use the alternate initializer.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="aff0d14df8d3791dc1beb1af4dca4256d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a> &gt;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the default vertex capacity and given shader</p>
<p>The default vertex capacity is 8192 vertices and 8192*3 = 24576 indices. If the mesh exceeds these values, the sprite batch will flush before before continuing to draw. If you wish to increase (or decrease) the capacity, use the alternate initializer.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ac14e11a9542a2524a16d50ead5d67c31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the given vertex capacity.</p>
<p>The index capacity will be 3 times the vertex capacity. The maximum number of possible indices is the maximum size_t, so the vertex size must be a third that.</p>
<p>If the mesh exceeds the capacity, the sprite batch will flush before before continuing to draw. You should tune your system to have the appropriate capacity. To small a capacity will cause the system to thrash. However, too large a capacity could stall on memory transfers.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae9fc9ab09df39eb9edc284a4295ef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a> &gt;&#160;</td>
          <td class="paramname"><em>shader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the given vertex capacity and shader</p>
<p>The index capacity will be 3 times the vertex capacity. The maximum number of possible indices is the maximum size_t, so the vertex size must be a third that.</p>
<p>If the mesh exceeds the capacity, the sprite batch will flush before before continuing to draw. You should tune your system to have the appropriate capacity. To small a capacity will cause the system to thrash. However, too large a capacity could stall on memory transfers.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c2ba1a0478cfeaca38170f8a28c9184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::isDrawing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this sprite batch is actively drawing.</p>
<p>A sprite batch is in use if <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin()</a> has been called without the requisite <a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end()</a> to flush the pipeline.</p>
<dl class="section return"><dt>Returns</dt><dd>whether this sprite batch is actively drawing. </dd></dl>

</div>
</div>
<a class="anchor" id="ab3338ec0127ab953178260c641ba696c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this sprite batch has been initialized and is ready for use.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this sprite batch has been initialized and is ready for use. </dd></dl>

</div>
</div>
<a class="anchor" id="a16861f1138f35644b5aaf639645b19f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a921e1b059e28bd1d7f440e3b51f9123f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle) a rectangle should be centered on the origin to rotate properly.</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the rectangle </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the rectangle </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69078bb30e579716e94db16565107d8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The rectangle will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a806c2ccf6e63193f6a29daa6f4504fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The rectangle will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the rectangle bounds).</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f40e476e271b1b77649584f3e220393"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a145f8902599cbec2176ee2f82514e01d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon will be offset by the given position.</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa879b66d7e8fbf819ccf541338d25912"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in world coordinates (not relative to the rectangle) a rectangle should be centered on the origin to rotate properly.</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The rotation origin </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67df1cbb4203943bf0af67ede5a0a34b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a367c5620c2f99391305187f8592eae12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified in world world coordinates (but which should ideally be inside the polygon bounds).</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The coordinate origin </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e7915925d0102a92fe433f4f634d634"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outlines the vertex path with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other outline methods. The texture no longer needs to be drawn uniformly over the wireframe. The transform will be applied to the vertex positions directly in world space.</p>
<p>The vertex path will be determined by the provided indices. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The list of vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation list </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a976736578885e0c1b729870476a2ae61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outlines the vertex path with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other outline methods. The texture no longer needs to be drawn uniformly over the wireframe. The transform will be applied to the vertex positions directly in world space.</p>
<p>The vertex path will be determined by the provided indices. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The list of vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation list </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0be8a8db878147182861d52a531ab149"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>voffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>isize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ioffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the vertex path with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other outline methods. The texture no longer needs to be drawn uniformly over the wireframe. The transform will be applied to the vertex positions directly in world space.</p>
<p>The vertex path will be determined by the provided indices. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices </td></tr>
    <tr><td class="paramname">vsize</td><td>The size of the vertex array </td></tr>
    <tr><td class="paramname">voffset</td><td>The first element of the vertex array </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation array </td></tr>
    <tr><td class="paramname">isize</td><td>The size of the index array </td></tr>
    <tr><td class="paramname">ioffset</td><td>The first element of the index array </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa06674b8eba3002786a466c5abaa9e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vertex2.html">Vertex2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>voffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>isize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ioffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the vertex path with the current texture.</p>
<p>This method provides more fine tuned control over texture coordinates that the other outline methods. The texture no longer needs to be drawn uniformly over the wireframe. The transform will be applied to the vertex positions directly in world space.</p>
<p>The vertex path will be determined by the provided indices. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a> or <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>.</p>
<p>The vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices </td></tr>
    <tr><td class="paramname">vsize</td><td>The size of the vertex array </td></tr>
    <tr><td class="paramname">voffset</td><td>The first element of the vertex array </td></tr>
    <tr><td class="paramname">indices</td><td>The triangulation array </td></tr>
    <tr><td class="paramname">isize</td><td>The size of the index array </td></tr>
    <tr><td class="paramname">ioffset</td><td>The first element of the index array </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac0113bb43b31702ad5a0cd2817db6938"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setBlendEquation </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>equation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the blending equation for this sprite batch</p>
<p>The enum must be a standard ones supported by OpenGL. See </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendEquation.xhtml
</pre><p>However, this setter does not do any error checking to verify that the input is valid. By default, the equation is GL_FUNC_ADD.</p>
<p>Changing this value will cause the sprite batch to flush.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equation</td><td>Specifies how source and destination colors are combined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c1eb99b5196d5dbff63c0bba1fd6f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setBlendFunc </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>srcFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>dstFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the blending function for this sprite batch</p>
<p>The enums are the standard ones supported by OpenGL. See </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml
</pre><p>However, this setter does not do any error checking to verify that the enums are valid. By default, srcFactor is GL_SRC_ALPHA while dstFactor is GL_ONE_MINUS_SRC_ALPHA. This corresponds to non-premultiplied alpha blending.</p>
<p>Changing this value will cause the sprite batch to flush.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcFactor</td><td>Specifies how the source blending factors are computed </td></tr>
    <tr><td class="paramname">dstFactor</td><td>Specifies how the destination blending factors are computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb765e19a962101a78cc1b9bb9a7f328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the active color of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will be tinted by this color. This color is white by default.</p>
<p>Changing this value will not cause the sprite batch to flush.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The active color for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a223ec040a1ea222e00ad113168bee32f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setPerspective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>perspective</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active perspective matrix of this sprite batch</p>
<p>The perspective matrix is the combined modelview-projection from the camera. By default, this is the identity matrix. Changing this value will cause the sprite batch to flush.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perspective</td><td>The active perspective matrix for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3b0ee91a480b347501aafd5b5216c28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setShader </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_shader.html">SpriteShader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the shader for this sprite batch</p>
<p>This value may NOT be changed during a drawing pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The active color for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dec0c947f5bbbe0a63eefeb3456ab04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setTexture </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active texture of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will use this texture. If the value is nullptr, all shapes and outlines will be draw with a solid color instead. This value is nullptr by default.</p>
<p>Changing this value will cause the sprite batch to flush. However, a subtexture will not cause a pipeline flush. This is an important argument for using texture atlases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The active texture for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/renderer/<a class="el" href="_c_u_sprite_batch_8h_source.html">CUSpriteBatch.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

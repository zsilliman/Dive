<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::CubicSplineApproximator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcugl_1_1_cubic_spline_approximator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::CubicSplineApproximator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_cubic_spline_approximator_8h_source.html">CUCubicSplineApproximator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac599adf3937c93e2f9418324f611a1f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9">Criterion</a> { <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9a3d85b771408c776a24d9e6c0fa0c6557">FLAT</a>, 
<a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9aff85a8dc44e0c3841d5c3877fe53221e">DISTANCE</a>, 
<a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9a20d705cdf44854312da1359e9cf309a0">SPACING</a>
 }<tr class="separator:ac599adf3937c93e2f9418324f611a1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a949cafe5dbb2e11d249226c8ea3f2763"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a949cafe5dbb2e11d249226c8ea3f2763">CubicSplineApproximator</a> ()</td></tr>
<tr class="separator:a949cafe5dbb2e11d249226c8ea3f2763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e0170fc87ef13f9fd3266056b8396e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a11e0170fc87ef13f9fd3266056b8396e">CubicSplineApproximator</a> (const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> *spline)</td></tr>
<tr class="separator:a11e0170fc87ef13f9fd3266056b8396e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043c48aea7e9c308161e4c8c9286b68d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a043c48aea7e9c308161e4c8c9286b68d">~CubicSplineApproximator</a> ()</td></tr>
<tr class="separator:a043c48aea7e9c308161e4c8c9286b68d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8b09060ca54412ab15dd058be2a788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a4d8b09060ca54412ab15dd058be2a788">set</a> (const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> *spline)</td></tr>
<tr class="separator:a4d8b09060ca54412ab15dd058be2a788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ad2d5379ca952dc0ba65427165574b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a98ad2d5379ca952dc0ba65427165574b">reset</a> ()</td></tr>
<tr class="separator:a98ad2d5379ca952dc0ba65427165574b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86effd6e50e78425a1ac96e22a6b9da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ab86effd6e50e78425a1ac96e22a6b9da">clear</a> ()</td></tr>
<tr class="separator:ab86effd6e50e78425a1ac96e22a6b9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16e29713044105c66a343e9e872df70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate</a> (<a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9">Criterion</a> criterion=Criterion::DISTANCE, float tolerance=DEFAULT_TOLERANCE)</td></tr>
<tr class="separator:af16e29713044105c66a343e9e872df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc3bd4747512894b08edc698ba9b6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a4dc3bd4747512894b08edc698ba9b6a2">getPath</a> () const </td></tr>
<tr class="separator:a4dc3bd4747512894b08edc698ba9b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63f0d7a93bd1edba295766dffb71c73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac63f0d7a93bd1edba295766dffb71c73">getPath</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer) const </td></tr>
<tr class="separator:ac63f0d7a93bd1edba295766dffb71c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d13c4bb18996b9d40c96245cae64288"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a2d13c4bb18996b9d40c96245cae64288">getParameters</a> () const </td></tr>
<tr class="separator:a2d13c4bb18996b9d40c96245cae64288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f59f52e9ebe065436159c42ad70f5f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a35f59f52e9ebe065436159c42ad70f5f">getParameters</a> (std::vector&lt; float &gt; buffer)</td></tr>
<tr class="separator:a35f59f52e9ebe065436159c42ad70f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13652443d37778fcd2cbb4a88ccfd300"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a13652443d37778fcd2cbb4a88ccfd300">getTangents</a> () const </td></tr>
<tr class="separator:a13652443d37778fcd2cbb4a88ccfd300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28724c163ce6260fcfd94e10ae37db1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac28724c163ce6260fcfd94e10ae37db1">getTangents</a> (std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; buffer)</td></tr>
<tr class="separator:ac28724c163ce6260fcfd94e10ae37db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e077eb76c8b791e21d8c2eda4fb788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a48e077eb76c8b791e21d8c2eda4fb788">getTangents</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer)</td></tr>
<tr class="separator:a48e077eb76c8b791e21d8c2eda4fb788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9d32075041820701b64fd736dad0a0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a9f9d32075041820701b64fd736dad0a0">getNormals</a> () const </td></tr>
<tr class="separator:a9f9d32075041820701b64fd736dad0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24826e0545581ede60f3a7d40d5f8504"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a24826e0545581ede60f3a7d40d5f8504">getNormals</a> (std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; buffer)</td></tr>
<tr class="separator:a24826e0545581ede60f3a7d40d5f8504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2cb0f89bfa367d2829f3b4f277a8c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#aae2cb0f89bfa367d2829f3b4f277a8c4">getNormals</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer)</td></tr>
<tr class="separator:aae2cb0f89bfa367d2829f3b4f277a8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0872d2a05cc4425197d45b5ba56c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a2e0872d2a05cc4425197d45b5ba56c62">getAnchors</a> (float radius, int segments=4) const </td></tr>
<tr class="separator:a2e0872d2a05cc4425197d45b5ba56c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd87549cbee9545b5c2c0ce1e1ac3a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#acd87549cbee9545b5c2c0ce1e1ac3a98">getAnchors</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer, float radius, int segments=4) const </td></tr>
<tr class="separator:acd87549cbee9545b5c2c0ce1e1ac3a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d00e0b0305d290491bee791a7bdbf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ad3d00e0b0305d290491bee791a7bdbf5">getHandles</a> (float radius, int segments=4) const </td></tr>
<tr class="separator:ad3d00e0b0305d290491bee791a7bdbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d10efe587f8a65b7a09908d423d974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ae0d10efe587f8a65b7a09908d423d974">getHandles</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer, float radius, int segments=4) const </td></tr>
<tr class="separator:ae0d10efe587f8a65b7a09908d423d974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7803fa5adb49f83cb3fd5576831cb0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#aa7803fa5adb49f83cb3fd5576831cb0f">getRefinement</a> () const </td></tr>
<tr class="separator:aa7803fa5adb49f83cb3fd5576831cb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de4d808155c30ef9a7f5f04f8a20ce1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#a7de4d808155c30ef9a7f5f04f8a20ce1">getRefinement</a> (<a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> *buffer) const </td></tr>
<tr class="separator:a7de4d808155c30ef9a7f5f04f8a20ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a factory for producing <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> objects from a <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>.</p>
<p>In order to draw a cubic spline, we must first convert it to a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object. All of our rendering tools are designed around the basic <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> class. In addition to generating a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for the spline path, this class can also generate <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> objects for UI elements such as handles and anchors.</p>
<p>As with all factories, the methods are broken up into three phases: initialization, calculation, and materialization. To use the factory, you first set the data (in this case a pointer to a <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>) with the initialization methods. You then call the calculation method. Finally, you use the materialization methods to access the data in several different ways.</p>
<p>This division allows us to support multithreaded calculation if the data generation takes too long. However, not that this factory keeps a pointer to the spline, and it is unsafe to modify the spline while the calculation is ongoing. If you do multithread the calculation, you should force the user to copy the spline first. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ac599adf3937c93e2f9418324f611a1f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9">cugl::CubicSplineApproximator::Criterion</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Termination criteria for de Castlejau's recursive subdivision</p>
<p>This is used by the polygon approximation functions. To convert a bezier into a polygon, we recursively subdivide the bezier until we reach the terminal condition. We then use the anchor points of the subdivided bezier to define our polygon. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac599adf3937c93e2f9418324f611a1f9a3d85b771408c776a24d9e6c0fa0c6557"></a>FLAT&#160;</td><td class="fielddoc">
<p>The FLAT termination criterion.</p>
<p>It guarantees a limit on the flatness (which in this context means the distance from the curve to the polygon divided by point spacing). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac599adf3937c93e2f9418324f611a1f9aff85a8dc44e0c3841d5c3877fe53221e"></a>DISTANCE&#160;</td><td class="fielddoc">
<p>The DISTANCE termination criterion.</p>
<p>It guarantees that the curve lies within a certain distance from the polygon defined by the points. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac599adf3937c93e2f9418324f611a1f9a20d705cdf44854312da1359e9cf309a0"></a>SPACING&#160;</td><td class="fielddoc">
<p>The SPACING termination criterion .</p>
<p>It guarantees that the points will be less than a certain distance apart. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a949cafe5dbb2e11d249226c8ea3f2763"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSplineApproximator::CubicSplineApproximator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a spline approximator with no spline data. </p>

</div>
</div>
<a class="anchor" id="a11e0170fc87ef13f9fd3266056b8396e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSplineApproximator::CubicSplineApproximator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> *&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a spline approximator with the given spline as its initial data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spline</td><td>The spline to approximate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a043c48aea7e9c308161e4c8c9286b68d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSplineApproximator::~CubicSplineApproximator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this spline approximator, releasing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="af16e29713044105c66a343e9e872df70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSplineApproximator::calculate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9">Criterion</a>&#160;</td>
          <td class="paramname"><em>criterion</em> = <code>Criterion::DISTANCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>DEFAULT_TOLERANCE</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs an approximation of the current spline</p>
<p>A polygon approximation is creating by recursively calling de Castlejau's until we reach a stopping condition. The stopping condition is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#ac599adf3937c93e2f9418324f611a1f9">Criterion</a>. See that enum for a description of how the various stopping conditions work. The tolerance is the value associated with the condition. For example, for condition DISTANCE, tolerance is how far the point can be away from the true curve.</p>
<p>The calculation uses a reference to the spline; it does not copy it. Hence this method is not thread-safe. If you are using this method in a task thread, you should copy the spline first before starting the calculation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">criterion</td><td>the stopping condition criterion </td></tr>
    <tr><td class="paramname">tolerance</td><td>the error tolerance of the stopping condition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab86effd6e50e78425a1ac96e22a6b9da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSplineApproximator::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all internal data, including the spline data.</p>
<p>When this method is called, you will need to set a new spline before calling calculate. </p>

</div>
</div>
<a class="anchor" id="a2e0872d2a05cc4425197d45b5ba56c62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::CubicSplineApproximator::getAnchors </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segments</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> representing handles for the anchor points</p>
<p>This method returns a collection of vertex information for handles at the anchor points. Handles are circular shapes of a given radius. This information may be drawn to provide a visual representation of the anchor points (as seen in Adobe Illustrator).</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose anchors for the control points on the original spline. This latter option is useful when you want to draw a UI for the original control points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>the radius of each handle </td></tr>
    <tr><td class="paramname">segments</td><td>the number of segments in the handle "circle"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> representing handles for the anchor points </dd></dl>

</div>
</div>
<a class="anchor" id="acd87549cbee9545b5c2c0ce1e1ac3a98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::CubicSplineApproximator::getAnchors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segments</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores vertex information representing the anchor points in the buffer.</p>
<p>This method creates a collection of vertex information for handles at the anchor points. Handles are circular shapes of a given radius. This information may be drawn to provide a visual representation of the anchor points (as seen in Adobe Illustrator).</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose anchors for the control points on the original spline. This latter option is useful when you want to draw a UI for the original control points.</p>
<p>The vertices (and indices) will be appended to the the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> if it is not empty. You should clear the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the vertex data </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of each handle </td></tr>
    <tr><td class="paramname">segments</td><td>The number of segments in the handle "circle"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3d00e0b0305d290491bee791a7bdbf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::CubicSplineApproximator::getHandles </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segments</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> representing handles for the tangent points</p>
<p>This method returns vertex information for handles at the tangent points. Handles are circular shapes of a given radius. This information may be passed to a <a class="el" href="classcugl_1_1_polygon_node.html">PolygonNode</a> to provide a visual representation of the tangent points (as seen in Adobe Illustrator).</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose the tangents from the control points on the original spline. This latter option is useful when you want to draw a UI for the original tangent points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>the radius of each handle </td></tr>
    <tr><td class="paramname">segments</td><td>the number of segments in the handle "circle"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> representing handles for the tangent points </dd></dl>

</div>
</div>
<a class="anchor" id="ae0d10efe587f8a65b7a09908d423d974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::CubicSplineApproximator::getHandles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segments</em> = <code>4</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores vertex information representing tangent point handles in the buffer.</p>
<p>This method creates vertex information for handles at the tangent points. Handles are circular shapes of a given radius. This information may be passed to a <a class="el" href="classcugl_1_1_polygon_node.html">PolygonNode</a> to provide a visual representation of the tangent points (as seen in Adobe Illustrator).</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose the tangents from the control points on the original spline. This latter option is useful when you want to draw a UI for the original tangent points.</p>
<p>The vertices (and indices) will be appended to the the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> if it is not empty. You should clear the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the vertex data </td></tr>
    <tr><td class="paramname">radius</td><td>the radius of each handle </td></tr>
    <tr><td class="paramname">segments</td><td>the number of segments in the handle "circle"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a9f9d32075041820701b64fd736dad0a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt; cugl::CubicSplineApproximator::getNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of normals for a polygon approximation</p>
<p>There is one normal per control point. If polygon contains n points, this method will also return n normals. The normals are determined by the right tangents. If the spline is open, then the normal of the last point is determined by its left tangent.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose normals for the control points on the original spline. This latter option is useful when you want to draw a UI for the control point normals.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of normals for a polygon approximation </dd></dl>

</div>
</div>
<a class="anchor" id="a24826e0545581ede60f3a7d40d5f8504"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::CubicSplineApproximator::getNormals </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a list of normals for the approximation in the buffer.</p>
<p>There is one normal per control point. If polygon contains n points, this method will also return n normals. The normals are determined by the right tangents. If the spline is open, then the normal of the last point is determined by its left tangent.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose normals for the control points on the original spline. This latter option is useful when you want to draw a UI for the control point normals.</p>
<p>The normals will be appended to the buffer vector. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="aae2cb0f89bfa367d2829f3b4f277a8c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::CubicSplineApproximator::getNormals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores normal data for the approximation in the buffer.</p>
<p>When complete, the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> will contain data for n lines, where the polygon contains n points. Hence this <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> may be drawn as a wireframe. Each line is a normal vector anchored at its associated control point. The length of the line is determined by the length of the associated tangent vector (right tangent, except for the last control point).</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose normals for the control points on the original spline. This latter option is useful when you want to draw a UI for the control point normals.</p>
<p>The normal data will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a2d13c4bb18996b9d40c96245cae64288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; cugl::CubicSplineApproximator::getParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of parameters for a polygon approximation</p>
<p>The parameters correspond to the generating values in the spline polynomial. That is, if you evaluate the polynomial on the parameters, {via <a class="el" href="">Bezerier.getPoint()</a>, you will get the points in the approximating polygon.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose parameters for the control points on the original spline.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of parameters for a polygon approximation </dd></dl>

</div>
</div>
<a class="anchor" id="a35f59f52e9ebe065436159c42ad70f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::CubicSplineApproximator::getParameters </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a list of parameters for the approximation in the buffer.</p>
<p>The parameters correspond to the generating values in the spline polynomial. That is, if you evaluate the polynomial on the parameters, {via <a class="el" href="">Bezerier.getPoint()</a>, you will get the points in the approximating polygon.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose parameters for the control points on the original spline.</p>
<p>The parameters will be appended to the buffer vector. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the parameter data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a4dc3bd4747512894b08edc698ba9b6a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::CubicSplineApproximator::getPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new polygon approximating this spline.</p>
<p>The <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> indices will define a path traversing the vertices of the polygon. Hence this <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> may be drawn as a wireframe. The indices will define a closed path if the spline is itself closed, and an open path otherwise.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will create a polygon from the control points on the original spline.</p>
<dl class="section return"><dt>Returns</dt><dd>a new polygon approximating this spline. </dd></dl>

</div>
</div>
<a class="anchor" id="ac63f0d7a93bd1edba295766dffb71c73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::CubicSplineApproximator::getPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores vertex information approximating this spline in the buffer.</p>
<p>The <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> indices will define a path traversing the vertices of the polygon. Hence this <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> may be drawn as a wireframe. The indices will define a closed path if the spline is itself closed, and an open path otherwise.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will create a polygon from the control points on the original spline.</p>
<p>The vertices (and indices) will be appended to the the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> if it is not empty. You should clear the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the vertex data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7803fa5adb49f83cb3fd5576831cb0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> cugl::CubicSplineApproximator::getRefinement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an expanded version of this spline</p>
<p>When we use de Castlejau's to approximate the spline, it produces a list of control points that are geometrically equal to this spline (e.g. ignoring parameterization). Instead of flattening this information to a polygon, this method presents this data as a new spline.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will copy the original spline.</p>
<dl class="section return"><dt>Returns</dt><dd>an expanded version of this spline </dd></dl>

</div>
</div>
<a class="anchor" id="a7de4d808155c30ef9a7f5f04f8a20ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>* cugl::CubicSplineApproximator::getRefinement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores an expanded version of this spline in the given buffer.</p>
<p>When we use de Castlejau's to approximate the spline, it produces a list of control points that are geometrically equal to this spline (e.g. ignoring parameterization). Instead of flattening this information to a polygon, this method presents this data as a new spline.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will copy the original spline.</p>
<p>The control points will be appended to the the spline if it is not empty. You should clear the spline first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the vertex data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a13652443d37778fcd2cbb4a88ccfd300"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt; cugl::CubicSplineApproximator::getTangents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of tangents for a polygon approximation</p>
<p>These tangent vectors are presented in control point order. First, we have the right tangent of the first point, then the left tangent of the second point, then the right, and so on. Hence if the polygon contains n points, this method will return 2(n-1) tangents.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose tangents for the control points on the original spline. This latter option is useful when you want to draw a UI for the control point tangents.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of tangents for a polygon approximation </dd></dl>

</div>
</div>
<a class="anchor" id="ac28724c163ce6260fcfd94e10ae37db1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::CubicSplineApproximator::getTangents </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a list of tangents for the approximation in the buffer.</p>
<p>These tangent vectors are presented in control point order. First, we have the right tangent of the first point, then the left tangent of the second point, then the right, and so on. Hence if the polygon contains n points, this method will return 2(n-1) tangents.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose tangents for the control points on the original spline. This latter option is useful when you want to draw a UI for the control point tangents.</p>
<p>The tangents will be appended to the buffer vector. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a48e077eb76c8b791e21d8c2eda4fb788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::CubicSplineApproximator::getTangents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores tangent data for the approximation in the buffer.</p>
<p>When complete, the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> will contain data for 2(n-1) lines, where the polygon contains n points. Hence this <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> may be drawn as a wireframe. Each line is a tangent vector anchored at its associated control point. The length of the line is determined by the length of the tangent vector.</p>
<p>The resolution of the polygon is determined by the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html#af16e29713044105c66a343e9e872df70">calculate()</a> method. See the description of that method for the various options. If calculate has not been called, this method will choose tangents for the control points on the original spline. This latter option is useful when you want to draw a UI for the control point tangents.</p>
<p>The tangent data will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a98ad2d5379ca952dc0ba65427165574b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSplineApproximator::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all internal data, but still maintains a reference to the spline.</p>
<p>Use this method when you want to reperform the approximation at a different resolution. </p>

</div>
</div>
<a class="anchor" id="a4d8b09060ca54412ab15dd058be2a788"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSplineApproximator::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> *&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the given spline as the data for this spline approximator.</p>
<p>This method resets all interal data. You will need to reperform the calculation before accessing data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spline</td><td>The spline to approximate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/polygon/<a class="el" href="_c_u_cubic_spline_approximator_8h_source.html">CUCubicSplineApproximator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::Scene Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_scene.html">Scene</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcugl_1_1_scene-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Scene Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_scene_8h_source.html">CUScene.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af90ebfdbecb1dbe5137cb4db2d17b9d0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#af90ebfdbecb1dbe5137cb4db2d17b9d0">Scene</a> ()</td></tr>
<tr class="separator:af90ebfdbecb1dbe5137cb4db2d17b9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac9ad736e2f657ab1acc31c9ef09faf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#afac9ad736e2f657ab1acc31c9ef09faf">~Scene</a> ()</td></tr>
<tr class="separator:afac9ad736e2f657ab1acc31c9ef09faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579420036bde8d0e9207e4e4f43c1f6e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a579420036bde8d0e9207e4e4f43c1f6e">dispose</a> ()</td></tr>
<tr class="separator:a579420036bde8d0e9207e4e4f43c1f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40035e0bca547fb32c053da5348f209"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aa40035e0bca547fb32c053da5348f209">init</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:aa40035e0bca547fb32c053da5348f209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0d2d53285c55e384d41d5e67a39e01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aef0d2d53285c55e384d41d5e67a39e01">init</a> (float width, float height)</td></tr>
<tr class="separator:aef0d2d53285c55e384d41d5e67a39e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d91ff2917ec2d82f34cfb9d74f338b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a23d91ff2917ec2d82f34cfb9d74f338b">init</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a23d91ff2917ec2d82f34cfb9d74f338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbb52f61335963f248256f25dedb43e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a7bbb52f61335963f248256f25dedb43e">init</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:a7bbb52f61335963f248256f25dedb43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fac15868f2196a5a6e171200476a0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a64fac15868f2196a5a6e171200476a0d">init</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:a64fac15868f2196a5a6e171200476a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8bfcd895e651962c5310736092b1ba"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aba8bfcd895e651962c5310736092b1ba">getName</a> () const </td></tr>
<tr class="separator:aba8bfcd895e651962c5310736092b1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abbf49d443b9ee09e04b9780f825bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a0abbf49d443b9ee09e04b9780f825bd4">setName</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a0abbf49d443b9ee09e04b9780f825bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cacef5921f262956bb9ba3e4388dfe"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_camera.html">Camera</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a85cacef5921f262956bb9ba3e4388dfe">getCamera</a> ()</td></tr>
<tr class="separator:a85cacef5921f262956bb9ba3e4388dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff2f921e7aff4a61e450c711faa72f6"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_camera.html">Camera</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a6ff2f921e7aff4a61e450c711faa72f6">getCamera</a> () const </td></tr>
<tr class="separator:a6ff2f921e7aff4a61e450c711faa72f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf82a2047c4553f10abcbecf50add556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aaf82a2047c4553f10abcbecf50add556">getColor</a> ()</td></tr>
<tr class="separator:aaf82a2047c4553f10abcbecf50add556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04f77344b17f8eaa00cf16fe19d4d10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ae04f77344b17f8eaa00cf16fe19d4d10">setColor</a> (<a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:ae04f77344b17f8eaa00cf16fe19d4d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4272bdf303e1b25e3859ff385a9b64df"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a4272bdf303e1b25e3859ff385a9b64df">toString</a> (bool verbose=false) const </td></tr>
<tr class="separator:a4272bdf303e1b25e3859ff385a9b64df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5652619a194dd5356e92a11bbd6d6c79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a5652619a194dd5356e92a11bbd6d6c79">operator std::string</a> () const </td></tr>
<tr class="separator:a5652619a194dd5356e92a11bbd6d6c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2390c0bd8eccd4997840295da1dca089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a2390c0bd8eccd4997840295da1dca089">setSize</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:a2390c0bd8eccd4997840295da1dca089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a920f4fe2e43dc850f8deed79dce946f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a920f4fe2e43dc850f8deed79dce946f1">setSize</a> (float width, float height)</td></tr>
<tr class="separator:a920f4fe2e43dc850f8deed79dce946f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411f1bf323d5abc41f1961724b98e591"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a411f1bf323d5abc41f1961724b98e591">setWidth</a> (float width)</td></tr>
<tr class="separator:a411f1bf323d5abc41f1961724b98e591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c6b20c0489ab4f26e5da820a98cf2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#af4c6b20c0489ab4f26e5da820a98cf2f">setHeight</a> (float height)</td></tr>
<tr class="separator:af4c6b20c0489ab4f26e5da820a98cf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d98034069d4e2aa6051729d289906c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a3d98034069d4e2aa6051729d289906c5">setBounds</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a3d98034069d4e2aa6051729d289906c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29baffe8a3d27536d4d12002f233d564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a29baffe8a3d27536d4d12002f233d564">setBounds</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:a29baffe8a3d27536d4d12002f233d564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a183cfadcfa71424aaa32b9479e7d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a5a183cfadcfa71424aaa32b9479e7d64">setBounds</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:a5a183cfadcfa71424aaa32b9479e7d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2d7611cbd949c4ef0fea001609b109"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#afb2d7611cbd949c4ef0fea001609b109">setOffset</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin)</td></tr>
<tr class="separator:afb2d7611cbd949c4ef0fea001609b109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb53f77d04bd0d60d2c62aa9cf412af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aaeb53f77d04bd0d60d2c62aa9cf412af">screenToWorldCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;screenCoords) const </td></tr>
<tr class="separator:aaeb53f77d04bd0d60d2c62aa9cf412af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9396fbd90793b1a92f01aaefd72c012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aa9396fbd90793b1a92f01aaefd72c012">worldToScreenCoords</a> (const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;worldCoords) const </td></tr>
<tr class="separator:aa9396fbd90793b1a92f01aaefd72c012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f47c2df2ddbd1599cbef81bf3ce396c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a3f47c2df2ddbd1599cbef81bf3ce396c">getChildCount</a> () const </td></tr>
<tr class="separator:a3f47c2df2ddbd1599cbef81bf3ce396c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655d66d50438b4185ae745e010a59057"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a655d66d50438b4185ae745e010a59057">getChild</a> (unsigned int pos)</td></tr>
<tr class="separator:a655d66d50438b4185ae745e010a59057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa095468dde6df594afb4de4a1d34841a"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aa095468dde6df594afb4de4a1d34841a">getChild</a> (unsigned int pos) const </td></tr>
<tr class="separator:aa095468dde6df594afb4de4a1d34841a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5369b027edaab712c5401add83a60f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb5369b027edaab712c5401add83a60f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#afb5369b027edaab712c5401add83a60f">getChild</a> (unsigned int pos) const </td></tr>
<tr class="separator:afb5369b027edaab712c5401add83a60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cbc74fa6ba199b9f4123f699cb5af1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a68cbc74fa6ba199b9f4123f699cb5af1">getChildByTag</a> (unsigned int tag) const </td></tr>
<tr class="separator:a68cbc74fa6ba199b9f4123f699cb5af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a41ae63dcf23a72d71803c9ebcefdb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28a41ae63dcf23a72d71803c9ebcefdb"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a28a41ae63dcf23a72d71803c9ebcefdb">getChildByTag</a> (unsigned int tag) const </td></tr>
<tr class="separator:a28a41ae63dcf23a72d71803c9ebcefdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4f7d8d46eb3aa1ccc1bc0d2aef28c1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#abd4f7d8d46eb3aa1ccc1bc0d2aef28c1">getChildByName</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:abd4f7d8d46eb3aa1ccc1bc0d2aef28c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a21c5f99352c406ea20d157d452012"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45a21c5f99352c406ea20d157d452012"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a45a21c5f99352c406ea20d157d452012">getChildByName</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a45a21c5f99352c406ea20d157d452012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3ef621d6ba86d343d088f6fc878457"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ace3ef621d6ba86d343d088f6fc878457">getChildren</a> ()</td></tr>
<tr class="separator:ace3ef621d6ba86d343d088f6fc878457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635e9f62a4ec6b826521e5f4e815863b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a635e9f62a4ec6b826521e5f4e815863b">getChildren</a> () const </td></tr>
<tr class="separator:a635e9f62a4ec6b826521e5f4e815863b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2ab5b180f0ebbfa3ec2d7b00770376"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aab2ab5b180f0ebbfa3ec2d7b00770376">addChild</a> (std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; child)</td></tr>
<tr class="separator:aab2ab5b180f0ebbfa3ec2d7b00770376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d473542f5a8b1ace5cab8233daedda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a36d473542f5a8b1ace5cab8233daedda">addChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, int zval)</td></tr>
<tr class="separator:a36d473542f5a8b1ace5cab8233daedda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7b06b29268d2e9c93e2ec5eaf9cbbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#afc7b06b29268d2e9c93e2ec5eaf9cbbf">addChildWithTag</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, unsigned int tag)</td></tr>
<tr class="separator:afc7b06b29268d2e9c93e2ec5eaf9cbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa553675a170fbf18531bb1feb2edbd22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aa553675a170fbf18531bb1feb2edbd22">addChildWithTag</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, unsigned int tag, int zval)</td></tr>
<tr class="separator:aa553675a170fbf18531bb1feb2edbd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e54fed85069c72e805e4e75a105fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a11e54fed85069c72e805e4e75a105fc2">addChildWithName</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, const std::string &amp;name)</td></tr>
<tr class="separator:a11e54fed85069c72e805e4e75a105fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168365cedfcd84526d0e5bcf91960885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a168365cedfcd84526d0e5bcf91960885">addChildWithName</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, const std::string &amp;name, int zval)</td></tr>
<tr class="separator:a168365cedfcd84526d0e5bcf91960885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d28932f2d424974660112761516824b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a7d28932f2d424974660112761516824b">swapChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child1, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child2, bool inherit=false)</td></tr>
<tr class="separator:a7d28932f2d424974660112761516824b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0496046f6c2ba42603eeddd8d6da495e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a0496046f6c2ba42603eeddd8d6da495e">removeChild</a> (unsigned int pos)</td></tr>
<tr class="separator:a0496046f6c2ba42603eeddd8d6da495e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a130fed7e7f8c7921833bb321a9c974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a5a130fed7e7f8c7921833bb321a9c974">removeChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child)</td></tr>
<tr class="separator:a5a130fed7e7f8c7921833bb321a9c974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae048912dff2494e7064df05cb8561bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ae048912dff2494e7064df05cb8561bf1">removeChildByTag</a> (unsigned int tag)</td></tr>
<tr class="separator:ae048912dff2494e7064df05cb8561bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984140b258fbe02b62fb1aa1b46bc014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a984140b258fbe02b62fb1aa1b46bc014">removeChildByName</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a984140b258fbe02b62fb1aa1b46bc014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab51728fcac293c4e5a861f5de8d0db"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aeab51728fcac293c4e5a861f5de8d0db">removeAllChildren</a> ()</td></tr>
<tr class="separator:aeab51728fcac293c4e5a861f5de8d0db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c43fc0bea47ecb19528f6652442869d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a7c43fc0bea47ecb19528f6652442869d">isZAutoSort</a> ()</td></tr>
<tr class="separator:a7c43fc0bea47ecb19528f6652442869d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad669e9ab7199357f25a4d58e9bea4518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ad669e9ab7199357f25a4d58e9bea4518">setZAutoSort</a> (bool value)</td></tr>
<tr class="separator:ad669e9ab7199357f25a4d58e9bea4518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838d77cfd961773a419a4baa434f81d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a838d77cfd961773a419a4baa434f81d2">isZDirty</a> () const </td></tr>
<tr class="separator:a838d77cfd961773a419a4baa434f81d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a149f575b95f6fbe4d1ff6a6715d0f361"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a149f575b95f6fbe4d1ff6a6715d0f361">sortZOrder</a> ()</td></tr>
<tr class="separator:a149f575b95f6fbe4d1ff6a6715d0f361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bbb9836c9820b695d450f40706f3b16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a3bbb9836c9820b695d450f40706f3b16">isActive</a> () const </td></tr>
<tr class="separator:a3bbb9836c9820b695d450f40706f3b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86923a266e6635d6cc8a6eb39c4035a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a86923a266e6635d6cc8a6eb39c4035a5">setActive</a> (bool value)</td></tr>
<tr class="separator:a86923a266e6635d6cc8a6eb39c4035a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa54208734def0109b34dbbc5177949"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aeaa54208734def0109b34dbbc5177949">update</a> (float timestep)</td></tr>
<tr class="separator:aeaa54208734def0109b34dbbc5177949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9798f49a815dc5dbd6e0b9a093c411f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ae9798f49a815dc5dbd6e0b9a093c411f">reset</a> ()</td></tr>
<tr class="separator:ae9798f49a815dc5dbd6e0b9a093c411f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b5f903812c575d46dc56de1fe4a143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a36b5f903812c575d46dc56de1fe4a143">render</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;batch)</td></tr>
<tr class="separator:a36b5f903812c575d46dc56de1fe4a143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5063efcbe3501333ee5be7d79efd893"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene.html">Scene</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ad5063efcbe3501333ee5be7d79efd893">alloc</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:ad5063efcbe3501333ee5be7d79efd893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee087e00e4dd0e45982c48fef427867"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene.html">Scene</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a3ee087e00e4dd0e45982c48fef427867">alloc</a> (float width, float height)</td></tr>
<tr class="separator:a3ee087e00e4dd0e45982c48fef427867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881134c10c7fdedf90b552f53ca43a4e"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene.html">Scene</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a881134c10c7fdedf90b552f53ca43a4e">alloc</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a881134c10c7fdedf90b552f53ca43a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe6671cb765efb8d09985e1cadd0692"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene.html">Scene</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aebe6671cb765efb8d09985e1cadd0692">alloc</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:aebe6671cb765efb8d09985e1cadd0692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f6fa17e582a2a1163e48f913e6078b"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene.html">Scene</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ab5f6fa17e582a2a1163e48f913e6078b">alloc</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:ab5f6fa17e582a2a1163e48f913e6078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4183ce971993bfa48da823936ad99ce6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a4183ce971993bfa48da823936ad99ce6">_name</a></td></tr>
<tr class="separator:a4183ce971993bfa48da823936ad99ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95c4129e05fde90d7d44947d439d895"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_orthographic_camera.html">OrthographicCamera</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#ab95c4129e05fde90d7d44947d439d895">_camera</a></td></tr>
<tr class="separator:ab95c4129e05fde90d7d44947d439d895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2beb67177e15a9a425707ac4029ba6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a9e2beb67177e15a9a425707ac4029ba6">_children</a></td></tr>
<tr class="separator:a9e2beb67177e15a9a425707ac4029ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe9ebd89dce4baba218faed37d54fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a7fe9ebd89dce4baba218faed37d54fd5">_color</a></td></tr>
<tr class="separator:a7fe9ebd89dce4baba218faed37d54fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a624e2f126428b668f40c1c63d7832aa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a624e2f126428b668f40c1c63d7832aa6">_zDirty</a></td></tr>
<tr class="separator:a624e2f126428b668f40c1c63d7832aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0d67cef8396ee197b6728d8ce56c90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a5e0d67cef8396ee197b6728d8ce56c90">_zSort</a></td></tr>
<tr class="separator:a5e0d67cef8396ee197b6728d8ce56c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a1d3d9fbcf9ff32f819988db438bdb"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a75a1d3d9fbcf9ff32f819988db438bdb">_blendEquation</a></td></tr>
<tr class="separator:a75a1d3d9fbcf9ff32f819988db438bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f65254f3e16ff06a0413341b76d91f2"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a1f65254f3e16ff06a0413341b76d91f2">_srcFactor</a></td></tr>
<tr class="separator:a1f65254f3e16ff06a0413341b76d91f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9826da7e240b291ab1567e33461f31"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#aff9826da7e240b291ab1567e33461f31">_dstFactor</a></td></tr>
<tr class="separator:aff9826da7e240b291ab1567e33461f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620bd467e3e7f54dc0e0f49111018369"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene.html#a620bd467e3e7f54dc0e0f49111018369">_active</a></td></tr>
<tr class="separator:a620bd467e3e7f54dc0e0f49111018369"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6db9d28bd448a131448276ee03de1e6d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6db9d28bd448a131448276ee03de1e6d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Node</b></td></tr>
<tr class="separator:a6db9d28bd448a131448276ee03de1e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides the root node of a scene graph.</p>
<p>The <a class="el" href="classcugl_1_1_scene.html">Scene</a> class is very similar to <a class="el" href="classcugl_1_1_node.html">Node</a> and shares many methods in common. The major differences are that it has no parent and it has no position (so it cannot be transformed). Instead, the <a class="el" href="classcugl_1_1_scene.html">Scene</a> is defined by an attached <a class="el" href="classcugl_1_1_orthographic_camera.html">OrthographicCamera</a>.</p>
<p>Rendering happens by traversing the the scene graph using an "Pre-Order" tree traversal algorithm ( <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</a> ). That means that parents are always draw before (and behind children). The children of each sub tree are ordered by z-value (or by the order added). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af90ebfdbecb1dbe5137cb4db2d17b9d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Scene::Scene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new degenerate <a class="el" href="classcugl_1_1_scene.html">Scene</a> on the stack.</p>
<p>The scene has no camera and must be initialized.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate an object on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a class="anchor" id="afac9ad736e2f657ab1acc31c9ef09faf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Scene::~Scene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this scene, disposing all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aab2ab5b180f0ebbfa3ec2d7b00770376"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::addChild </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36d473542f5a8b1ace5cab8233daedda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene::addChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given z-order.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a11e54fed85069c72e805e4e75a105fc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::addChildWithName </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given name.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a168365cedfcd84526d0e5bcf91960885"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::addChildWithName </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given name and z-order</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afc7b06b29268d2e9c93e2ec5eaf9cbbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::addChildWithTag </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given tag.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa553675a170fbf18531bb1feb2edbd22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::addChildWithTag </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given tag and z-order</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5063efcbe3501333ee5be7d79efd893"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene.html">Scene</a>&gt; cugl::Scene::alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ee087e00e4dd0e45982c48fef427867"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene.html">Scene</a>&gt; cugl::Scene::alloc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport. </dd></dl>

</div>
</div>
<a class="anchor" id="a881134c10c7fdedf90b552f53ca43a4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene.html">Scene</a>&gt; cugl::Scene::alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The viewport bounding box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport. </dd></dl>

</div>
</div>
<a class="anchor" id="aebe6671cb765efb8d09985e1cadd0692"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene.html">Scene</a>&gt; cugl::Scene::alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The viewport offset </td></tr>
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5f6fa17e582a2a1163e48f913e6078b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene.html">Scene</a>&gt; cugl::Scene::alloc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The viewport x offset </td></tr>
    <tr><td class="paramname">y</td><td>The viewport y offset </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_scene.html">Scene</a> for the given viewport. </dd></dl>

</div>
</div>
<a class="anchor" id="a579420036bde8d0e9207e4e4f43c1f6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disposes all of the resources used by this scene.</p>
<p>A disposed <a class="el" href="classcugl_1_1_scene.html">Scene</a> can be safely reinitialized. Any children owned by this scene will be released. They will be deleted if no other object owns them. </p>

</div>
</div>
<a class="anchor" id="a85cacef5921f262956bb9ba3e4388dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_camera.html">Camera</a>&gt; cugl::Scene::getCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the camera for this scene.</p>
<dl class="section return"><dt>Returns</dt><dd>the camera for this scene. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ff2f921e7aff4a61e450c711faa72f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_camera.html">Camera</a>&gt; cugl::Scene::getCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the camera for this scene.</p>
<dl class="section return"><dt>Returns</dt><dd>the camera for this scene. </dd></dl>

</div>
</div>
<a class="anchor" id="a655d66d50438b4185ae745e010a59057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Scene::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the given position.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="aa095468dde6df594afb4de4a1d34841a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt;&amp; cugl::Scene::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the given position.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="afb5369b027edaab712c5401add83a60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Scene::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the child at the given position, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type <a class="el" href="classcugl_1_1_node.html">Node</a>, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="abd4f7d8d46eb3aa1ccc1bc0d2aef28c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Scene::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (first) child with the given name.</p>
<p>If there is more than one child of the given name, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given name. </dd></dl>

</div>
</div>
<a class="anchor" id="a45a21c5f99352c406ea20d157d452012"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Scene::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) child with the given name, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type <a class="el" href="classcugl_1_1_node.html">Node</a>, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>If there is more than one child of the given name, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given name, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a68cbc74fa6ba199b9f4123f699cb5af1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Scene::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (first) child with the given tag.</p>
<p>If there is more than one child of the given tag, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given tag. </dd></dl>

</div>
</div>
<a class="anchor" id="a28a41ae63dcf23a72d71803c9ebcefdb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Scene::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) child with the given tag, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type <a class="el" href="classcugl_1_1_node.html">Node</a>, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>If there is more than one child of the given tag, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given tag, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f47c2df2ddbd1599cbef81bf3ce396c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Scene::getChildCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of immediate children of this scene.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of immediate children of this scene. </dd></dl>

</div>
</div>
<a class="anchor" id="ace3ef621d6ba86d343d088f6fc878457"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; &gt; cugl::Scene::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of the scene's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>the list of the scene's immediate children. </dd></dl>

</div>
</div>
<a class="anchor" id="a635e9f62a4ec6b826521e5f4e815863b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; &gt;&amp; cugl::Scene::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of the scene's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>the list of the scene's immediate children. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf82a2047c4553f10abcbecf50add556"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::Scene::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the tint color for this scene.</p>
<p>During the render phase, this color will be applied to any child for which hasRelativeColor() is true.</p>
<dl class="section return"><dt>Returns</dt><dd>the tint color for this scene. </dd></dl>

</div>
</div>
<a class="anchor" id="aba8bfcd895e651962c5310736092b1ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::Scene::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is used to identify the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>a string that is used to identify the scene. </dd></dl>

</div>
</div>
<a class="anchor" id="aa40035e0bca547fb32c053da5348f209"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Scene::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene.html">Scene</a> with the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="aef0d2d53285c55e384d41d5e67a39e01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::init </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene.html">Scene</a> with the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a23d91ff2917ec2d82f34cfb9d74f338b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Scene::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene.html">Scene</a> with the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset of the viewport in a larger canvas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The viewport bounding box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bbb52f61335963f248256f25dedb43e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Scene::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene.html">Scene</a> with the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset of the viewport in a larger canvas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The viewport offset </td></tr>
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a64fac15868f2196a5a6e171200476a0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::init </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene.html">Scene</a> with the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset of the viewport in a larger canvas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The viewport x offset </td></tr>
    <tr><td class="paramname">y</td><td>The viewport y offset </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a3bbb9836c9820b695d450f40706f3b16"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::isActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the scene is currently active</p>
<dl class="section return"><dt>Returns</dt><dd>true if the scene is currently active </dd></dl>

</div>
</div>
<a class="anchor" id="a7c43fc0bea47ecb19528f6652442869d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::isZAutoSort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this scene automatically sorts children by z-value.</p>
<p>If this value is true, the scene graph will be resorted every time that <a class="el" href="classcugl_1_1_scene.html#a36b5f903812c575d46dc56de1fe4a143">render()</a> is called. Because of our invariant with dirty nodes, sorting will be avoided if it is not necessary.</p>
<p>Sorting only happens automatically is this value it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene.html#a149f575b95f6fbe4d1ff6a6715d0f361">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this scene automatically sorts children by z-value. </dd></dl>

</div>
</div>
<a class="anchor" id="a838d77cfd961773a419a4baa434f81d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::isZDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the children of this <a class="el" href="classcugl_1_1_scene.html">Scene</a> needs resorting.</p>
<p>The children of a scene may need to be resorted whenever a child is added, or whenever the z-value of a child is changed.</p>
<p>This value satisfies the following invariant: if a <a class="el" href="classcugl_1_1_node.html">Node</a> is dirty and needs resorting, then so are all of its ancestors (including this associated <a class="el" href="classcugl_1_1_scene.html">Scene</a>). Our methods guarantee this invariant, so that the method <a class="el" href="classcugl_1_1_scene.html#a838d77cfd961773a419a4baa434f81d2">isZDirty()</a> always returns the correct value.</p>
<p>Sorting only happens automatically is <a class="el" href="classcugl_1_1_scene.html#a7c43fc0bea47ecb19528f6652442869d">isZAutoSort()</a> it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene.html#a149f575b95f6fbe4d1ff6a6715d0f361">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order.</p>
<dl class="section return"><dt>Returns</dt><dd>whether the children of this node needs resorting. </dd></dl>

</div>
</div>
<a class="anchor" id="a5652619a194dd5356e92a11bbd6d6c79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Scene::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from a <a class="el" href="classcugl_1_1_scene.html">Scene</a> to a string. </p>

</div>
</div>
<a class="anchor" id="aeab51728fcac293c4e5a861f5de8d0db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene::removeAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all children from this <a class="el" href="classcugl_1_1_node.html">Node</a>. </p>

</div>
</div>
<a class="anchor" id="a0496046f6c2ba42603eeddd8d6da495e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the child at the given position from this <a class="el" href="classcugl_1_1_scene.html">Scene</a>.</p>
<p>Removing a child alters the position of every child after it. Hence it is unsafe to cache child positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the child node which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a130fed7e7f8c7921833bb321a9c974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::removeChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from this <a class="el" href="classcugl_1_1_scene.html">Scene</a>.</p>
<p>Removing a child alters the position of every child after it. Hence it is unsafe to cache child positions.</p>
<p>If the child is not in this node, nothing happens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a984140b258fbe02b62fb1aa1b46bc014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::removeChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from the <a class="el" href="classcugl_1_1_scene.html">Scene</a> by name.</p>
<p>If there is more than one child of the given name, it removes the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae048912dff2494e7064df05cb8561bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::removeChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from the <a class="el" href="classcugl_1_1_scene.html">Scene</a> by tag value.</p>
<p>If there is more than one child of the given tag, it removes the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a36b5f903812c575d46dc56de1fe4a143"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::render </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws all of the children in this scene with the given <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>.</p>
<p>This method assumes that the sprite batch is not actively drawing. It will call both begin() and end().</p>
<p>Rendering happens by traversing the the scene graph using an "Pre-Order" tree traversal algorithm ( <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</a> ). That means that parents are always draw before (and behind children). The children of each sub tree are ordered by z-value (or by the order added).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> to draw with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9798f49a815dc5dbd6e0b9a093c411f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the status of the scene to its original configuration. </p>

</div>
</div>
<a class="anchor" id="aaeb53f77d04bd0d60d2c62aa9cf412af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a> cugl::Scene::screenToWorldCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>screenCoords</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the world space equivalent of a point in screen coordinates.</p>
<p>Ideally, window space and screen space would be the same space. They are both defined by the viewport and have the same offset and dimension. However, screen coordinates have the origin in the top left while window coordinates have the origin in the bottom left.</p>
<p>In computing the world space coordinates, this method assumes that the z-value of the original vector is the same as near, which is the closest it can be the screen.</p>
<p>This method is important for converting event coordinates (such as a mouse click) to world coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenCoords</td><td>The point in screen coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the world space equivalent of a point in screen coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a86923a266e6635d6cc8a6eb39c4035a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene::setActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether the scene is currently active</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>whether the scene is currently active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d98034069d4e2aa6051729d289906c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene.html">Scene</a> to have the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The viewport bounding box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29baffe8a3d27536d4d12002f233d564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene.html">Scene</a> to have the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The viewport offset </td></tr>
    <tr><td class="paramname">size</td><td>The viewport size </td></tr>
    <tr><td class="paramname">yDown</td><td>Whether to put the origin in the top left corner </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a183cfadcfa71424aaa32b9479e7d64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene.html">Scene</a> to have the given viewport.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The viewport x offset </td></tr>
    <tr><td class="paramname">y</td><td>The viewport y offset </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae04f77344b17f8eaa00cf16fe19d4d10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the tint color for this scene.</p>
<p>During the render phase, this color will be applied to any child for which hasRelativeColor() is true.</p>
<p>color The tint color for this scene. </p>

</div>
</div>
<a class="anchor" id="af4c6b20c0489ab4f26e5da820a98cf2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setHeight </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene.html">Scene</a> to have the given viewport height.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>The viewport height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0abbf49d443b9ee09e04b9780f825bd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the string that is used to identify the scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string that is used to identify the scene. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afb2d7611cbd949c4ef0fea001609b109"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets the viewport origin by the given amount.</p>
<p>Offseting the viewport origin has little affect on the <a class="el" href="classcugl_1_1_scene.html">Scene</a> in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a8ba952d60ee4b8558987322e411e3433">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a489ea3d87e17a35568e59ab0188bff69">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The offset of the viewport origin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2390c0bd8eccd4997840295da1dca089"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene.html">Scene</a> to have the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The viewport size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a920f4fe2e43dc850f8deed79dce946f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene.html">Scene</a> to have the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a411f1bf323d5abc41f1961724b98e591"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene.html">Scene</a> to have the given viewport width.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad669e9ab7199357f25a4d58e9bea4518"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::setZAutoSort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether this scene automatically sorts children by z-value.</p>
<p>If this value is true, the scene graph will be resorted every time that <a class="el" href="classcugl_1_1_scene.html#a36b5f903812c575d46dc56de1fe4a143">render()</a> is called. Because of our invariant with dirty nodes, sorting will be avoided if it is not necessary.</p>
<p>Sorting only happens automatically is this value it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene.html#a149f575b95f6fbe4d1ff6a6715d0f361">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order.</p>
<p>value Whether this scene automatically sorts children by z-value. </p>

</div>
</div>
<a class="anchor" id="a149f575b95f6fbe4d1ff6a6715d0f361"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::sortZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resorts the children of this <a class="el" href="classcugl_1_1_scene.html">Scene</a> according to z-value.</p>
<p>If two children have the same z-value, their relative order is preserved to what it was before the sort. This method should be called before rendering.</p>
<p>Resorting is done recursively down a tree for each child that is dirty and needs resorting. We guarantee that Nodes will not be resorted unless necessary, because of the following invariant: if a <a class="el" href="classcugl_1_1_node.html">Node</a> is dirty and needs resorting, then so are all of its ancestors (including this associated <a class="el" href="classcugl_1_1_scene.html">Scene</a>).</p>
<p>Sorting only happens automatically is <a class="el" href="classcugl_1_1_scene.html#a7c43fc0bea47ecb19528f6652442869d">isZAutoSort()</a> it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene.html#a149f575b95f6fbe4d1ff6a6715d0f361">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order. </p>

</div>
</div>
<a class="anchor" id="a7d28932f2d424974660112761516824b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene::swapChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the current child child1 with the new child child2.</p>
<p>If inherit is true, the children of child1 are assigned to child2 after the swap; this value is false by default. The purpose of this value is to allow transitions in the scene graph.</p>
<p>This method is undefined if child1 is not a child of this scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child1</td><td>The current child of this node </td></tr>
    <tr><td class="paramname">child2</td><td>The child to swap it with. </td></tr>
    <tr><td class="paramname">inherit</td><td>Whether the new child should inherit the children of child1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4272bdf303e1b25e3859ff385a9b64df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cugl::Scene::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string representation of this scene for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this scene for debuggging purposes. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaa54208734def0109b34dbbc5177949"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timestep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The method called to update the scene.</p>
<p>This method should be overridden with the specific scene logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestep</td><td>The amount of time (in seconds) since the last frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9396fbd90793b1a92f01aaefd72c012"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Scene::worldToScreenCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>worldCoords</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the screen space equivalent of a point in world coordinates.</p>
<p>Ideally, window space and screen space would be the same space. They are both defined by the viewport and have the same offset and dimension. However, screen coordinates have the origin in the top left while window coordinates have the origin in the bottom left.</p>
<p>This method is important for converting world coordinates to event coordinates (such as a mouse click).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldCoords</td><td>The point in wprld coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the screen space equivalent of a point in world coordinates. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a620bd467e3e7f54dc0e0f49111018369"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::_active</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or note this scene is still active </p>

</div>
</div>
<a class="anchor" id="a75a1d3d9fbcf9ff32f819988db438bdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Scene::_blendEquation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The blending equation for this scene </p>

</div>
</div>
<a class="anchor" id="ab95c4129e05fde90d7d44947d439d895"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_orthographic_camera.html">OrthographicCamera</a>&gt; cugl::Scene::_camera</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The camera for this scene </p>

</div>
</div>
<a class="anchor" id="a9e2beb67177e15a9a425707ac4029ba6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; &gt; cugl::Scene::_children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array of internal nodes </p>

</div>
</div>
<a class="anchor" id="a7fe9ebd89dce4baba218faed37d54fd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::Scene::_color</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default tint for this scene </p>

</div>
</div>
<a class="anchor" id="aff9826da7e240b291ab1567e33461f31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Scene::_dstFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The destination factor for the blend function </p>

</div>
</div>
<a class="anchor" id="a4183ce971993bfa48da823936ad99ce6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Scene::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of this scene </p>

</div>
</div>
<a class="anchor" id="a1f65254f3e16ff06a0413341b76d91f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Scene::_srcFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The source factor for the blend function </p>

</div>
</div>
<a class="anchor" id="a624e2f126428b668f40c1c63d7832aa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::_zDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the z-order is currently violated </p>

</div>
</div>
<a class="anchor" id="a5e0d67cef8396ee197b6728d8ce56c90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene::_zSort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether auto-sorting is active </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/2d/<a class="el" href="_c_u_scene_8h_source.html">CUScene.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

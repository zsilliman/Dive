<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::Node Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_node.html">Node</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcugl_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Node Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_node_8h_source.html">CUNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cugl::Node:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcugl_1_1_node.png" usemap="#cugl::Node_map" alt=""/>
  <map id="cugl::Node_map" name="cugl::Node_map">
<area href="classcugl_1_1_button.html" alt="cugl::Button" shape="rect" coords="0,56,127,80"/>
<area href="classcugl_1_1_label.html" alt="cugl::Label" shape="rect" coords="137,56,264,80"/>
<area href="classcugl_1_1_nine_patch.html" alt="cugl::NinePatch" shape="rect" coords="274,56,401,80"/>
<area href="classcugl_1_1_progress_bar.html" alt="cugl::ProgressBar" shape="rect" coords="411,56,538,80"/>
<area href="classcugl_1_1_slider.html" alt="cugl::Slider" shape="rect" coords="548,56,675,80"/>
<area href="classcugl_1_1_textured_node.html" alt="cugl::TexturedNode" shape="rect" coords="685,56,812,80"/>
<area href="classcugl_1_1_text_field.html" alt="cugl::TextField" shape="rect" coords="137,112,264,136"/>
<area href="classcugl_1_1_path_node.html" alt="cugl::PathNode" shape="rect" coords="548,112,675,136"/>
<area href="classcugl_1_1_polygon_node.html" alt="cugl::PolygonNode" shape="rect" coords="685,112,812,136"/>
<area href="classcugl_1_1_wire_node.html" alt="cugl::WireNode" shape="rect" coords="822,112,949,136"/>
<area href="classcugl_1_1_animation_node.html" alt="cugl::AnimationNode" shape="rect" coords="685,168,812,192"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac6225223f6215d48dc6f89e612fa302d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ac6225223f6215d48dc6f89e612fa302d">Node</a> ()</td></tr>
<tr class="separator:ac6225223f6215d48dc6f89e612fa302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add87aa9f75ae13b38a9e45fb60de3dcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#add87aa9f75ae13b38a9e45fb60de3dcc">~Node</a> ()</td></tr>
<tr class="separator:add87aa9f75ae13b38a9e45fb60de3dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e721d709d2dc1ae7c758d8d29de779b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a2e721d709d2dc1ae7c758d8d29de779b">dispose</a> ()</td></tr>
<tr class="separator:a2e721d709d2dc1ae7c758d8d29de779b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63a5ce4955b74da2d3881db0f7abbbb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab63a5ce4955b74da2d3881db0f7abbbb">init</a> ()</td></tr>
<tr class="separator:ab63a5ce4955b74da2d3881db0f7abbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd72bf905eea27e4ace5c1a561fa65e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a0cd72bf905eea27e4ace5c1a561fa65e">initWithPosition</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;pos)</td></tr>
<tr class="separator:a0cd72bf905eea27e4ace5c1a561fa65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8186ed75f3ab581ecc4c4fd8a04f3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aac8186ed75f3ab581ecc4c4fd8a04f3b">initWithPosition</a> (float x, float y)</td></tr>
<tr class="separator:aac8186ed75f3ab581ecc4c4fd8a04f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b757ef34080f46e4af6e589da09571"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a26b757ef34080f46e4af6e589da09571">initWithBounds</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:a26b757ef34080f46e4af6e589da09571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cb7d3fb4ad4b98e3654ca2fd7d5222"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab9cb7d3fb4ad4b98e3654ca2fd7d5222">initWithBounds</a> (float width, float height)</td></tr>
<tr class="separator:ab9cb7d3fb4ad4b98e3654ca2fd7d5222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3dc0c999d714c0e873ca1e3c3ce6994"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ae3dc0c999d714c0e873ca1e3c3ce6994">initWithBounds</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:ae3dc0c999d714c0e873ca1e3c3ce6994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade438721f423d5eb10e721a7d7e2a9cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ade438721f423d5eb10e721a7d7e2a9cd">initWithBounds</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:ade438721f423d5eb10e721a7d7e2a9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0206ce198d0f6600a4d889987db2b4ef"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a0206ce198d0f6600a4d889987db2b4ef">initWithData</a> (const <a class="el" href="classcugl_1_1_scene_loader.html">SceneLoader</a> *loader, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;data)</td></tr>
<tr class="separator:a0206ce198d0f6600a4d889987db2b4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59d2dead9e24bbb24a89f933631a0de"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcugl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ad59d2dead9e24bbb24a89f933631a0de">copy</a> (<a class="el" href="classcugl_1_1_node.html">Node</a> *dst)</td></tr>
<tr class="separator:ad59d2dead9e24bbb24a89f933631a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6d4dc22e16208e8d102d32c90fcc5a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a3c6d4dc22e16208e8d102d32c90fcc5a">getTag</a> () const </td></tr>
<tr class="separator:a3c6d4dc22e16208e8d102d32c90fcc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed79f5d6706392b26987bcc2bf60517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a3ed79f5d6706392b26987bcc2bf60517">setTag</a> (unsigned int tag)</td></tr>
<tr class="separator:a3ed79f5d6706392b26987bcc2bf60517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb1b6d46a20b3a4ddfee81d976e4c26"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a7fb1b6d46a20b3a4ddfee81d976e4c26">getName</a> () const </td></tr>
<tr class="separator:a7fb1b6d46a20b3a4ddfee81d976e4c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0821464428b7f9d7e8319a8dbb85ebe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a0821464428b7f9d7e8319a8dbb85ebe6">setName</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a0821464428b7f9d7e8319a8dbb85ebe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16b8f546757d3687b7f7fb562e3b8ca"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ac16b8f546757d3687b7f7fb562e3b8ca">toString</a> (bool verbose=false) const </td></tr>
<tr class="separator:ac16b8f546757d3687b7f7fb562e3b8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ec3d9674cd640a301a32b5af343a8d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a26ec3d9674cd640a301a32b5af343a8d">operator std::string</a> () const </td></tr>
<tr class="separator:a26ec3d9674cd640a301a32b5af343a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc65f390d5bd3561c9f4b7ac5b9a89"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#abbbc65f390d5bd3561c9f4b7ac5b9a89">getPosition</a> () const </td></tr>
<tr class="separator:abbbc65f390d5bd3561c9f4b7ac5b9a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b39da2a3bf2902143cea48da0866b34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a1b39da2a3bf2902143cea48da0866b34">setPosition</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="separator:a1b39da2a3bf2902143cea48da0866b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01bb76aa2bac44758084daa1bf489b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#af01bb76aa2bac44758084daa1bf489b5">setPosition</a> (float x, float y)</td></tr>
<tr class="separator:af01bb76aa2bac44758084daa1bf489b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7375891306a66788048c7151f60665"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a7c7375891306a66788048c7151f60665">getPositionX</a> (void) const </td></tr>
<tr class="separator:a7c7375891306a66788048c7151f60665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5e5ccda945b8ea8e7d3261e24ce2f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a3c5e5ccda945b8ea8e7d3261e24ce2f6">setPositionX</a> (float x)</td></tr>
<tr class="separator:a3c5e5ccda945b8ea8e7d3261e24ce2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc1f7ee11a9b20ea06a71b2c8f9ec54"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#abbc1f7ee11a9b20ea06a71b2c8f9ec54">getPositionY</a> (void) const </td></tr>
<tr class="separator:abbc1f7ee11a9b20ea06a71b2c8f9ec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407286cf325d4f43164700a8336ecac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a407286cf325d4f43164700a8336ecac7">setPositionY</a> (float y)</td></tr>
<tr class="separator:a407286cf325d4f43164700a8336ecac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698c25ac964c12bc192ff491936642b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a698c25ac964c12bc192ff491936642b7">getWorldPosition</a> () const </td></tr>
<tr class="separator:a698c25ac964c12bc192ff491936642b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa57264ce0d46a3410ee704e6119a24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a3aa57264ce0d46a3410ee704e6119a24">getContentSize</a> () const </td></tr>
<tr class="separator:a3aa57264ce0d46a3410ee704e6119a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8ae817691b6077270aeb86d8e6fcd3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a0a8ae817691b6077270aeb86d8e6fcd3">setContentSize</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:a0a8ae817691b6077270aeb86d8e6fcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9edeba8eb0ab3fb668b79d26fd658fd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ac9edeba8eb0ab3fb668b79d26fd658fd">setContentSize</a> (float width, float height)</td></tr>
<tr class="separator:ac9edeba8eb0ab3fb668b79d26fd658fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc12a5e99f9feed8823dd069e461aa8c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#afc12a5e99f9feed8823dd069e461aa8c">getContentWidth</a> () const </td></tr>
<tr class="separator:afc12a5e99f9feed8823dd069e461aa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ee6cc103e400c70fd24eafe3de5215"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ad4ee6cc103e400c70fd24eafe3de5215">setContentWidth</a> (float width)</td></tr>
<tr class="separator:ad4ee6cc103e400c70fd24eafe3de5215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7b2adc2d545daff2cb196a1acb2f55"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4b7b2adc2d545daff2cb196a1acb2f55">getContentHeight</a> () const </td></tr>
<tr class="separator:a4b7b2adc2d545daff2cb196a1acb2f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ee621cec9e7fd879e1fed322799709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a41ee621cec9e7fd879e1fed322799709">setContentHeight</a> (float height)</td></tr>
<tr class="separator:a41ee621cec9e7fd879e1fed322799709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0897f9f799fa33ee1647f88d38efe2d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a0897f9f799fa33ee1647f88d38efe2d0">getSize</a> () const </td></tr>
<tr class="separator:a0897f9f799fa33ee1647f88d38efe2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f51a00fedb2349b5a11b7c076b58c70"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a6f51a00fedb2349b5a11b7c076b58c70">getWidth</a> () const </td></tr>
<tr class="separator:a6f51a00fedb2349b5a11b7c076b58c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf34c4e9fddcc265c23f1bce3bacd525"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#adf34c4e9fddcc265c23f1bce3bacd525">getHeight</a> () const </td></tr>
<tr class="separator:adf34c4e9fddcc265c23f1bce3bacd525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4002974b148d59c57b1da3bcdd1a9f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4002974b148d59c57b1da3bcdd1a9f33">getBoundingBox</a> () const </td></tr>
<tr class="separator:a4002974b148d59c57b1da3bcdd1a9f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1c34616fda2e52e782c1e4f63bdebd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a6a1c34616fda2e52e782c1e4f63bdebd">setAnchor</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;anchor)</td></tr>
<tr class="separator:a6a1c34616fda2e52e782c1e4f63bdebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca47d1024886ff6750af9339dbc6b183"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aca47d1024886ff6750af9339dbc6b183">setAnchor</a> (float x, float y)</td></tr>
<tr class="separator:aca47d1024886ff6750af9339dbc6b183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f7ef1bbadf6e1f4e95e3c141331df2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor</a> () const </td></tr>
<tr class="separator:a96f7ef1bbadf6e1f4e95e3c141331df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2df62d3f7c4fff1444a9ba345efa23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ad2df62d3f7c4fff1444a9ba345efa23f">getAnchorInPixels</a> ()</td></tr>
<tr class="separator:ad2df62d3f7c4fff1444a9ba345efa23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff4862c23a619b6fc7dc021f681627d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#abff4862c23a619b6fc7dc021f681627d">getColor</a> () const </td></tr>
<tr class="separator:abff4862c23a619b6fc7dc021f681627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0106e6b8b7feabff4af2f046bbb904a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a0106e6b8b7feabff4af2f046bbb904a2">setColor</a> (<a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:a0106e6b8b7feabff4af2f046bbb904a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4991c61a76b3f09a6f3056d73e7a4039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4991c61a76b3f09a6f3056d73e7a4039">getAbsoluteColor</a> ()</td></tr>
<tr class="separator:a4991c61a76b3f09a6f3056d73e7a4039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5870f669f9e691da4de29620e42267c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a5870f669f9e691da4de29620e42267c1">isVisible</a> () const </td></tr>
<tr class="separator:a5870f669f9e691da4de29620e42267c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4675cb74bb8f3cacc338ceab22c0a24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aa4675cb74bb8f3cacc338ceab22c0a24">setVisible</a> (bool visible)</td></tr>
<tr class="separator:aa4675cb74bb8f3cacc338ceab22c0a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db73ee0cefa7cd66dc587abcae1f0de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a6db73ee0cefa7cd66dc587abcae1f0de">hasRelativeColor</a> ()</td></tr>
<tr class="separator:a6db73ee0cefa7cd66dc587abcae1f0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d0ed3f7a12e1af12965ec248772061"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a76d0ed3f7a12e1af12965ec248772061">setRelativeColor</a> (bool flag)</td></tr>
<tr class="separator:a76d0ed3f7a12e1af12965ec248772061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef74ad990867093ee735c6e86a25023f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aef74ad990867093ee735c6e86a25023f">getScale</a> () const </td></tr>
<tr class="separator:aef74ad990867093ee735c6e86a25023f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66fc88a556f5fe2e47303a5b7bdecc41"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a66fc88a556f5fe2e47303a5b7bdecc41">getScaleX</a> () const </td></tr>
<tr class="separator:a66fc88a556f5fe2e47303a5b7bdecc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b8abe1e9590c9e007243bd9d1bd1c1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a27b8abe1e9590c9e007243bd9d1bd1c1">getScaleY</a> () const </td></tr>
<tr class="separator:a27b8abe1e9590c9e007243bd9d1bd1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb777d81bcfa45e604e6a8c34aaee43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#abcb777d81bcfa45e604e6a8c34aaee43">setScale</a> (float scale)</td></tr>
<tr class="separator:abcb777d81bcfa45e604e6a8c34aaee43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300159d09a87fd3f75d5a94937d527a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a300159d09a87fd3f75d5a94937d527a9">setScale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;vec)</td></tr>
<tr class="separator:a300159d09a87fd3f75d5a94937d527a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab0a7d92a4ecfbd2c6e4ab4b42e7210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#acab0a7d92a4ecfbd2c6e4ab4b42e7210">setScale</a> (float sx, float sy)</td></tr>
<tr class="separator:acab0a7d92a4ecfbd2c6e4ab4b42e7210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae529d2c818dd14a7e73d049464d3ae7c"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ae529d2c818dd14a7e73d049464d3ae7c">getAngle</a> ()</td></tr>
<tr class="separator:ae529d2c818dd14a7e73d049464d3ae7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab198070e67d86747bda04c48899ab81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aab198070e67d86747bda04c48899ab81">setAngle</a> (float angle)</td></tr>
<tr class="separator:aab198070e67d86747bda04c48899ab81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa1a8f89fa807c378bd44695a94b2a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aeaa1a8f89fa807c378bd44695a94b2a2">getAlternateTransform</a> ()</td></tr>
<tr class="separator:aeaa1a8f89fa807c378bd44695a94b2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc03e6c26c8afc17738d48a49ffdb86f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#adc03e6c26c8afc17738d48a49ffdb86f">setAlternateTransform</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:adc03e6c26c8afc17738d48a49ffdb86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062ae72c9418a12967b716c86c7e3dee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a062ae72c9418a12967b716c86c7e3dee">withAlternateTransform</a> ()</td></tr>
<tr class="separator:a062ae72c9418a12967b716c86c7e3dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73ab49f003f009a2dd7db7d678020ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab73ab49f003f009a2dd7db7d678020ec">chooseAlternateTransform</a> (bool active)</td></tr>
<tr class="separator:ab73ab49f003f009a2dd7db7d678020ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0c53f4fb4e4e0c56743429a17ef8d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4c0c53f4fb4e4e0c56743429a17ef8d7">getNodeToParentTransform</a> () const </td></tr>
<tr class="separator:a4c0c53f4fb4e4e0c56743429a17ef8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab694bea1b8c2ebae52a26c89346c4e9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab694bea1b8c2ebae52a26c89346c4e9b">getParentToNodeTransform</a> () const </td></tr>
<tr class="separator:ab694bea1b8c2ebae52a26c89346c4e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3de72993fd38ebb3346a6efa3f9e969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aa3de72993fd38ebb3346a6efa3f9e969">getNodeToWorldTransform</a> () const </td></tr>
<tr class="separator:aa3de72993fd38ebb3346a6efa3f9e969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af1be25ff2e7bec8339e5d0c45460d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a8af1be25ff2e7bec8339e5d0c45460d1">getWorldToNodeTransform</a> () const </td></tr>
<tr class="separator:a8af1be25ff2e7bec8339e5d0c45460d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234b680135b1fba02526294a730be41f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a234b680135b1fba02526294a730be41f">screenToNodeCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;screenPoint) const </td></tr>
<tr class="separator:a234b680135b1fba02526294a730be41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b851d805d533897dc856d55aa83aaf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a5b851d805d533897dc856d55aa83aaf5">worldToNodeCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;worldPoint) const </td></tr>
<tr class="separator:a5b851d805d533897dc856d55aa83aaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797190aee6f29b028fe7f58455f9671e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a797190aee6f29b028fe7f58455f9671e">nodeToScreenCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;nodePoint) const </td></tr>
<tr class="separator:a797190aee6f29b028fe7f58455f9671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac871ce33725d9ad5c0d0253c1a46336e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ac871ce33725d9ad5c0d0253c1a46336e">nodeToWorldCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;nodePoint) const </td></tr>
<tr class="separator:ac871ce33725d9ad5c0d0253c1a46336e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ab618f700ebed9f6a50518a6bf63bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab6ab618f700ebed9f6a50518a6bf63bd">parentToNodeCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;parentPoint) const </td></tr>
<tr class="separator:ab6ab618f700ebed9f6a50518a6bf63bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c3d6d801f24cc6bf777d5400d1eb48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a37c3d6d801f24cc6bf777d5400d1eb48">nodeToParentCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;nodePoint) const </td></tr>
<tr class="separator:a37c3d6d801f24cc6bf777d5400d1eb48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cee256602ea7ccce5d4ee59717d2d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a52cee256602ea7ccce5d4ee59717d2d6">setZOrder</a> (int z)</td></tr>
<tr class="separator:a52cee256602ea7ccce5d4ee59717d2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e4d20037fa52f7f7d4a5edf7a14c35"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a59e4d20037fa52f7f7d4a5edf7a14c35">getZOrder</a> () const </td></tr>
<tr class="separator:a59e4d20037fa52f7f7d4a5edf7a14c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b47e69a02eb9ebbedd045a371a6da52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4b47e69a02eb9ebbedd045a371a6da52">isZDirty</a> () const </td></tr>
<tr class="separator:a4b47e69a02eb9ebbedd045a371a6da52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f610475468b411372ea3afb544cf663"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a7f610475468b411372ea3afb544cf663">sortZOrder</a> ()</td></tr>
<tr class="separator:a7f610475468b411372ea3afb544cf663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b84f586dd4e09fd6649a8b76bcf02cb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a6b84f586dd4e09fd6649a8b76bcf02cb">getChildCount</a> () const </td></tr>
<tr class="separator:a6b84f586dd4e09fd6649a8b76bcf02cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53dd4f421e4cacf61faa711f6c11a55f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a53dd4f421e4cacf61faa711f6c11a55f">getChild</a> (unsigned int pos)</td></tr>
<tr class="separator:a53dd4f421e4cacf61faa711f6c11a55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532bfe574e5e22d9e89c9d3a70a2d0f9"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a532bfe574e5e22d9e89c9d3a70a2d0f9">getChild</a> (unsigned int pos) const </td></tr>
<tr class="separator:a532bfe574e5e22d9e89c9d3a70a2d0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5e54400d5ffa43a3a7402a236f535f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd5e54400d5ffa43a3a7402a236f535f"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#abd5e54400d5ffa43a3a7402a236f535f">getChild</a> (unsigned int pos) const </td></tr>
<tr class="separator:abd5e54400d5ffa43a3a7402a236f535f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1988874b474ee2bf9ebb4a2cabe2f1a2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a1988874b474ee2bf9ebb4a2cabe2f1a2">getChildByTag</a> (unsigned int tag) const </td></tr>
<tr class="separator:a1988874b474ee2bf9ebb4a2cabe2f1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ee7a3866292a19b2438737df1e19dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23ee7a3866292a19b2438737df1e19dc"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a23ee7a3866292a19b2438737df1e19dc">getChildByTag</a> (unsigned int tag) const </td></tr>
<tr class="separator:a23ee7a3866292a19b2438737df1e19dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a89cdb7bbbb6f3cc3c9e114309fc47"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#af3a89cdb7bbbb6f3cc3c9e114309fc47">getChildByName</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:af3a89cdb7bbbb6f3cc3c9e114309fc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b4aecdca2aeab6e120c3e8077e7632"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a74b4aecdca2aeab6e120c3e8077e7632"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a74b4aecdca2aeab6e120c3e8077e7632">getChildByName</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a74b4aecdca2aeab6e120c3e8077e7632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48942a4301eb2ffdba25bc1530efe6f0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a48942a4301eb2ffdba25bc1530efe6f0">getChildren</a> ()</td></tr>
<tr class="separator:a48942a4301eb2ffdba25bc1530efe6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3eac2759d4da2a1e2d255f708990d7"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ade3eac2759d4da2a1e2d255f708990d7">getChildren</a> () const </td></tr>
<tr class="separator:ade3eac2759d4da2a1e2d255f708990d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ebf15a615cc5c23a8a7884b842435bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a7ebf15a615cc5c23a8a7884b842435bb">addChild</a> (std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; child)</td></tr>
<tr class="separator:a7ebf15a615cc5c23a8a7884b842435bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a700024daff99ea37de512e21e2d0330b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a700024daff99ea37de512e21e2d0330b">addChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, int zval)</td></tr>
<tr class="separator:a700024daff99ea37de512e21e2d0330b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599f892feae7c74e536642ea88d07ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a599f892feae7c74e536642ea88d07ff9">addChildWithTag</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, unsigned int tag)</td></tr>
<tr class="separator:a599f892feae7c74e536642ea88d07ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55768205e9c549899bd128df6722a6e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a55768205e9c549899bd128df6722a6e9">addChildWithTag</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, unsigned int tag, int zval)</td></tr>
<tr class="separator:a55768205e9c549899bd128df6722a6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d845eb74a69953f1cd8412aecb3e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a8d845eb74a69953f1cd8412aecb3e723">addChildWithName</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, const std::string &amp;name)</td></tr>
<tr class="separator:a8d845eb74a69953f1cd8412aecb3e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2ed3bd160d5764d8a6dba1508acaf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ade2ed3bd160d5764d8a6dba1508acaf3">addChildWithName</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child, const std::string &amp;name, int zval)</td></tr>
<tr class="separator:ade2ed3bd160d5764d8a6dba1508acaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260cb3435cbd5e378872410f3f11da17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a260cb3435cbd5e378872410f3f11da17">swapChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child1, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child2, bool inherit=false)</td></tr>
<tr class="separator:a260cb3435cbd5e378872410f3f11da17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50acd02aab1f1475eb7a36a656a8263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#af50acd02aab1f1475eb7a36a656a8263">getParent</a> ()</td></tr>
<tr class="separator:af50acd02aab1f1475eb7a36a656a8263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c32a5e6d210be121d72ca13b0b30f0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a49c32a5e6d210be121d72ca13b0b30f0">getParent</a> () const </td></tr>
<tr class="separator:a49c32a5e6d210be121d72ca13b0b30f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420bbc05818d4db6bca7548309cabbcb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_scene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a420bbc05818d4db6bca7548309cabbcb">getScene</a> ()</td></tr>
<tr class="separator:a420bbc05818d4db6bca7548309cabbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccbeb19ea7b6ed7bf33431bfa1f6e99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_scene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aeccbeb19ea7b6ed7bf33431bfa1f6e99">getScene</a> () const </td></tr>
<tr class="separator:aeccbeb19ea7b6ed7bf33431bfa1f6e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321e63fe345f3eb4a4770a506c9b90b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a321e63fe345f3eb4a4770a506c9b90b0">removeFromParent</a> ()</td></tr>
<tr class="separator:a321e63fe345f3eb4a4770a506c9b90b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf52f91953f9a7df3fc563dcc4dfb190"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#acf52f91953f9a7df3fc563dcc4dfb190">removeChild</a> (unsigned int pos)</td></tr>
<tr class="separator:acf52f91953f9a7df3fc563dcc4dfb190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96abf42e4c58edbd75291621070f3af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a96abf42e4c58edbd75291621070f3af6">removeChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;child)</td></tr>
<tr class="separator:a96abf42e4c58edbd75291621070f3af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a90a92d8b8e592ffc77de774541ea40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a3a90a92d8b8e592ffc77de774541ea40">removeChildByTag</a> (unsigned int tag)</td></tr>
<tr class="separator:a3a90a92d8b8e592ffc77de774541ea40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffde2d492e4f2ecd080801f85f0fe9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4ffde2d492e4f2ecd080801f85f0fe9c">removeChildByName</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a4ffde2d492e4f2ecd080801f85f0fe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e510e8d40688d6a0c488eac78403c84"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4e510e8d40688d6a0c488eac78403c84">removeAllChildren</a> ()</td></tr>
<tr class="separator:a4e510e8d40688d6a0c488eac78403c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132956e348805bdab9f99f48e375d7e1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a132956e348805bdab9f99f48e375d7e1">render</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;batch, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, <a class="el" href="classcugl_1_1_color4.html">Color4</a> tint)</td></tr>
<tr class="separator:a132956e348805bdab9f99f48e375d7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a3192181ce5f10d905d2fd371a8f76"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab3a3192181ce5f10d905d2fd371a8f76">render</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;batch)</td></tr>
<tr class="separator:ab3a3192181ce5f10d905d2fd371a8f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9510e78aa199eaddc506d13882c24a65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a9510e78aa199eaddc506d13882c24a65">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;batch, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, <a class="el" href="classcugl_1_1_color4.html">Color4</a> tint)</td></tr>
<tr class="separator:a9510e78aa199eaddc506d13882c24a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0a68b43c14cb6689a14edc6ecb4612"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_layout.html">Layout</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a6b0a68b43c14cb6689a14edc6ecb4612">getLayout</a> () const </td></tr>
<tr class="separator:a6b0a68b43c14cb6689a14edc6ecb4612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b285a3176996a2343ad2b588d69ca08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a8b285a3176996a2343ad2b588d69ca08">setLayout</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_layout.html">Layout</a> &gt; &amp;layout)</td></tr>
<tr class="separator:a8b285a3176996a2343ad2b588d69ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35f84fba729c4a27b0bd1362d56d614"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab35f84fba729c4a27b0bd1362d56d614">doLayout</a> ()</td></tr>
<tr class="separator:ab35f84fba729c4a27b0bd1362d56d614"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:adf5dc0618e9623f343e02ef5d3bb0546"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#adf5dc0618e9623f343e02ef5d3bb0546">alloc</a> ()</td></tr>
<tr class="separator:adf5dc0618e9623f343e02ef5d3bb0546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4340feae07fbf1d9456b660df70b1911"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a4340feae07fbf1d9456b660df70b1911">allocWithPosition</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;pos)</td></tr>
<tr class="separator:a4340feae07fbf1d9456b660df70b1911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506806c8d8a7125006f687c6498bcc26"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a506806c8d8a7125006f687c6498bcc26">allocWithPosition</a> (float x, float y)</td></tr>
<tr class="separator:a506806c8d8a7125006f687c6498bcc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95a48fa097ef3cf3c30f24b5615bfbd"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ad95a48fa097ef3cf3c30f24b5615bfbd">allocWithBounds</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;size)</td></tr>
<tr class="separator:ad95a48fa097ef3cf3c30f24b5615bfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a2984a7b940226db9f0655e7c932c2"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a73a2984a7b940226db9f0655e7c932c2">allocWithBounds</a> (float width, float height)</td></tr>
<tr class="separator:a73a2984a7b940226db9f0655e7c932c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f5ae54daae9929dbbcd538076b0f1b"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aa8f5ae54daae9929dbbcd538076b0f1b">allocWithBounds</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:aa8f5ae54daae9929dbbcd538076b0f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f76c5823cca09c63f955296770c5990"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a2f76c5823cca09c63f955296770c5990">allocWithBounds</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:a2f76c5823cca09c63f955296770c5990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae621214229a04bd4ed7df625d299665b"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ae621214229a04bd4ed7df625d299665b">allocWithData</a> (const <a class="el" href="classcugl_1_1_scene_loader.html">SceneLoader</a> *loader, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;data)</td></tr>
<tr class="separator:ae621214229a04bd4ed7df625d299665b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a52f25f2cad71d3976e877e3145621e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a52f25f2cad71d3976e877e3145621e04">_position</a></td></tr>
<tr class="separator:a52f25f2cad71d3976e877e3145621e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5359ad4e19ca4f97786757b28ad940bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a5359ad4e19ca4f97786757b28ad940bc">_anchor</a></td></tr>
<tr class="separator:a5359ad4e19ca4f97786757b28ad940bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730765e8808fe4ece8f42e2e14bc49ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a730765e8808fe4ece8f42e2e14bc49ed">_contentSize</a></td></tr>
<tr class="separator:a730765e8808fe4ece8f42e2e14bc49ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca58d152a4aab54815acdf4ff0222821"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aca58d152a4aab54815acdf4ff0222821">_tintColor</a></td></tr>
<tr class="separator:aca58d152a4aab54815acdf4ff0222821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770225163af3ea586747ed527f16bcf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a770225163af3ea586747ed527f16bcf3">_hasParentColor</a></td></tr>
<tr class="separator:a770225163af3ea586747ed527f16bcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4b8e4c6f503e12295784a0aa810dd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a1c4b8e4c6f503e12295784a0aa810dd8">_isVisible</a></td></tr>
<tr class="separator:a1c4b8e4c6f503e12295784a0aa810dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b1e76ec7fbd7229a5c6de9b2040008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a62b1e76ec7fbd7229a5c6de9b2040008">_scale</a></td></tr>
<tr class="separator:a62b1e76ec7fbd7229a5c6de9b2040008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad544a4dd2fce692ea97fcb5a7e1cb661"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ad544a4dd2fce692ea97fcb5a7e1cb661">_angle</a></td></tr>
<tr class="separator:ad544a4dd2fce692ea97fcb5a7e1cb661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f272d4763dfdc98c38da469a8be2a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a75f272d4763dfdc98c38da469a8be2a7">_transform</a></td></tr>
<tr class="separator:a75f272d4763dfdc98c38da469a8be2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae682010710abd27156772fd05c62bb0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ae682010710abd27156772fd05c62bb0a">_useTransform</a></td></tr>
<tr class="separator:ae682010710abd27156772fd05c62bb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0be4afeb408d2d1989d788fb295b4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aea0be4afeb408d2d1989d788fb295b4e">_combined</a></td></tr>
<tr class="separator:aea0be4afeb408d2d1989d788fb295b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab386dc005d6e2cae41c729ecab44170d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ab386dc005d6e2cae41c729ecab44170d">_children</a></td></tr>
<tr class="separator:ab386dc005d6e2cae41c729ecab44170d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5254ad8f2b5164dd7fa0f35bd798f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a3c5254ad8f2b5164dd7fa0f35bd798f7">_parent</a></td></tr>
<tr class="separator:a3c5254ad8f2b5164dd7fa0f35bd798f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a868e33be8d86c54ea3a5f5f040e323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_scene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a8a868e33be8d86c54ea3a5f5f040e323">_graph</a></td></tr>
<tr class="separator:a8a868e33be8d86c54ea3a5f5f040e323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62bd80314b5d89f2b9eb84a5e9d5cf2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_layout.html">Layout</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#ae62bd80314b5d89f2b9eb84a5e9d5cf2">_layout</a></td></tr>
<tr class="separator:ae62bd80314b5d89f2b9eb84a5e9d5cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5286ef6807047bdf00afb2fd2d9225c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a5286ef6807047bdf00afb2fd2d9225c7">_childOffset</a></td></tr>
<tr class="separator:a5286ef6807047bdf00afb2fd2d9225c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aab8955161507cffb87cce2d9d9109b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a7aab8955161507cffb87cce2d9d9109b">_tag</a></td></tr>
<tr class="separator:a7aab8955161507cffb87cce2d9d9109b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70a1b6ae1c2b6f2add8b84ab7275b42"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#aa70a1b6ae1c2b6f2add8b84ab7275b42">_name</a></td></tr>
<tr class="separator:aa70a1b6ae1c2b6f2add8b84ab7275b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d32a25cde02bb61314201dc5e099d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a46d32a25cde02bb61314201dc5e099d5">_hashOfName</a></td></tr>
<tr class="separator:a46d32a25cde02bb61314201dc5e099d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522f68e7601cd49d7cd4594899075ce4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a522f68e7601cd49d7cd4594899075ce4">_zOrder</a></td></tr>
<tr class="separator:a522f68e7601cd49d7cd4594899075ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab3c26b8b1bffe5411323c9a33ab6c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_node.html#a2ab3c26b8b1bffe5411323c9a33ab6c9">_zDirty</a></td></tr>
<tr class="separator:a2ab3c26b8b1bffe5411323c9a33ab6c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a032858ae1fe02d2d1170981c2af2d67c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a032858ae1fe02d2d1170981c2af2d67c"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Scene</b></td></tr>
<tr class="separator:a032858ae1fe02d2d1170981c2af2d67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides a 2d scene graph node.</p>
<p>A base node is a rectangular space that can contain other (transformed) nodes. Each <a class="el" href="classcugl_1_1_node.html">Node</a> forms a its own coordinate space. All rendering takes place inside of this coordinate space. By default, a <a class="el" href="classcugl_1_1_node.html">Node</a> does not render anything, but it does provide rendering support for subclasses via the <a class="el" href="classcugl_1_1_node.html#a9510e78aa199eaddc506d13882c24a65">draw()</a> method.</p>
<p>Rendering happens by traversing the the scene graph using an "Pre-Order" tree traversal algorithm ( <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</a> ). That means that parents are always draw before (and behind children). The children of each sub tree are ordered by z-value (or by the order added).</p>
<p>One of the important pitfalls of the <a class="el" href="classcugl_1_1_node.html">Node</a> class is that the position of a a <a class="el" href="classcugl_1_1_node.html">Node</a> does not necessarily define the position of its Node-space origin. that means that transforms applied to the <a class="el" href="classcugl_1_1_node.html">Node</a> do not necessarily leave the <a class="el" href="classcugl_1_1_node.html">Node</a> position unaffected.</p>
<p>That is why it is important to understand the difference between the anchor and the origin. Each <a class="el" href="classcugl_1_1_node.html">Node</a> is a rectangular bounding-box, and its origin is the bottom left corner. However, the anchor can be any point inside of the bounding box. The scale and angle are applied to the anchor point, NOT the <a class="el" href="classcugl_1_1_node.html">Node</a> origin. If you want to apply a traditional transform to the <a class="el" href="classcugl_1_1_node.html">Node</a> origin, you will need to use the <a class="el" href="classcugl_1_1_node.html#adc03e6c26c8afc17738d48a49ffdb86f">setAlternateTransform()</a> option.</p>
<p>In addition, when a <a class="el" href="classcugl_1_1_node.html">Node</a> is resized, the resizing takes place relative to the anchor point. That means that the position is unchanged, but the node origin may move. However, if the anchor is altered, the <a class="el" href="classcugl_1_1_node.html">Node</a> itself does not move while the position changes. While this may seem counter-intuitive, this is traditional sprite behavior, and scene graph nodes are just a generalization of a sprite. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac6225223f6215d48dc6f89e612fa302d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Node::Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an uninitialized node.</p>
<p>You must initialize this <a class="el" href="classcugl_1_1_node.html">Node</a> before use.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate a <a class="el" href="classcugl_1_1_node.html">Node</a> on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a class="anchor" id="add87aa9f75ae13b38a9e45fb60de3dcc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Node::~Node </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this node, disposing all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7ebf15a615cc5c23a8a7884b842435bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::addChild </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this node.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a700024daff99ea37de512e21e2d0330b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::addChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this node with the given z-order.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d845eb74a69953f1cd8412aecb3e723"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::addChildWithName </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this node with the given name.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade2ed3bd160d5764d8a6dba1508acaf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::addChildWithName </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this node with the given name and z-order</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a599f892feae7c74e536642ea88d07ff9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::addChildWithTag </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this node with the given tag.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55768205e9c549899bd128df6722a6e9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::addChildWithTag </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this node with the given tag and z-order</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf5dc0618e9623f343e02ef5d3bb0546"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node at the world origin.</p>
<p>The node has both position and size (0,0).</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node at the world origin. </dd></dl>

</div>
</div>
<a class="anchor" id="ad95a48fa097ef3cf3c30f24b5615bfbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::allocWithBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node with the given size.</p>
<p>The size defines the content size. The bounding box of the node is (0,0,width,height). Hence the node is anchored in the center and has position (width/2,height/2) in the parent space. The node origin is the (0,0) at the bottom left corner of the bounding box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node with the given size. </dd></dl>

</div>
</div>
<a class="anchor" id="a73a2984a7b940226db9f0655e7c932c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::allocWithBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node with the given size.</p>
<p>The size defines the content size. The bounding box of the node is (0,0,width,height). Hence the node is anchored in the center and has position (width/2,height/2) in the parent space. The node origin is the (0,0) at the bottom left corner of the bounding box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the node in parent space </td></tr>
    <tr><td class="paramname">height</td><td>The height of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node with the given size. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8f5ae54daae9929dbbcd538076b0f1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::allocWithBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node with the given bounds.</p>
<p>The rectangle origin is the bottom left corner of the node in parent space, and corresponds to the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> space. The size defines its content width and height. The node is anchored in the center and has position origin-(width/2,height/2) in parent space.</p>
<p>Because the bounding box is explicit, this is the preferred constructor for Nodes that will explicitly contain other Nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The bounds of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node with the given bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f76c5823cca09c63f955296770c5990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::allocWithBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node with the given bounds.</p>
<p>The rectangle origin is the bottom left corner of the node in parent space, and corresponds to the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> space. The size defines its content width and height. The node is anchored in the center and has position origin-(width/2,height/2) in parent space.</p>
<p>Because the bounding box is explicit, this is the preferred constructor for Nodes that will explicitly contain other Nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the node origin in parent space </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the node origin in parent space </td></tr>
    <tr><td class="paramname">width</td><td>The width of the node in parent space </td></tr>
    <tr><td class="paramname">height</td><td>The height of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node with the given bounds. </dd></dl>

</div>
</div>
<a class="anchor" id="ae621214229a04bd4ed7df625d299665b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::allocWithData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_scene_loader.html">SceneLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node with the given JSON specification.</p>
<p>This initializer is designed to receive the "data" object from the JSON passed to <a class="el" href="classcugl_1_1_scene_loader.html">SceneLoader</a>. This JSON format supports the following attribute values: </p><pre class="fragment"> "position": A two-element number array
 "size":     A two-element number array
 "anchor":   A two-element number array representing the anchor point
 "color":    A four-element integer array.  Values should be 0..255
 "scale":    A two-element number array
 "angle":    A number, representing the rotation in DEGREES, not radians
 "visible":  A boolean value, representing if the node is visible
</pre><p>All attributes are optional. There are no required attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>The scene loader passing this JSON file </td></tr>
    <tr><td class="paramname">data</td><td>The JSON object specifying the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node with the given JSON specification. </dd></dl>

</div>
</div>
<a class="anchor" id="a4340feae07fbf1d9456b660df70b1911"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::allocWithPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node at the given position.</p>
<p>The node has size (0,0). As a result, the position is identified with the origin of the node space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The origin of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="a506806c8d8a7125006f687c6498bcc26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::allocWithPosition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated node at the given position.</p>
<p>The node has size (0,0). As a result, the position is identified with the origin of the node space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the node in parent space </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated node at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="ab73ab49f003f009a2dd7db7d678020ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::chooseAlternateTransform </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set whether the <a class="el" href="classcugl_1_1_node.html">Node</a> is using the alternate transform.</p>
<p>Unlike the built-in scaling and rotation, the alternate transform is applied to the coordinate space of the <a class="el" href="classcugl_1_1_node.html">Node</a> (e.g. with the origin in the bottom left corner).</p>
<p>Scaling/rotation and the alternate transform do no play nice with each other. It does not make sense to stack them on top of one another in either direction. Hence, you should only use of of the two. This method determines whether the alternate transform is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">active</td><td>Whether the <a class="el" href="classcugl_1_1_node.html">Node</a> is using the alternate transform. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad59d2dead9e24bbb24a89f933631a0de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcugl_1_1_node.html">Node</a>* cugl::Node::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a shallow copy of this <a class="el" href="classcugl_1_1_node.html">Node</a> into dst.</p>
<p>No children from this node are copied, and no children of dst are modified. In addition, the parents of both Nodes are unchanged. However, all other attributes of this node are copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The <a class="el" href="classcugl_1_1_node.html">Node</a> to copy into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e721d709d2dc1ae7c758d8d29de779b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disposes all of the resources used by this node.</p>
<p>A disposed <a class="el" href="classcugl_1_1_node.html">Node</a> can be safely reinitialized. Any children owned by this node will be released. They will be deleted if no other object owns them.</p>
<p>It is unsafe to call this on a <a class="el" href="classcugl_1_1_node.html">Node</a> that is still currently inside of a scene graph. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1_label.html#ac481ee167caf34538641c370fb217067">cugl::Label</a>, <a class="el" href="classcugl_1_1_slider.html#ac454f2ea98ac2206672730945c79d9ba">cugl::Slider</a>, <a class="el" href="classcugl_1_1_text_field.html#ae88278da71972e8ecf5aaac5f64286b2">cugl::TextField</a>, <a class="el" href="classcugl_1_1_button.html#a8a5a4ccb64b18e42ac8c70b5d7a391a6">cugl::Button</a>, <a class="el" href="classcugl_1_1_textured_node.html#a3d33e90a654854ecdc7ec42dc5618793">cugl::TexturedNode</a>, <a class="el" href="classcugl_1_1_nine_patch.html#a71d804c065ed373377d0f313ddbf9754">cugl::NinePatch</a>, and <a class="el" href="classcugl_1_1_progress_bar.html#a92b1782129cb35af612fd497222e33f7">cugl::ProgressBar</a>.</p>

</div>
</div>
<a class="anchor" id="ab35f84fba729c4a27b0bd1362d56d614"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::doLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Arranges the child of this node using the layout manager.</p>
<p>This process occurs recursively and top-down. A layout manager may end up resizing the children. That is why the parent must finish its layout before we can apply a layout manager to the children. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1_button.html#a40eba63d88ddbeef34c6ec09035d724a">cugl::Button</a>.</p>

</div>
</div>
<a class="anchor" id="a9510e78aa199eaddc506d13882c24a65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>tint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws this <a class="el" href="classcugl_1_1_node.html">Node</a> via the given <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>.</p>
<p>This method only worries about drawing the current node. It does not attempt to render the children.</p>
<p>This is the method that you should override to implement your custom drawing code. You are welcome to use any OpenGL commands that you wish. You can even skip use of the <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>. However, if you do so, you must flush the <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> by calling end() at the start of the method. in addition, you should remember to call begin() at the start of the method.</p>
<p>This method provides the correct transformation matrix and tint color. You do not need to worry about whether the node uses relative color. This method is called by <a class="el" href="classcugl_1_1_node.html#a132956e348805bdab9f99f48e375d7e1">render()</a> and these values are guaranteed to be correct. In addition, this method does not need to check for visibility, as it is guaranteed to only be called when the node is visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> to draw with. </td></tr>
    <tr><td class="paramname">transform</td><td>The global transformation matrix. </td></tr>
    <tr><td class="paramname">tint</td><td>The tint to blend with the <a class="el" href="classcugl_1_1_node.html">Node</a> color. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_label.html#a23b8f50c35b7b3929b5a58c81299a494">cugl::Label</a>, <a class="el" href="classcugl_1_1_textured_node.html#a9051e35f70a6f72afff324173dd4e8f4">cugl::TexturedNode</a>, <a class="el" href="classcugl_1_1_path_node.html#a5c5418469fdcf4506053963838b982e1">cugl::PathNode</a>, <a class="el" href="classcugl_1_1_nine_patch.html#a2e27c7ca391e0ca070491decf9930329">cugl::NinePatch</a>, <a class="el" href="classcugl_1_1_text_field.html#a94c0d21f60f1da17fadf067c168e72de">cugl::TextField</a>, <a class="el" href="classcugl_1_1_wire_node.html#a51dc8b01e1a8597e338a8ad8013907b5">cugl::WireNode</a>, and <a class="el" href="classcugl_1_1_polygon_node.html#a986fd762f8d9496df7005518457bddc1">cugl::PolygonNode</a>.</p>

</div>
</div>
<a class="anchor" id="a4991c61a76b3f09a6f3056d73e7a4039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::Node::getAbsoluteColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the absolute color tinting this node.</p>
<p>If <a class="el" href="classcugl_1_1_node.html#a6db73ee0cefa7cd66dc587abcae1f0de">hasRelativeColor()</a> is true, this value is the base color multiplied by the absolute color of its parent. If <a class="el" href="classcugl_1_1_node.html#a6db73ee0cefa7cd66dc587abcae1f0de">hasRelativeColor()</a> is false, it is the same as the tint color.</p>
<dl class="section return"><dt>Returns</dt><dd>the absolute color tinting this node. </dd></dl>

</div>
</div>
<a class="anchor" id="aeaa1a8f89fa807c378bd44695a94b2a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&amp; cugl::Node::getAlternateTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the alternate transform of this node.</p>
<p>Unlike the built-in scaling and rotation, this transform is applied to the coordinate space of the <a class="el" href="classcugl_1_1_node.html">Node</a> (e.g. with the origin in the bottom left corner).</p>
<p>Scaling/rotation and the alternate transform do no play nice with each other. It does not make sense to stack them on top of one another in either direction. Hence, you should only use of of the two. See the method <a class="el" href="">activateAlternateTransform(bool)</a> to choose.</p>
<dl class="section return"><dt>Returns</dt><dd>the alternate transform of this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a96f7ef1bbadf6e1f4e95e3c141331df2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&amp; cugl::Node::getAnchor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the anchor point in percent.</p>
<p>The anchor point defines the relative origin of <a class="el" href="classcugl_1_1_node.html">Node</a> with respect to its parent. It is a "pin" where the <a class="el" href="classcugl_1_1_node.html">Node</a> is attached to its parent. In effect, the translation of a <a class="el" href="classcugl_1_1_node.html">Node</a> is defined by its position plus anchor point.</p>
<p>The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. There are many anchor point constants defined in <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>. However, there is nothing preventing an anchor point higher than (1,1) or lower than (0,0).</p>
<p>The default anchorPoint is (0.5,0.5), so it starts in the center of the node. Changing the anchor will not move the contents of the node in the parent space, but it will change the value of the <a class="el" href="classcugl_1_1_node.html">Node</a> position.</p>
<dl class="section return"><dt>Returns</dt><dd>The anchor point in percent. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2df62d3f7c4fff1444a9ba345efa23f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::getAnchorInPixels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the anchor point in pixels.</p>
<p>The anchor point defines the relative origin of <a class="el" href="classcugl_1_1_node.html">Node</a> with respect to its parent. It is a "pin" where the <a class="el" href="classcugl_1_1_node.html">Node</a> is attached to its parent. In effect, the translation of a <a class="el" href="classcugl_1_1_node.html">Node</a> is defined by its position plus anchor point.</p>
<p>This version of the anchor point is multiplied by the size of the <a class="el" href="classcugl_1_1_node.html">Node</a> bounding box. Hence (0,0) means the bottom-left corner and (width,height) means the top-right corner.</p>
<dl class="section return"><dt>Returns</dt><dd>The anchor point in percent. </dd></dl>

</div>
</div>
<a class="anchor" id="ae529d2c818dd14a7e73d049464d3ae7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getAngle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rotation angle of this node.</p>
<p>This value rotates the node about the anchor, with the anchor unmoved. The angle is measured in radians , counter-clockwise from the x-axis. Rotation is applied after scaling.</p>
<dl class="section return"><dt>Returns</dt><dd>the rotation angle of this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a4002974b148d59c57b1da3bcdd1a9f33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Node::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an AABB (axis-aligned bounding-box) in the parent's coordinates.</p>
<p>This method returns the minimal axis-aligned bounding box that contains the transformed node in its parents coordinate system. If the node is rotated, this may not be a perfect fit of the transformed contents.</p>
<dl class="section return"><dt>Returns</dt><dd>An AABB (axis-aligned bounding-box) in the parent's coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a53dd4f421e4cacf61faa711f6c11a55f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the given position.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="a532bfe574e5e22d9e89c9d3a70a2d0f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt;&amp; cugl::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the given position.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="abd5e54400d5ffa43a3a7402a236f535f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Node::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the child at the given position, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type <a class="el" href="classcugl_1_1_node.html">Node</a>, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="af3a89cdb7bbbb6f3cc3c9e114309fc47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (first) child with the given name.</p>
<p>If there is more than one child of the given name, it returns the first one that is found. For the base <a class="el" href="classcugl_1_1_node.html">Node</a> class, children are always enumerated in the order that they are added. However, this is not guaranteed for subclasses of <a class="el" href="classcugl_1_1_node.html">Node</a>. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given name. </dd></dl>

</div>
</div>
<a class="anchor" id="a74b4aecdca2aeab6e120c3e8077e7632"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Node::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) child with the given name, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type <a class="el" href="classcugl_1_1_node.html">Node</a>, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>If there is more than one child of the given name, it returns the first one that is found. For the base <a class="el" href="classcugl_1_1_node.html">Node</a> class, children are always enumerated in the order that they are added. However, this is not guaranteed for subclasses of <a class="el" href="classcugl_1_1_node.html">Node</a>. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given name, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a1988874b474ee2bf9ebb4a2cabe2f1a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; cugl::Node::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (first) child with the given tag.</p>
<p>If there is more than one child of the given tag, it returns the first one that is found. For the base <a class="el" href="classcugl_1_1_node.html">Node</a> class, children are always enumerated in the order that they are added. However, this is not guaranteed for subclasses of <a class="el" href="classcugl_1_1_node.html">Node</a>. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given tag. </dd></dl>

</div>
</div>
<a class="anchor" id="a23ee7a3866292a19b2438737df1e19dc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Node::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) child with the given tag, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type <a class="el" href="classcugl_1_1_node.html">Node</a>, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>If there is more than one child of the given tag, it returns the first one that is found. For the base <a class="el" href="classcugl_1_1_node.html">Node</a> class, children are always enumerated in the order that they are added. However, this is not guaranteed for subclasses of <a class="el" href="classcugl_1_1_node.html">Node</a>. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given tag, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b84f586dd4e09fd6649a8b76bcf02cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Node::getChildCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of children of this node.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of children of this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a48942a4301eb2ffdba25bc1530efe6f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; &gt; cugl::Node::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of the node's children.</p>
<dl class="section return"><dt>Returns</dt><dd>the list of the node's children. </dd></dl>

</div>
</div>
<a class="anchor" id="ade3eac2759d4da2a1e2d255f708990d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; &gt;&amp; cugl::Node::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of the node's children.</p>
<dl class="section return"><dt>Returns</dt><dd>the list of the node's children. </dd></dl>

</div>
</div>
<a class="anchor" id="abff4862c23a619b6fc7dc021f681627d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::Node::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the color tinting this node.</p>
<p>This color will be multiplied with the parent (this node on top) if <a class="el" href="classcugl_1_1_node.html#a6db73ee0cefa7cd66dc587abcae1f0de">hasRelativeColor()</a> is true.</p>
<p>The default color is white, which means that all children have their natural color.</p>
<dl class="section return"><dt>Returns</dt><dd>the color tinting this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b7b2adc2d545daff2cb196a1acb2f55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getContentHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the untransformed height of the node.</p>
<p>The content height remains the same no matter how the node is scaled or rotated. All nodes must have a height, though it may be degenerate (0).</p>
<dl class="section return"><dt>Returns</dt><dd>the untransformed height of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a3aa57264ce0d46a3410ee704e6119a24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_size.html">Size</a>&amp; cugl::Node::getContentSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the untransformed size of the node.</p>
<p>The content size remains the same no matter how the node is scaled or rotated. All nodes must have a size, though it may be degenerate (0,0).</p>
<dl class="section return"><dt>Returns</dt><dd>the untransformed size of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="afc12a5e99f9feed8823dd069e461aa8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getContentWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the untransformed width of the node.</p>
<p>The content width remains the same no matter how the node is scaled or rotated. All nodes must have a width, though it may be degenerate (0).</p>
<dl class="section return"><dt>Returns</dt><dd>the untransformed width of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="adf34c4e9fddcc265c23f1bce3bacd525"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the transformed height of the node.</p>
<p>This method returns the height of the axis-aligned bounding box that contains the transformed node in its parents coordinate system. If the node is rotated, this may not be a perfect fit of the transformed contents.</p>
<dl class="section return"><dt>Returns</dt><dd>the transformed height of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b0a68b43c14cb6689a14edc6ecb4612"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_layout.html">Layout</a>&gt;&amp; cugl::Node::getLayout </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the layout manager for this node</p>
<p>We had originally intended to completely decouple layout managers from nodes. However, nodes (including layout assignemnts) are typically built bottom-up, while layout must happen top down to correctly resize elements. Therefore, we do allow the addition of an optional layout manager.</p>
<dl class="section return"><dt>Returns</dt><dd>the layout manager for this node </dd></dl>

</div>
</div>
<a class="anchor" id="a7fb1b6d46a20b3a4ddfee81d976e4c26"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::Node::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is used to identify the node.</p>
<p>This name is used to access a child node, since child position may change. In addition, the name is useful for debugging. To work properly, a name should be unique within a scene graph. It is empty if undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>a string that is used to identify the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c0c53f4fb4e4e0c56743429a17ef8d7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&amp; cugl::Node::getNodeToParentTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix transforming node space to parent space.</p>
<p>This value is the node's transform. It is either computed from the scale and rotation about the anchor, or the alternate transform, as determined by defined by <a class="el" href="">activateAlternateTransform(bool)</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix transforming node space to parent space. </dd></dl>

</div>
</div>
<a class="anchor" id="aa3de72993fd38ebb3346a6efa3f9e969"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> cugl::Node::getNodeToWorldTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the matrix transforming node space to world space.</p>
<p>This matrix is used to convert node coordinates into OpenGL coordinates. It is the recursive (left-multiplied) node-to-parent transforms of all of its ancestors.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix transforming node space to world space. </dd></dl>

</div>
</div>
<a class="anchor" id="af50acd02aab1f1475eb7a36a656a8263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_node.html">Node</a>* cugl::Node::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a (weak) pointer to the parent node.</p>
<p>The purpose of this pointer is to climb back up the scene graph tree. No child asserts ownership of its parent.</p>
<dl class="section return"><dt>Returns</dt><dd>a (weak) pointer to the parent node. </dd></dl>

</div>
</div>
<a class="anchor" id="a49c32a5e6d210be121d72ca13b0b30f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_node.html">Node</a>* cugl::Node::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a (weak) pointer to the parent node.</p>
<p>The purpose of this pointer is to climb back up the scene graph tree. No child asserts ownership of its parent.</p>
<dl class="section return"><dt>Returns</dt><dd>a (weak) pointer to the parent node. </dd></dl>

</div>
</div>
<a class="anchor" id="ab694bea1b8c2ebae52a26c89346c4e9b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> cugl::Node::getParentToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix transforming parent space to node space.</p>
<p>This value is the inverse that node's transform. It is either computed from the scale and rotation about the anchor, or the alternate transform, as determined by defined by <a class="el" href="">activateAlternateTransform(bool)</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix transforming parent space to node space. </dd></dl>

</div>
</div>
<a class="anchor" id="abbbc65f390d5bd3561c9f4b7ac5b9a89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&amp; cugl::Node::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the position of the node in its parent's coordinate system.</p>
<p>The node position is not necessarily the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> coordinate system. The relationship between the position and <a class="el" href="classcugl_1_1_node.html">Node</a> space is determined by the anchor point. See <a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor()</a> for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>the position of the node in its parent's coordinate system. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c7375891306a66788048c7151f60665"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getPositionX </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the x-coordinate of the node in its parent's coordinate system.</p>
<p>The node position is not necessarily the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> coordinate system. The relationship between the position and <a class="el" href="classcugl_1_1_node.html">Node</a> space is determined by the anchor point. See <a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor()</a> for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>the x-coordinate of the node in its parent's coordinate system. </dd></dl>

</div>
</div>
<a class="anchor" id="abbc1f7ee11a9b20ea06a71b2c8f9ec54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getPositionY </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the y-coordinate of the node in its parent's coordinate system.</p>
<p>The node position is not necessarily the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> coordinate system. The relationship between the position and <a class="el" href="classcugl_1_1_node.html">Node</a> space is determined by the anchor point. See <a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor()</a> for more details.</p>
<dl class="section return"><dt>Returns</dt><dd>the y-coordinate of the node in its parent's coordinate system. </dd></dl>

</div>
</div>
<a class="anchor" id="aef74ad990867093ee735c6e86a25023f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&amp; cugl::Node::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the non-uniform scaling factor for this node about the anchor.</p>
<p>This factor scales the node about the anchor (with the anchor unmoved). Hence this is not the same as a scale applied to <a class="el" href="classcugl_1_1_node.html">Node</a> space, as the origin is in the bottom left corner. Scaling is first, before any other transforms.</p>
<dl class="section return"><dt>Returns</dt><dd>the non-uniform scaling factor for this node about the anchor </dd></dl>

</div>
</div>
<a class="anchor" id="a66fc88a556f5fe2e47303a5b7bdecc41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getScaleX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the x-axis scaling factor for this node.</p>
<p>This factor scales the node about the anchor (with the anchor unmoved). Hence this is not the same as a scale applied to <a class="el" href="classcugl_1_1_node.html">Node</a> space, as the origin is in the bottom left corner. Scaling is first, before any other transforms.</p>
<dl class="section return"><dt>Returns</dt><dd>the x-axis scaling factor for this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a27b8abe1e9590c9e007243bd9d1bd1c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getScaleY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the y-axis scaling factor for this node.</p>
<p>This factor scales the node about the anchor (with the anchor unmoved). Hence this is not the same as a scale applied to <a class="el" href="classcugl_1_1_node.html">Node</a> space, as the origin is in the bottom left corner. Scaling is first, before any other transforms.</p>
<dl class="section return"><dt>Returns</dt><dd>the y-axis scaling factor for this node. </dd></dl>

</div>
</div>
<a class="anchor" id="a420bbc05818d4db6bca7548309cabbcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_scene.html">Scene</a>* cugl::Node::getScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a (weak) pointer to the scene graph.</p>
<p>The purpose of this pointer is to climb back up to the root of the scene graph tree. No node asserts ownership of its scene.</p>
<dl class="section return"><dt>Returns</dt><dd>a (weak) pointer to the scene graph. </dd></dl>

</div>
</div>
<a class="anchor" id="aeccbeb19ea7b6ed7bf33431bfa1f6e99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_scene.html">Scene</a>* cugl::Node::getScene </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a (weak) pointer to the scene graph.</p>
<p>The purpose of this pointer is to climb back up to the root of the scene graph tree. No node asserts ownership of its scene.</p>
<dl class="section return"><dt>Returns</dt><dd>a (weak) pointer to the scene graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a0897f9f799fa33ee1647f88d38efe2d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Node::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the transformed size of the node.</p>
<p>This method returns the size of the axis-aligned bounding box that contains the transformed node in its parents coordinate system. If the node is rotated, this may not be a perfect fit of the transformed contents.</p>
<dl class="section return"><dt>Returns</dt><dd>the transformed size of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c6d4dc22e16208e8d102d32c90fcc5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Node::getTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a tag that is used to identify the node easily.</p>
<p>This tag is used to quickly access a child node, since child position may change. To work properly, a tag should be unique within a scene graph. It is 0 if undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>a tag that is used to identify the node easily. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f51a00fedb2349b5a11b7c076b58c70"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the transformed width of the node.</p>
<p>This method returns the width of the axis-aligned bounding box that contains the transformed node in its parents coordinate system. If the node is rotated, this may not be a perfect fit of the transformed contents.</p>
<dl class="section return"><dt>Returns</dt><dd>the transformed width of the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a698c25ac964c12bc192ff491936642b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::getWorldPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the position of the anchor point node in OpenGL space.</p>
<p>Note that this is the position of the anchor point. This is not the same as the location of the node origin in world space.</p>
<dl class="section return"><dt>Returns</dt><dd>the position of this node in OpenGL space. </dd></dl>

</div>
</div>
<a class="anchor" id="a8af1be25ff2e7bec8339e5d0c45460d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> cugl::Node::getWorldToNodeTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix transforming node space to world space.</p>
<p>This matrix is used to convert OpenGL coordinates into node coordinates. This method is useful for converting global positions like touches or mouse clicks. It is the recursive (right-multiplied) parent-to-node transforms of all of its ancestors.</p>
<dl class="section return"><dt>Returns</dt><dd>the matrix transforming node space to world space. </dd></dl>

</div>
</div>
<a class="anchor" id="a59e4d20037fa52f7f7d4a5edf7a14c35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Node::getZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value used to 'sort' a node relative to its siblings.</p>
<p>The z-order determines the drawing order of the children. If two nodes have the same z-order, they are drawn in the order that they were added to their parent.</p>
<p>The z-order is not an actual z-value. Attempting to interpret it other wise would result in an interleaving of children, which is not what we want in a scene graph.</p>
<p>Sorting does not happen automatically (except within a <a class="el" href="classcugl_1_1_scene.html">Scene</a>). It is the responsibility of a user to sort the z-order before a call to render. Otherwise, render order will be in the unsorted order.</p>
<dl class="section return"><dt>Returns</dt><dd>the value used to 'sort' a node relative to its siblings. </dd></dl>

</div>
</div>
<a class="anchor" id="a6db73ee0cefa7cd66dc587abcae1f0de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::hasRelativeColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this node is tinted by its parent.</p>
<p>If this value is true, the base color is multiplied with the absolute color of its parent when rendering happens. Otherwise, the base color is used alone.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is tinted by its parent. </dd></dl>

</div>
</div>
<a class="anchor" id="ab63a5ce4955b74da2d3881db0f7abbbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Node::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node at the world origin.</p>
<p>The node has both position and size (0,0).</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_label.html#a16b1552ed39f1f4d60f65db9111ff4bc">cugl::Label</a>, <a class="el" href="classcugl_1_1_slider.html#a816cc415546b7bf8a780110e7249be00">cugl::Slider</a>, <a class="el" href="classcugl_1_1_button.html#afb4436096bc385e99d019791f8fd8c74">cugl::Button</a>, <a class="el" href="classcugl_1_1_textured_node.html#aac3020ed60c441d2b04ad3befbbe2490">cugl::TexturedNode</a>, <a class="el" href="classcugl_1_1_nine_patch.html#aaa5b82ee00a140334e7beefd046150ea">cugl::NinePatch</a>, and <a class="el" href="classcugl_1_1_progress_bar.html#ae67bdbb20fd03b14a2344066e25e4137">cugl::ProgressBar</a>.</p>

</div>
</div>
<a class="anchor" id="a26b757ef34080f46e4af6e589da09571"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Node::initWithBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node with the given size.</p>
<p>The size defines the content size. The bounding box of the node is (0,0,width,height). Hence the node is anchored in the center and has position (width/2,height/2) in the parent space. The node origin is the (0,0) at the bottom left corner of the bounding box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The size of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9cb7d3fb4ad4b98e3654ca2fd7d5222"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::initWithBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node with the given size.</p>
<p>The size defines the content size. The bounding box of the node is (0,0,width,height). Hence the node is anchored in the center and has position (width/2,height/2) in the parent space. The node origin is the (0,0) at the bottom left corner of the bounding box.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width of the node in parent space </td></tr>
    <tr><td class="paramname">height</td><td>The height of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3dc0c999d714c0e873ca1e3c3ce6994"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Node::initWithBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node with the given bounds.</p>
<p>The rectangle origin is the bottom left corner of the node in parent space, and corresponds to the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> space. The size defines its content width and height. The node is anchored in the center and has position origin-(width/2,height/2) in parent space.</p>
<p>Because the bounding box is explicit, this is the preferred initializer for Nodes that will explicitly contain other Nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The bounds of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ade438721f423d5eb10e721a7d7e2a9cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::initWithBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node with the given bounds.</p>
<p>The rectangle origin is the bottom left corner of the node in parent space, and corresponds to the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> space. The size defines its content width and height. The node is anchored in the center and has position origin-(width/2,height/2) in parent space.</p>
<p>Because the bounding box is explicit, this is the preferred initializer for Nodes that will explicitly contain other Nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the node origin in parent space </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the node origin in parent space </td></tr>
    <tr><td class="paramname">width</td><td>The width of the node in parent space </td></tr>
    <tr><td class="paramname">height</td><td>The height of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a0206ce198d0f6600a4d889987db2b4ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Node::initWithData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_scene_loader.html">SceneLoader</a> *&#160;</td>
          <td class="paramname"><em>loader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node with the given JSON specificaton.</p>
<p>This initializer is designed to receive the "data" object from the JSON passed to <a class="el" href="classcugl_1_1_scene_loader.html">SceneLoader</a>. This JSON format supports the following attribute values: </p><pre class="fragment"> "position": A two-element number array
 "size":     A two-element number array
 "anchor":   A two-element number array representing the anchor point
 "color":    A four-element integer array.  Values should be 0..255
 "scale":    Either a two-element number array or a single number
 "angle":    A number, representing the rotation in DEGREES, not radians
 "visible":  A boolean value, representing if the node is visible
</pre><p>All attributes are optional. There are no required attributes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>The scene loader passing this JSON file </td></tr>
    <tr><td class="paramname">data</td><td>The JSON object specifying the node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_label.html#af27c0af224f0a4c32d7a5a4379a80cf3">cugl::Label</a>, <a class="el" href="classcugl_1_1_textured_node.html#ab14681b3e8285010309cff377e2e4bb1">cugl::TexturedNode</a>, <a class="el" href="classcugl_1_1_progress_bar.html#af53df8aafc286844d95ca0d965df0a55">cugl::ProgressBar</a>, <a class="el" href="classcugl_1_1_slider.html#a0e0f1b4c5844c407370754bb66ec9231">cugl::Slider</a>, <a class="el" href="classcugl_1_1_button.html#a79977ced7da6daf4b25b6dad9c515099">cugl::Button</a>, <a class="el" href="classcugl_1_1_path_node.html#ac84e607ad938948312908ed87b2f3263">cugl::PathNode</a>, <a class="el" href="classcugl_1_1_nine_patch.html#ad8010e33679a8c26de15c246cb043810">cugl::NinePatch</a>, <a class="el" href="classcugl_1_1_wire_node.html#a2f4b5d90d59f7c3d5e4af32beae1a3c5">cugl::WireNode</a>, and <a class="el" href="classcugl_1_1_animation_node.html#a68bb7c3b6265297be5d0f4d661f19056">cugl::AnimationNode</a>.</p>

</div>
</div>
<a class="anchor" id="a0cd72bf905eea27e4ace5c1a561fa65e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Node::initWithPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node at the given position.</p>
<p>The node has size (0,0). As a result, the position is identified with the origin of the node space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The origin of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="aac8186ed75f3ab581ecc4c4fd8a04f3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::initWithPosition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a node at the given position.</p>
<p>The node has size (0,0). As a result, the position is identified with the origin of the node space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the node in parent space </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the node in parent space</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a5870f669f9e691da4de29620e42267c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::isVisible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the node is visible.</p>
<p>If a node is not visible, then it is not drawn. This means that its children are not visible as well, regardless of their visibility settings. The default value is true, making the node visible.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the node is visible. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b47e69a02eb9ebbedd045a371a6da52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::isZDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the children of this node needs resorting.</p>
<p>The children of a node may need to be resorted whenever a child is added, or whenever the z-value of a child is changed.</p>
<p>This value satisfies the following invariant: if a <a class="el" href="classcugl_1_1_node.html">Node</a> is dirty and needs resorting, then so are all of its ancestors (including any associated <a class="el" href="classcugl_1_1_scene.html">Scene</a>). Our methods guarantee this invariant, so that the method <a class="el" href="classcugl_1_1_node.html#a4b47e69a02eb9ebbedd045a371a6da52">isZDirty()</a> always returns the correct value.</p>
<p>Sorting does not happen automatically (except within a <a class="el" href="classcugl_1_1_scene.html">Scene</a>). It is the responsibility of a user to sort the z-order before a call to render. Otherwise, render order will be in the unsorted order.</p>
<dl class="section return"><dt>Returns</dt><dd>whether the children of this node needs resorting. </dd></dl>

</div>
</div>
<a class="anchor" id="a37c3d6d801f24cc6bf777d5400d1eb48"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::nodeToParentCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>nodePoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an node (local) space position to parent coordinates.</p>
<p>See <a class="el" href="classcugl_1_1_node.html#a4c0c53f4fb4e4e0c56743429a17ef8d7">getNodeToParentTransform()</a> for how this conversion takes place. That method should be used instead if there are many points to convert, as this method will recompute the transform matrix each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePoint</td><td>A local position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in parent space coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a797190aee6f29b028fe7f58455f9671e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::nodeToScreenCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>nodePoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an node (local) position to screen coordinates.</p>
<p>This method is useful for converting back to global positions like touches or mouse clicks, which are represented in screen coordinates. Screen coordinates typically have the origin in the top left.</p>
<p>The screen coordinate system is defined by the scene's camera. The method converts the node point into world space, and then uses the camera to convert into screen space.</p>
<p>This method returns the original point if there is no active scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePoint</td><td>A local position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in screen coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="ac871ce33725d9ad5c0d0253c1a46336e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::nodeToWorldCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>nodePoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an node (local) position to OpenGL coordinates.</p>
<p>See <a class="el" href="classcugl_1_1_node.html#aa3de72993fd38ebb3346a6efa3f9e969">getNodeToWorldTransform()</a> for how this conversion takes place. That method should be used instead if there are many points to convert, as this method will recompute the transform matrix each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePoint</td><td>A local position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in OpenGL coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a26ec3d9674cd640a301a32b5af343a8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Node::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from a <a class="el" href="classcugl_1_1_node.html">Node</a> to a string. </p>

</div>
</div>
<a class="anchor" id="ab6ab618f700ebed9f6a50518a6bf63bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::parentToNodeCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>parentPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an parent space position to node (local) space coordinates.</p>
<p>See <a class="el" href="classcugl_1_1_node.html#ab694bea1b8c2ebae52a26c89346c4e9b">getParentToNodeTransform()</a> for how this conversion takes place. That method should be used instead if there are many points to convert, as this method will recompute the transform matrix each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parentPoint</td><td>A parent position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in node (local) space coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e510e8d40688d6a0c488eac78403c84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::removeAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all children from this <a class="el" href="classcugl_1_1_node.html">Node</a>. </p>

</div>
</div>
<a class="anchor" id="acf52f91953f9a7df3fc563dcc4dfb190"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the child at the given position from this <a class="el" href="classcugl_1_1_node.html">Node</a>.</p>
<p>Removing a child alters the position of every child after it. Hence it is unsafe to cache child positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the child node which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a96abf42e4c58edbd75291621070f3af6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::removeChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from this <a class="el" href="classcugl_1_1_node.html">Node</a>.</p>
<p>Removing a child alters the position of every child after it. Hence it is unsafe to cache child positions.</p>
<p>If the child is not in this node, nothing happens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ffde2d492e4f2ecd080801f85f0fe9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::removeChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from the <a class="el" href="classcugl_1_1_node.html">Node</a> by name.</p>
<p>If there is more than one child of the given name, it removes the first one that is found. For the base <a class="el" href="classcugl_1_1_node.html">Node</a> class, children are always enumerated in the order that they are added. However, this is not guaranteed for subclasses of <a class="el" href="classcugl_1_1_node.html">Node</a>. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a90a92d8b8e592ffc77de774541ea40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::removeChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from the <a class="el" href="classcugl_1_1_node.html">Node</a> by tag value.</p>
<p>If there is more than one child of the given tag, it removes the first one that is found. For the base <a class="el" href="classcugl_1_1_node.html">Node</a> class, children are always enumerated in the order that they are added. However, this is not guaranteed for subclasses of <a class="el" href="classcugl_1_1_node.html">Node</a>. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a321e63fe345f3eb4a4770a506c9b90b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::removeFromParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes this node from its parent node.</p>
<p>If the node has no parent, nothing happens. </p>

</div>
</div>
<a class="anchor" id="a132956e348805bdab9f99f48e375d7e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::render </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>batch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>tint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws this <a class="el" href="classcugl_1_1_node.html">Node</a> and all of its children with the given <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>.</p>
<p>You almost never need to override this method. You should override the method draw(shared_ptr&lt;SpriteBatch&gt;,const Mat4&amp;,Color4) if you need to define custom drawing code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> to draw with. </td></tr>
    <tr><td class="paramname">transform</td><td>The global transformation matrix. </td></tr>
    <tr><td class="paramname">tint</td><td>The tint to blend with the <a class="el" href="classcugl_1_1_node.html">Node</a> color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3a3192181ce5f10d905d2fd371a8f76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::render </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws this <a class="el" href="classcugl_1_1_node.html">Node</a> and all of its children with the given <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>.</p>
<p>You almost never need to override this method. You should override the method draw(shared_ptr&lt;SpriteBatch&gt;,const Mat4&amp;,Color4) if you need to define custom drawing code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> to draw with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a234b680135b1fba02526294a730be41f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::screenToNodeCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>screenPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a screen position to node (local) space coordinates.</p>
<p>This method is useful for converting global positions like touches or mouse clicks, which are represented in screen coordinates. Screen coordinates typically have the origin in the top left.</p>
<p>The screen coordinate system is defined by the scene's camera. The method uses the camera to convert into world space, and then converts from world space into not (local) space.</p>
<p>This method returns the original point if there is no active scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenPoint</td><td>An position on the screen</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in node (local) space coordinates. </dd></dl>

</div>
</div>
<a class="anchor" id="adc03e6c26c8afc17738d48a49ffdb86f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setAlternateTransform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the alternate transform of this node.</p>
<p>Unlike the built-in scaling and rotation, this transform is applied to the coordinate space of the <a class="el" href="classcugl_1_1_node.html">Node</a> (e.g. with the origin in the bottom left corner).</p>
<p>Scaling/rotation and the alternate transform do no play nice with each other. It does not make sense to stack them on top of one another in either direction. Hence, you should only use of of the two. See the method <a class="el" href="">activateAlternateTransform(bool)</a> to choose.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>the alternate transform of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a1c34616fda2e52e782c1e4f63bdebd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::setAnchor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>anchor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the anchor point in percentages.</p>
<p>The anchor point defines the relative origin of <a class="el" href="classcugl_1_1_node.html">Node</a> with respect to its parent. It is a "pin" where the <a class="el" href="classcugl_1_1_node.html">Node</a> is attached to its parent. In effect, the translation of a <a class="el" href="classcugl_1_1_node.html">Node</a> is defined by its position plus anchor point.</p>
<p>The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. There are many anchor point constants defined in <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>. However, there is nothing preventing an anchor point higher than (1,1) or lower than (0,0).</p>
<p>The default anchorPoint is (0.5,0.5), so it starts in the center of the node. Changing the anchor will not move the contents of the node in the parent space, but it will change the value of the <a class="el" href="classcugl_1_1_node.html">Node</a> position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anchor</td><td>The anchor point of node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_textured_node.html#a3125247920f4f63c8238b59a51d1dccf">cugl::TexturedNode</a>.</p>

</div>
</div>
<a class="anchor" id="aca47d1024886ff6750af9339dbc6b183"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setAnchor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the anchor point in percentages.</p>
<p>The anchor point defines the relative origin of <a class="el" href="classcugl_1_1_node.html">Node</a> with respect to its parent. It is a "pin" where the <a class="el" href="classcugl_1_1_node.html">Node</a> is attached to its parent. In effect, the translation of a <a class="el" href="classcugl_1_1_node.html">Node</a> is defined by its position plus anchor point.</p>
<p>The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. There are many anchor point constants defined in <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>. However, there is nothing preventing an anchor point higher than (1,1) or lower than (0,0).</p>
<p>The default anchorPoint is (0.5,0.5), so it starts in the center of the node. Changing the anchor will not move the contents of the node in the parent space, but it will change the value of the <a class="el" href="classcugl_1_1_node.html">Node</a> position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The horizontal anchor percentage. </td></tr>
    <tr><td class="paramname">y</td><td>The vertical anchor percentage. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab198070e67d86747bda04c48899ab81"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setAngle </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the rotation angle of this node.</p>
<p>This value rotates the node about the anchor, with the anchor unmoved. The angle is measured in radians , counter-clockwise from the x-axis. Rotation is applied after scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>the rotation angle of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0106e6b8b7feabff4af2f046bbb904a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::setColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the color tinting this node.</p>
<p>This color will be multiplied with the parent (this node on top) if <a class="el" href="classcugl_1_1_node.html#a6db73ee0cefa7cd66dc587abcae1f0de">hasRelativeColor()</a> is true.</p>
<p>The default color is white, which means that all children have their natural color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>the color tinting this node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_button.html#afe50c115c5e5549a1e518a57c966e85e">cugl::Button</a>.</p>

</div>
</div>
<a class="anchor" id="a41ee621cec9e7fd879e1fed322799709"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setContentHeight </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the untransformed height of the node.</p>
<p>The content height remains the same no matter how the node is scaled or rotated. All nodes must have a height, though it may be degenerate (0).</p>
<p>Changing the size of a rectangle will not change the position of the node. However, if the anchor is not the bottom-left corner, it will change the origin. The <a class="el" href="classcugl_1_1_node.html">Node</a> will grow out from an anchor on an edge, and equidistant from an anchor in the center.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>The untransformed height of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a8ae817691b6077270aeb86d8e6fcd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::setContentSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the untransformed size of the node.</p>
<p>The content size remains the same no matter how the node is scaled or rotated. All nodes must have a size, though it may be degenerate (0,0).</p>
<p>Changing the size of a rectangle will not change the position of the node. However, if the anchor is not the bottom-left corner, it will change the origin. The <a class="el" href="classcugl_1_1_node.html">Node</a> will grow out from an anchor on an edge, and equidistant from an anchor in the center.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The untransformed size of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_label.html#aa77c5e380f2ee3818b6237b74f142824">cugl::Label</a>, <a class="el" href="classcugl_1_1_textured_node.html#ab92554ddc46f21f96c1be259178e7707">cugl::TexturedNode</a>, and <a class="el" href="classcugl_1_1_nine_patch.html#a645ccef3ea71c84faeddc5970bfd0947">cugl::NinePatch</a>.</p>

</div>
</div>
<a class="anchor" id="ac9edeba8eb0ab3fb668b79d26fd658fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Node::setContentSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the untransformed size of the node.</p>
<p>The content size remains the same no matter how the node is scaled or rotated. All nodes must have a size, though it may be degenerate (0,0).</p>
<p>Changing the size of a rectangle will not change the position of the node. However, if the anchor is not the bottom-left corner, it will change the origin. The <a class="el" href="classcugl_1_1_node.html">Node</a> will grow out from an anchor on an edge, and equidistant from an anchor in the center.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The untransformed width of the node. </td></tr>
    <tr><td class="paramname">height</td><td>The untransformed height of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_label.html#a6f7f83c8656b1928f2780b39828dc475">cugl::Label</a>, and <a class="el" href="classcugl_1_1_textured_node.html#a03ba2e54158eca41e2aa285bf3639ea0">cugl::TexturedNode</a>.</p>

</div>
</div>
<a class="anchor" id="ad4ee6cc103e400c70fd24eafe3de5215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setContentWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the untransformed width of the node.</p>
<p>The content width remains the same no matter how the node is scaled or rotated. All nodes must have a width, though it may be degenerate (0).</p>
<p>Changing the size of a rectangle will not change the position of the node. However, if the anchor is not the bottom-left corner, it will change the origin. The <a class="el" href="classcugl_1_1_node.html">Node</a> will grow out from an anchor on an edge, and equidistant from an anchor in the center.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The untransformed width of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b285a3176996a2343ad2b588d69ca08"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setLayout </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_layout.html">Layout</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the layout manager for this node</p>
<p>We had originally intended to completely decouple layout managers from nodes. However, nodes (including layout assignemnts) are typically built bottom-up, while layout must happen top down to correctly resize elements. Therefore, we do allow the addition of an optional layout manager.</p>
<p>Changing the layout manager does not reperform layout. You must call <a class="el" href="classcugl_1_1_node.html#ab35f84fba729c4a27b0bd1362d56d614">doLayout()</a> to do this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the</td><td>layout manager for this node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0821464428b7f9d7e8319a8dbb85ebe6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a string that is used to identify the node.</p>
<p>This name is used to access a child node, since child position may change. In addition, the name is useful for debugging. To work properly, a name should be unique within a scene graph. It is empty if undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string that is used to identify the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b39da2a3bf2902143cea48da0866b34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the position of the node in its parent's coordinate system.</p>
<p>The node position is not necessarily the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> coordinate system. The relationship between the position and <a class="el" href="classcugl_1_1_node.html">Node</a> space is determined by the anchor point. See <a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position of the node in its parent's coordinate system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af01bb76aa2bac44758084daa1bf489b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setPosition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the position of the node in its parent's coordinate system.</p>
<p>The node position is not necessarily the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> coordinate system. The relationship between the position and <a class="el" href="classcugl_1_1_node.html">Node</a> space is determined by the anchor point. See <a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the node in its parent's coordinate system. </td></tr>
    <tr><td class="paramname">y</td><td>The x-coordinate of the node in its parent's coordinate system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c5e5ccda945b8ea8e7d3261e24ce2f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setPositionX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the x-coordinate of the node in its parent's coordinate system.</p>
<p>The node position is not necessarily the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> coordinate system. The relationship between the position and <a class="el" href="classcugl_1_1_node.html">Node</a> space is determined by the anchor point. See <a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the node in its parent's coordinate system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a407286cf325d4f43164700a8336ecac7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setPositionY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the y-coordinate of the node in its parent's coordinate system.</p>
<p>The node position is not necessarily the origin of the <a class="el" href="classcugl_1_1_node.html">Node</a> coordinate system. The relationship between the position and <a class="el" href="classcugl_1_1_node.html">Node</a> space is determined by the anchor point. See <a class="el" href="classcugl_1_1_node.html#a96f7ef1bbadf6e1f4e95e3c141331df2">getAnchor()</a> for more details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>The y-coordinate of the node in its parent's coordinate system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a76d0ed3f7a12e1af12965ec248772061"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setRelativeColor </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether this node is tinted by its parent.</p>
<p>If this value is true, the base color is multiplied with the absolute color of its parent when rendering happens. Otherwise, the base color is used alone.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Whether this node is tinted by its parent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abcb777d81bcfa45e604e6a8c34aaee43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the uniform scaling factor for this node.</p>
<p>This factor scales the node about the anchor (with the anchor unmoved). Hence this is not the same as a scale applied to <a class="el" href="classcugl_1_1_node.html">Node</a> space, as the origin is in the bottom left corner. Scaling is first, before any other transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>the uniform scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a300159d09a87fd3f75d5a94937d527a9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the non-uniform scaling factor for this node.</p>
<p>This factor scales the node about the anchor (with the anchor unmoved). Hence this is not the same as a scale applied to <a class="el" href="classcugl_1_1_node.html">Node</a> space, as the origin is in the bottom left corner. Scaling is first, before any other transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>the non-uniform scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acab0a7d92a4ecfbd2c6e4ab4b42e7210"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the non-uniform scaling factor for this node.</p>
<p>This factor scales the node about the anchor (with the anchor unmoved). Hence this is not the same as a scale applied to <a class="el" href="classcugl_1_1_node.html">Node</a> space, as the origin is in the bottom left corner. Scaling is first, before any other transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>the x-axis scaling factor. </td></tr>
    <tr><td class="paramname">sy</td><td>the y-axis scaling factor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ed79f5d6706392b26987bcc2bf60517"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a tag that is used to identify the node easily.</p>
<p>This tag is used to quickly access a child node, since child position may change. To work properly, a tag should be unique within a scene graph. It is 0 if undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>A tag that is used to identify the node easily. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4675cb74bb8f3cacc338ceab22c0a24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether the node is visible.</p>
<p>If a node is not visible, then it is not drawn. This means that its children are not visible as well, regardless of their visibility settings. The default value is true, making the node visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td>true if the node is visible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a52cee256602ea7ccce5d4ee59717d2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::setZOrder </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>z</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value used to 'sort' a node relative to its siblings.</p>
<p>The z-order determines the drawing order of the children. If two nodes have the same z-order, they are drawn in the order that they were added to their parent.</p>
<p>The z-order is not an actual z-value. Attempting to interpret it other wise would result in an interleaving of children, which is not what we want in a scene graph.</p>
<p>Sorting does not happen automatically (except within a <a class="el" href="classcugl_1_1_scene.html">Scene</a>). It is the responsibility of a user to sort the z-order before a call to render. Otherwise, render order will be in the unsorted order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>The local Z order value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7f610475468b411372ea3afb544cf663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::sortZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resorts the children of this node according to z-value.</p>
<p>If two children have the same z-value, their relative order is preserved to what it was before the sort. This method should be called before rendering.</p>
<p>Resorting is done recursively down a tree for each child that is dirty and needs resorting. We guarantee that Nodes will not be resorted unless necessary, because of the following invariant: if a <a class="el" href="classcugl_1_1_node.html">Node</a> is dirty and needs resorting, then so are all of its ancestors (including any associated <a class="el" href="classcugl_1_1_scene.html">Scene</a>).</p>
<p>Sorting does not happen automatically (except within a <a class="el" href="classcugl_1_1_scene.html">Scene</a>). It is the responsibility of a user to call this method before rendering. Otherwise, render order will be in the unsorted order. </p>

</div>
</div>
<a class="anchor" id="a260cb3435cbd5e378872410f3f11da17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Node::swapChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the current child child1 with the new child child2.</p>
<p>If inherit is true, the children of child1 are assigned to child2 after the swap; this value is false by default. The purpose of this value is to allow transition nodes in the middle of the scene graph.</p>
<p>This method is undefined if child1 is not a child of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child1</td><td>The current child of this node </td></tr>
    <tr><td class="paramname">child2</td><td>The child to swap it with. </td></tr>
    <tr><td class="paramname">inherit</td><td>Whether the new child should inherit the children of child1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac16b8f546757d3687b7f7fb562e3b8ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cugl::Node::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string representation of this node for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this node for debuggging purposes. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_textured_node.html#a7d5b79267b6f2ae1ab6648457af08c6d">cugl::TexturedNode</a>, and <a class="el" href="classcugl_1_1_nine_patch.html#a44f61b631bd446265fa6bd4d7852c38b">cugl::NinePatch</a>.</p>

</div>
</div>
<a class="anchor" id="a062ae72c9418a12967b716c86c7e3dee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::withAlternateTransform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="classcugl_1_1_node.html">Node</a> is using the alternate transform.</p>
<p>Unlike the built-in scaling and rotation, the alternate transform is applied to the coordinate space of the <a class="el" href="classcugl_1_1_node.html">Node</a> (e.g. with the origin in the bottom left corner).</p>
<p>Scaling/rotation and the alternate transform do no play nice with each other. It does not make sense to stack them on top of one another in either direction. Hence, you should only use of of the two. This method returns true if the alternate transform is in use.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classcugl_1_1_node.html">Node</a> is using the alternate transform. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b851d805d533897dc856d55aa83aaf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::worldToNodeCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>worldPoint</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts an OpenGL position to node (local) space coordinates.</p>
<p>See getWorldtoNodeTransform() for how this conversion takes place. That method should be used instead if there are many points to convert, as this method will recompute the transform matrix each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldPoint</td><td>An OpenGL position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A point in node (local) space coordinates. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a5359ad4e19ca4f97786757b28ad940bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::_anchor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The anchor point of the node.</p>
<p>The anchor point is a percentage of the node bounding box. Together with the position, it species the origin of the node space. </p>

</div>
</div>
<a class="anchor" id="ad544a4dd2fce692ea97fcb5a7e1cb661"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Node::_angle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The rotation angle of this node.</p>
<p>The angle is measured in degrees and is counter-clockwise from the x-axis. The rotation is about the anchor point, not the node origin. It is applied after the scale, but before the post-transform. The node coordinate space is unchanged. </p>

</div>
</div>
<a class="anchor" id="a5286ef6807047bdf00afb2fd2d9225c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Node::_childOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (current) child offset of this node (-1 if root) </p>

</div>
</div>
<a class="anchor" id="ab386dc005d6e2cae41c729ecab44170d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1_node.html">Node</a>&gt; &gt; cugl::Node::_children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array of children nodes </p>

</div>
</div>
<a class="anchor" id="aea0be4afeb408d2d1989d788fb295b4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> cugl::Node::_combined</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cached local transform matrix.</p>
<p>This matrix specifes the transform from node space to parent space. Depending on the settings, it is either the scale and rotation or the alternate transform. </p>

</div>
</div>
<a class="anchor" id="a730765e8808fe4ece8f42e2e14bc49ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Node::_contentSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (untransformed) size of this node. </p>

</div>
</div>
<a class="anchor" id="a8a868e33be8d86c54ea3a5f5f040e323"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_scene.html">Scene</a>* cugl::Node::_graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A weaker pointer to the scene (or null if not in a scene) </p>

</div>
</div>
<a class="anchor" id="a46d32a25cde02bb61314201dc5e099d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Node::_hashOfName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A cached has value of _name.</p>
<p>This value is used to speed up look-ups by string. </p>

</div>
</div>
<a class="anchor" id="a770225163af3ea586747ed527f16bcf3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::_hasParentColor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether to blend our color with that of our parent. </p>

</div>
</div>
<a class="anchor" id="a1c4b8e4c6f503e12295784a0aa810dd8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::_isVisible</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this node is visible </p>

</div>
</div>
<a class="anchor" id="ae62bd80314b5d89f2b9eb84a5e9d5cf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_layout.html">Layout</a>&gt; cugl::Node::_layout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A layout manager for complex scene graphs </p>

</div>
</div>
<a class="anchor" id="aa70a1b6ae1c2b6f2add8b84ab7275b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Node::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A descriptive identifying tag.</p>
<p>Like tag, this value is used to quickly identify the child of a node. However, it is more descriptive, and so is useful in debugging. </p>

</div>
</div>
<a class="anchor" id="a3c5254ad8f2b5164dd7fa0f35bd798f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_node.html">Node</a>* cugl::Node::_parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A weaker pointer to the parent (or null if root) </p>

</div>
</div>
<a class="anchor" id="a52f25f2cad71d3976e877e3145621e04"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::_position</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The position of the node.</p>
<p>This position is specified in the coordinate system defined by the parent. Together with the anchor point, it species the origin of the node space. </p>

</div>
</div>
<a class="anchor" id="a62b1e76ec7fbd7229a5c6de9b2040008"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Node::_scale</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scale of this node.</p>
<p>The scale determines the transform from node space about the anchor. It is applied before any rotation. The node coordinate space is unchanged. </p>

</div>
</div>
<a class="anchor" id="a7aab8955161507cffb87cce2d9d9109b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Node::_tag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An identifying tag.</p>
<p>This value is used to quickly identify the child of a node. To work properly, a tag should be unique within a scene graph. It is 0 if undefined. </p>

</div>
</div>
<a class="anchor" id="aca58d152a4aab54815acdf4ff0222821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::Node::_tintColor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The color to tint this node. This color is white by default. </p>

</div>
</div>
<a class="anchor" id="a75f272d4763dfdc98c38da469a8be2a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> cugl::Node::_transform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The alternate transform of this node.</p>
<p>This value allows you to perform more arbitrary transformations of the node in parent space. Unlike scaling and rotation, this transform is applied to the node space directly (not with respect to the anchor). Hence this transform is applied before any other ones. </p>

</div>
</div>
<a class="anchor" id="ae682010710abd27156772fd05c62bb0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::_useTransform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or not to use the alternate transform </p>

</div>
</div>
<a class="anchor" id="a2ab3c26b8b1bffe5411323c9a33ab6c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Node::_zDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether or not the z-order is currently violated </p>

</div>
</div>
<a class="anchor" id="a522f68e7601cd49d7cd4594899075ce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Node::_zOrder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The z-order of this node </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/2d/<a class="el" href="_c_u_node_8h_source.html">CUNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

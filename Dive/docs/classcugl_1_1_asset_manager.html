<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::AssetManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcugl_1_1_asset_manager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::AssetManager Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_asset_manager_8h_source.html">CUAssetManager.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb56afd4db13559529604a018bbaf93d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#acb56afd4db13559529604a018bbaf93d">AssetManager</a> ()</td></tr>
<tr class="separator:acb56afd4db13559529604a018bbaf93d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80b939b7db4ee2179d16ae1b23f3b7c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#ab80b939b7db4ee2179d16ae1b23f3b7c">~AssetManager</a> ()</td></tr>
<tr class="separator:ab80b939b7db4ee2179d16ae1b23f3b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f56a7d7d0d2137c1144714d9d25eaf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a0f56a7d7d0d2137c1144714d9d25eaf4">dispose</a> ()</td></tr>
<tr class="separator:a0f56a7d7d0d2137c1144714d9d25eaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc459fa7b80d5516895a642314f0c9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#affc459fa7b80d5516895a642314f0c9b">init</a> ()</td></tr>
<tr class="separator:affc459fa7b80d5516895a642314f0c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdbb59fad1e6a7aca66a4a5f46a89aa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8cdbb59fad1e6a7aca66a4a5f46a89aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a8cdbb59fad1e6a7aca66a4a5f46a89aa">attach</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_base_loader.html">BaseLoader</a> &gt; &amp;loader)</td></tr>
<tr class="separator:a8cdbb59fad1e6a7aca66a4a5f46a89aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f40d4501094ffc53e09f6cc746f4c7e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f40d4501094ffc53e09f6cc746f4c7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a1f40d4501094ffc53e09f6cc746f4c7e">isAttached</a> ()</td></tr>
<tr class="separator:a1f40d4501094ffc53e09f6cc746f4c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d1986e23b2bea04e09391215b38194"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2d1986e23b2bea04e09391215b38194"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#aa2d1986e23b2bea04e09391215b38194">detach</a> ()</td></tr>
<tr class="separator:aa2d1986e23b2bea04e09391215b38194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa132fcb0c51ec963a48e60f04eed191c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#aa132fcb0c51ec963a48e60f04eed191c">detachAll</a> ()</td></tr>
<tr class="separator:aa132fcb0c51ec963a48e60f04eed191c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fde1f1fffacd0df4c69883afaecc695"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fde1f1fffacd0df4c69883afaecc695"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_loader.html">Loader</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a9fde1f1fffacd0df4c69883afaecc695">access</a> () const </td></tr>
<tr class="separator:a9fde1f1fffacd0df4c69883afaecc695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae429b9d9b8041bd5e54a17ac497d9a5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#aae429b9d9b8041bd5e54a17ac497d9a5">loadCount</a> () const </td></tr>
<tr class="separator:aae429b9d9b8041bd5e54a17ac497d9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bd3894e67600179965406aba0e130b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#af3bd3894e67600179965406aba0e130b">waitCount</a> () const </td></tr>
<tr class="separator:af3bd3894e67600179965406aba0e130b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395ace9d1f6ee999dfad6ea3ceb022ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a395ace9d1f6ee999dfad6ea3ceb022ca">complete</a> () const </td></tr>
<tr class="separator:a395ace9d1f6ee999dfad6ea3ceb022ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb676f60e4f37c489cfddee3656f1da5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#abb676f60e4f37c489cfddee3656f1da5">progress</a> () const </td></tr>
<tr class="separator:abb676f60e4f37c489cfddee3656f1da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc06eced24bc4a1adbed9dfcddaaa32"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bc06eced24bc4a1adbed9dfcddaaa32"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a0bc06eced24bc4a1adbed9dfcddaaa32">get</a> (const std::string &amp;key) const </td></tr>
<tr class="separator:a0bc06eced24bc4a1adbed9dfcddaaa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178ff7d7cc26db39cd4f43f1074478b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a178ff7d7cc26db39cd4f43f1074478b6"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a178ff7d7cc26db39cd4f43f1074478b6">get</a> (const char *key) const </td></tr>
<tr class="separator:a178ff7d7cc26db39cd4f43f1074478b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902838a29654acca271074464b101536"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a902838a29654acca271074464b101536"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a902838a29654acca271074464b101536">load</a> (const std::string &amp;key, const std::string &amp;source)</td></tr>
<tr class="separator:a902838a29654acca271074464b101536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14a3cb2bc23efcff5003f94b357f0da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab14a3cb2bc23efcff5003f94b357f0da"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#ab14a3cb2bc23efcff5003f94b357f0da">load</a> (const char *key, const std::string &amp;source)</td></tr>
<tr class="separator:ab14a3cb2bc23efcff5003f94b357f0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7cab8ea490149e84cb3ea72f81e5d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b7cab8ea490149e84cb3ea72f81e5d3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a6b7cab8ea490149e84cb3ea72f81e5d3">load</a> (const std::string &amp;key, const char *source)</td></tr>
<tr class="separator:a6b7cab8ea490149e84cb3ea72f81e5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea07dc369a31df4e3616c54d1b694db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afea07dc369a31df4e3616c54d1b694db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#afea07dc369a31df4e3616c54d1b694db">load</a> (const char *key, const char *source)</td></tr>
<tr class="separator:afea07dc369a31df4e3616c54d1b694db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bf7b535b7228dd4c09e5086a54dc71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a16bf7b535b7228dd4c09e5086a54dc71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a16bf7b535b7228dd4c09e5086a54dc71">loadAsync</a> (const std::string &amp;key, const std::string &amp;source, LoaderCallback callback)</td></tr>
<tr class="separator:a16bf7b535b7228dd4c09e5086a54dc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1c78e59c31f5bda3faa5f075bb089e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada1c78e59c31f5bda3faa5f075bb089e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#ada1c78e59c31f5bda3faa5f075bb089e">loadAsync</a> (const char *key, const std::string &amp;source, LoaderCallback callback)</td></tr>
<tr class="separator:ada1c78e59c31f5bda3faa5f075bb089e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f3381567cbb74b5d40dc4d8b6a687b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50f3381567cbb74b5d40dc4d8b6a687b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a50f3381567cbb74b5d40dc4d8b6a687b">loadAsync</a> (const std::string &amp;key, const char *source, LoaderCallback callback)</td></tr>
<tr class="separator:a50f3381567cbb74b5d40dc4d8b6a687b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10859373a48819e652972818e20ecc62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10859373a48819e652972818e20ecc62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a10859373a48819e652972818e20ecc62">loadAsync</a> (const char *key, const char *source, LoaderCallback callback)</td></tr>
<tr class="separator:a10859373a48819e652972818e20ecc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7600554071556362c5f934d1f77ab0f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7600554071556362c5f934d1f77ab0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#ad7600554071556362c5f934d1f77ab0f">unload</a> (const std::string &amp;key)</td></tr>
<tr class="separator:ad7600554071556362c5f934d1f77ab0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab1aacd22fe27a47f132f8fa7b653f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afab1aacd22fe27a47f132f8fa7b653f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#afab1aacd22fe27a47f132f8fa7b653f8">unload</a> (const char *key)</td></tr>
<tr class="separator:afab1aacd22fe27a47f132f8fa7b653f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b234bf991d5707cc2ea167aed903324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a5b234bf991d5707cc2ea167aed903324">unloadAll</a> ()</td></tr>
<tr class="separator:a5b234bf991d5707cc2ea167aed903324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8e836af7e706616e454ee0e3524a32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#aba8e836af7e706616e454ee0e3524a32">loadDirectory</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json)</td></tr>
<tr class="separator:aba8e836af7e706616e454ee0e3524a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f9e55b899721c30fb4fb22c9efeb09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a94f9e55b899721c30fb4fb22c9efeb09">loadDirectory</a> (const std::string &amp;directory)</td></tr>
<tr class="separator:a94f9e55b899721c30fb4fb22c9efeb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb396e08bb865a8c2aa393fef5904610"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#acb396e08bb865a8c2aa393fef5904610">loadDirectory</a> (const char *directory)</td></tr>
<tr class="separator:acb396e08bb865a8c2aa393fef5904610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0f4fdbe01ef66e8d0ace5a339f6556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a9a0f4fdbe01ef66e8d0ace5a339f6556">loadDirectoryAsync</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json, LoaderCallback callback)</td></tr>
<tr class="separator:a9a0f4fdbe01ef66e8d0ace5a339f6556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab612611e1570c082caa138c39884b087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#ab612611e1570c082caa138c39884b087">loadDirectoryAsync</a> (const std::string &amp;directory, LoaderCallback callback)</td></tr>
<tr class="separator:ab612611e1570c082caa138c39884b087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77987673fba9f3ac2c72c59bbd47b877"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a77987673fba9f3ac2c72c59bbd47b877">loadDirectoryAsync</a> (const char *directory, LoaderCallback callback)</td></tr>
<tr class="separator:a77987673fba9f3ac2c72c59bbd47b877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64d91ae1cd7598302dd7f474b5e66a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#aa64d91ae1cd7598302dd7f474b5e66a3">unloadDirectory</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json)</td></tr>
<tr class="separator:aa64d91ae1cd7598302dd7f474b5e66a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3d02aa993787f258d9929ae305754e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#adf3d02aa993787f258d9929ae305754e">unloadDirectory</a> (const std::string &amp;directory)</td></tr>
<tr class="separator:adf3d02aa993787f258d9929ae305754e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d921f2e2b0ea5a66b3ed3c014cd36d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#af0d921f2e2b0ea5a66b3ed3c014cd36d">unloadDirectory</a> (const char *directory)</td></tr>
<tr class="separator:af0d921f2e2b0ea5a66b3ed3c014cd36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a03e5c10f36ed79a8eede3e24535db2e1"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a03e5c10f36ed79a8eede3e24535db2e1">alloc</a> ()</td></tr>
<tr class="separator:a03e5c10f36ed79a8eede3e24535db2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab8a2dc7a0ccf3dce1a237d1db3ea1bb1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#ab8a2dc7a0ccf3dce1a237d1db3ea1bb1">readCategory</a> (size_t hash, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json)</td></tr>
<tr class="separator:ab8a2dc7a0ccf3dce1a237d1db3ea1bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b5f7eb33e043a93112889268853c6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#ae8b5f7eb33e043a93112889268853c6e">readCategory</a> (size_t hash, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json, LoaderCallback callback)</td></tr>
<tr class="separator:ae8b5f7eb33e043a93112889268853c6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa8475c05d74bfdb48d03e13c4ffd42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a6fa8475c05d74bfdb48d03e13c4ffd42">purgeCategory</a> (size_t hash, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json)</td></tr>
<tr class="separator:a6fa8475c05d74bfdb48d03e13c4ffd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534e010dc88a5b02a80a48b1d184d48f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a534e010dc88a5b02a80a48b1d184d48f">sync</a> ()</td></tr>
<tr class="separator:a534e010dc88a5b02a80a48b1d184d48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5521c503026bb3cc8ad43a7edd34e39c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a5521c503026bb3cc8ad43a7edd34e39c">block</a> ()</td></tr>
<tr class="separator:a5521c503026bb3cc8ad43a7edd34e39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd888d2e5c2721d71acc7c2795d108e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#abd888d2e5c2721d71acc7c2795d108e7">resume</a> ()</td></tr>
<tr class="separator:abd888d2e5c2721d71acc7c2795d108e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af5e44ca3647c0b538712435b6865e687"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; size_t, std::shared_ptr&lt; <a class="el" href="classcugl_1_1_base_loader.html">BaseLoader</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#af5e44ca3647c0b538712435b6865e687">_handlers</a></td></tr>
<tr class="separator:af5e44ca3647c0b538712435b6865e687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff91aa818a5b3bccf4d0d864a9d6cd1"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#afff91aa818a5b3bccf4d0d864a9d6cd1">_workers</a></td></tr>
<tr class="separator:afff91aa818a5b3bccf4d0d864a9d6cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7403bb5eca58ed464af08b3816d53fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#af7403bb5eca58ed464af08b3816d53fd">_preload</a></td></tr>
<tr class="separator:af7403bb5eca58ed464af08b3816d53fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd5801be71b152d62901bd028967d6e"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_asset_manager.html#a6dd5801be71b152d62901bd028967d6e">_wait</a></td></tr>
<tr class="separator:a6dd5801be71b152d62901bd028967d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is loader/manager for handling a wide variety of assets.</p>
<p>This asset manager is uses to manage a collection of loaders. Loaders must be "attached" to the asset manager. The asset manager does not come with a collection of loaders pre-installed. You will need to do this yourself in the start-up code for each scene. Once a loader is attached to this asset manager, the manager obtains ownership of the loader. It will be responsible for garbage collection when it is done.</p>
<p>Like loaders, an asset manager both loads an asset and allows it to be referenced at any time via a key. This allows us to easily decouple asset loading from the rest of the application. To access an asset, you just need a (weak or strong) reference to the asset loader. However, we do not make asset managers a singleton, because different player modes may want different asset managers.</p>
<p>Disposing an asset manager unloads all of the assets. However, assets may still be used after an asset manager is destroyed, provided that they still have a smart pointer referencing them.</p>
<p>IMPORTANT: This class is not even remotely thread-safe. Do not call any of these methods outside of the main CUGL thread. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acb56afd4db13559529604a018bbaf93d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::AssetManager::AssetManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a degenerate asset manager with no attached threads.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate an asset manager on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a class="anchor" id="ab80b939b7db4ee2179d16ae1b23f3b7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::AssetManager::~AssetManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this asset manager, disposing of all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9fde1f1fffacd0df4c69883afaecc695"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_loader.html">Loader</a>&lt;T&gt; &gt; cugl::AssetManager::access </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the loader for the given asset Type</p>
<p>The type of the asset is specified by the template parameter T.</p>
<dl class="section return"><dt>Returns</dt><dd>the loader for the given asset Type </dd></dl>

</div>
</div>
<a class="anchor" id="a03e5c10f36ed79a8eede3e24535db2e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>&gt; cugl::AssetManager::alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated asset manager with two auxiliary threads.</p>
<p>The asset manager will have a thread pool of size 2, giving it two threads to load assets asynchronously. These threads have no effect on synchronous loading and will sleep when no assets are being loaded.</p>
<p>This constructor does not attach any loaders. It simply creates an object that is ready to accept loader objects.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated asset manager with two auxiliary threads. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cdbb59fad1e6a7aca66a4a5f46a89aa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::attach </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_base_loader.html">BaseLoader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attaches the given loader to the asset manager</p>
<p>The type of the asset is specified by the template parameter T. Once attached, all assets of type T will use this loader for this scene. In addition, this asset manager will obtain ownership of the loader and be responsible for its garbage collection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>The loader for asset T</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if there is already a loader for this asset </dd></dl>

</div>
</div>
<a class="anchor" id="a5521c503026bb3cc8ad43a7edd34e39c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::block </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Blocks the asset manager until the next animation frame.</p>
<p>Any assets queued after a block will not be added to thread pool until at least one animation frame has passed. This method is used to implement the <a class="el" href="classcugl_1_1_asset_manager.html#a534e010dc88a5b02a80a48b1d184d48f">sync()</a> method. </p>

</div>
</div>
<a class="anchor" id="a395ace9d1f6ee999dfad6ea3ceb022ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::complete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the loader has finished loading all assets.</p>
<p>It is not safe to use asynchronously loaded assets until all loading is complete. This method allows us to determine when asset loading is complete via polling.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the loader has finished loading </dd></dl>

</div>
</div>
<a class="anchor" id="aa2d1986e23b2bea04e09391215b38194"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detaches a loader for an asset type</p>
<p>The type of the asset is specified by the template parameter T. The loader will be released and deleted if there are no further (smart pointer) references to it.</p>
<dl class="section return"><dt>Returns</dt><dd>true if there was a loader of that Type. </dd></dl>

</div>
</div>
<a class="anchor" id="aa132fcb0c51ec963a48e60f04eed191c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::detachAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Detaches all loaders from this asset manager</p>
<p>The loaders will be released and deleted if there are no further (smart pointer) references to them. </p>

</div>
</div>
<a class="anchor" id="a0f56a7d7d0d2137c1144714d9d25eaf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detaches all the attached loaders and deletes all auxiliary threads.</p>
<p>Unlike the destructor, this does not destroy the asset manager. However, you will need to reinitialize the manager (to restart the auxiliary threads) and reattach all loaders to use the asset manager again. </p>

</div>
</div>
<a class="anchor" id="a0bc06eced24bc4a1adbed9dfcddaaa32"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::AssetManager::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the asset for the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the given asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the asset for the given key. </dd></dl>

</div>
</div>
<a class="anchor" id="a178ff7d7cc26db39cd4f43f1074478b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::AssetManager::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the asset for the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the given asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the asset for the given key. </dd></dl>

</div>
</div>
<a class="anchor" id="affc459fa7b80d5516895a642314f0c9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new asset manager with two auxiliary threads.</p>
<p>The asset manager will have a thread pool of size 2, giving it two threads to load assets asynchronously. These threads have no effect on synchronous loading and will sleep when no assets are being loaded.</p>
<p>This initializer does not attach any loaders. It simply creates an object that is ready to accept loader objects.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the asset manager was initialized successfully </dd></dl>

</div>
</div>
<a class="anchor" id="a1f40d4501094ffc53e09f6cc746f4c7e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::isAttached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if there is a loader for the given asset Type</p>
<p>The type of the asset is specified by the template parameter T.</p>
<dl class="section return"><dt>Returns</dt><dd>true if there is a loader for the given asset Type </dd></dl>

</div>
</div>
<a class="anchor" id="a902838a29654acca271074464b101536"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads an asset and assigns it to the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a54100cd81819d774291111b504f86853">BaseLoader#load</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded synchronously. This means it will be available immediately. This method should be limited to those times in which an asset is really necessary immediately, such as for a loading screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a class="anchor" id="ab14a3cb2bc23efcff5003f94b357f0da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads an asset and assigns it to the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a54100cd81819d774291111b504f86853">BaseLoader#load</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded synchronously. This means it will be available immediately. This method should be limited to those times in which an asset is really necessary immediately, such as for a loading screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7cab8ea490149e84cb3ea72f81e5d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads an asset and assigns it to the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a54100cd81819d774291111b504f86853">BaseLoader#load</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded synchronously. This means it will be available immediately. This method should be limited to those times in which an asset is really necessary immediately, such as for a loading screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a class="anchor" id="afea07dc369a31df4e3616c54d1b694db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads an asset and assigns it to the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a54100cd81819d774291111b504f86853">BaseLoader#load</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded synchronously. This means it will be available immediately. This method should be limited to those times in which an asset is really necessary immediately, such as for a loading screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a class="anchor" id="a16bf7b535b7228dd4c09e5086a54dc71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new asset to the loading queue.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a02abfeaf208c29096de7f941b7e6e884">BaseLoader#loadAsync</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, it will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when the loading either completes or fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for when the asset is loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada1c78e59c31f5bda3faa5f075bb089e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new asset to the loading queue.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a02abfeaf208c29096de7f941b7e6e884">BaseLoader#loadAsync</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, it will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when the loading either completes or fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for when the asset is loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50f3381567cbb74b5d40dc4d8b6a687b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new asset to the loading queue.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a02abfeaf208c29096de7f941b7e6e884">BaseLoader#loadAsync</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, it will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when the loading either completes or fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for when the asset is loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10859373a48819e652972818e20ecc62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a new asset to the loading queue.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method essentially calls <a class="el" href="classcugl_1_1_base_loader.html#a02abfeaf208c29096de7f941b7e6e884">BaseLoader#loadAsync</a> in the appropriate loader. If there is no loader for the given type, the method will fail.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, it will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when the loading either completes or fails.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset source </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for when the asset is loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae429b9d9b8041bd5e54a17ac497d9a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::AssetManager::loadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of assets currently loaded.</p>
<p>This method is a rough way to determine how many assets have been loaded so far. This method counts each asset equally regardless of the memory requirements of each asset.</p>
<p>The value returned is the sum of the loadCount for all attached loaders.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of assets currently loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="aba8e836af7e706616e454ee0e3524a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::loadDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously loads all assets in the given directory.</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<p>This method will try to load as many assets from the directory as it can. If any asset fails to load, it will return false. However, some assets may still be loaded and safe to access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON asset directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all assets specified in the directory were successfully loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a94f9e55b899721c30fb4fb22c9efeb09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::loadDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronously loads all assets in the given directory.</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<p>This method will try to load as many assets from the directory as it can. If any asset fails to load, it will return false. However, some assets may still be loaded and safe to access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The path to the JSON asset directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all assets specified in the directory were successfully loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="acb396e08bb865a8c2aa393fef5904610"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::loadDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronously loads all assets in the given directory.</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<p>This method will try to load as many assets from the directory as it can. If any asset fails to load, it will return false. However, some assets may still be loaded and safe to access.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The path to the JSON asset directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all assets specified in the directory were successfully loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a0f4fdbe01ef66e8d0ace5a339f6556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::loadDirectoryAsync </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronously loads all assets in the given directory.</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<p>As an asynchronous load, all asset loading will take place outside of the main thread. However, assets such as fonts and textures will need the OpenGL context to complete, so part of their asset loading may take place in the main thread via the <a class="el" href="classcugl_1_1_application.html#a3b277c28091afb74571dee5723fa78d8">Application#schedule</a> interface. You may either poll this interface to determine when the assets are loaded or use optional callbacks.</p>
<p>The optional callback function will be called each time an individual asset loads or fails to load. However, if the entire category fails to load, the callback function will be given the asset category name (e.g. "soundfx") as the asset key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON asset directory </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback after each asset is loaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab612611e1570c082caa138c39884b087"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::loadDirectoryAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Asynchronously loads all assets in the given directory.</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<p>As an asynchronous load, all asset loading will take place outside of the main thread. However, assets such as fonts and textures will need the OpenGL context to complete, so part of their asset loading may take place in the main thread via the <a class="el" href="classcugl_1_1_application.html#a3b277c28091afb74571dee5723fa78d8">Application#schedule</a> interface. You may either poll this interface to determine when the assets are loaded or use optional callbacks.</p>
<p>The optional callback function will be called each time an individual asset loads or fails to load. However, if the entire category fails to load, the callback function will be given the asset category name (e.g. "soundfx") as the asset key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The path to the JSON asset directory </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback after each asset is loaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a77987673fba9f3ac2c72c59bbd47b877"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::loadDirectoryAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously loads all assets in the given directory.</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<p>As an asynchronous load, all asset loading will take place outside of the main thread. However, assets such as fonts and textures will need the OpenGL context to complete, so part of their asset loading may take place in the main thread via the <a class="el" href="classcugl_1_1_application.html#a3b277c28091afb74571dee5723fa78d8">Application#schedule</a> interface. You may either poll this interface to determine when the assets are loaded or use optional callbacks.</p>
<p>The optional callback function will be called each time an individual asset loads or fails to load. However, if the entire category fails to load, the callback function will be given the asset category name (e.g. "soundfx") as the asset key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The path to the JSON asset directory </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback after each asset is loaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb676f60e4f37c489cfddee3656f1da5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::AssetManager::progress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the loader progress as a percentage.</p>
<p>This method returns a value between 0 and 1. A value of 0 means no assets have been loaded. A value of 1 means that all assets have been loaded.</p>
<p>Anything in-between indicates that there are assets which have been loaded asynchronously and have not completed loading. It is not safe to use asynchronously loaded assets until all loading is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>the loader progress as a percentage. </dd></dl>

</div>
</div>
<a class="anchor" id="a6fa8475c05d74bfdb48d03e13c4ffd42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::purgeCategory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Immediately removes an asset category previously loaded from the JSON file</p>
<p>This method is used by the <a class="el" href="classcugl_1_1_asset_manager.html#aa64d91ae1cd7598302dd7f474b5e66a3">unloadDirectory</a> method to remove assets a category at a time. Unloading is instantaneous and occurs in the main thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash of the asset type </td></tr>
    <tr><td class="paramname">json</td><td>The child of asset directory with these assets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all assets of this type were successfully loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8a2dc7a0ccf3dce1a237d1db3ea1bb1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::readCategory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronously reads an asset category from a JSON file</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash of the asset type </td></tr>
    <tr><td class="paramname">json</td><td>The child of asset directory with these assets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all assets of this type were successfully loaded. </dd></dl>

</div>
</div>
<a class="anchor" id="ae8b5f7eb33e043a93112889268853c6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::readCategory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoaderCallback&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously reads an asset category from a JSON file</p>
<p>JSON directories provide a robust way for us to load a collection of assets. Instead of having to define parameters like asset key, font size, or texture wrap in the code, we can specify them in a JSON file. This JSON file (called the asset directory) is read by the asset manager, and directs the various loaders to load in assets.</p>
<p>Currently JSON loading supports five types of assets, with the following names: "textures", "fonts", "music", "soundfx", and "jsons". See the method <a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">BaseLoader#read</a> in each of the individual loaders for a description of the suported JSON format. A loader must still be attached for the asset manager to read that type of asset. If the asset directory contains an asset for which there is no attached asset manager, those specific assets will not be loaded.</p>
<p>As an asynchronous read, all asset loading will take place outside of the main thread. However, assets such as fonts and textures will need the OpenGL context to complete, so part of their asset loading may take place in the main thread via the <a class="el" href="classcugl_1_1_application.html#a3b277c28091afb74571dee5723fa78d8">Application#schedule</a> interface. You may either poll this interface to determine when the assets are loaded or use optional callbacks.</p>
<p>The optional callback function will be called each time an individual asset loads or fails to load. However, if the entire category fails to load, the callback function will be given the asset category name (e.g. "soundfx") as the asset key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>The hash of the asset type </td></tr>
    <tr><td class="paramname">json</td><td>The child of asset directory with these assets </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback after each asset is loaded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd888d2e5c2721d71acc7c2795d108e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resumes a previously blocked the asset manager.</p>
<p>Any assets queued after a block will not be added to thread pool until at least one animation frame has passed. This method is used to implement the <a class="el" href="classcugl_1_1_asset_manager.html#a534e010dc88a5b02a80a48b1d184d48f">sync()</a> method. </p>

</div>
</div>
<a class="anchor" id="a534e010dc88a5b02a80a48b1d184d48f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::sync </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronizes the asset manager to wait until all assets have finished.</p>
<p>This method is necessary for assets whose construction depends on previously loaded assets (e.g. scene graphs). In the current architecture, this method is only correct if the asset manager loads assets in a single thread. </p>

</div>
</div>
<a class="anchor" id="ad7600554071556362c5f934d1f77ab0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::unload </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads the asset for the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method simply unloads the asset from this asset manager. If there are active smart pointers still referencing the asset, it still may remain in memory. However, the rest of the program can no longer access the asset by key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key referencing the asset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afab1aacd22fe27a47f132f8fa7b653f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::unload </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads the asset for the given key.</p>
<p>The type of the asset is specified by the template parameter T. Because the method is parameterized by the type, it is safe to reuse keys for different types. However, this is not recommended.</p>
<p>This method simply unloads the asset from this asset manager. If there are active smart pointers still referencing the asset, it still may remain in memory. However, the rest of the program can no longer access the asset by key.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key referencing the asset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b234bf991d5707cc2ea167aed903324"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AssetManager::unloadAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads all assets present in this loader.</p>
<p>This method unloads all assets associated with this loader. If there are active smart pointers still referencing the assets, they still may remain in memory. However, the rest of the program can no longer access these assets. </p>

</div>
</div>
<a class="anchor" id="aa64d91ae1cd7598302dd7f474b5e66a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::unloadDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unloads all assets for the given directory.</p>
<p>This method unloads only those assets associated with the given directory. If there are active smart pointers still referencing the assets, they still may remain in memory. However, the rest of the program can no longer access these assets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON asset directory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf3d02aa993787f258d9929ae305754e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::unloadDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unloads all assets for the given directory.</p>
<p>This method unloads only those assets associated with the given directory. If there are active smart pointers still referencing the assets, they still may remain in memory. However, the rest of the program can no longer access these assets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The path to the JSON asset directory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0d921f2e2b0ea5a66b3ed3c014cd36d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::unloadDirectory </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>directory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads all assets for the given directory.</p>
<p>This method unloads only those assets associated with the given directory. If there are active smart pointers still referencing the assets, they still may remain in memory. However, the rest of the program can no longer access these assets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">directory</td><td>The path to the JSON asset directory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af3bd3894e67600179965406aba0e130b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::AssetManager::waitCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of assets waiting to load.</p>
<p>This is a rough way to determine how many assets are still pending. An asset is pending if it has been loaded asychronously, and the loading process has not yet finished. This method counts each asset equally regardless of the memory requirements of each asset.</p>
<p>The value returned is the sum of the waitCount for all attached loaders.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of assets waiting to load. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="af5e44ca3647c0b538712435b6865e687"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;size_t,std::shared_ptr&lt;<a class="el" href="classcugl_1_1_base_loader.html">BaseLoader</a>&gt; &gt; cugl::AssetManager::_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The individual loaders for each type </p>

</div>
</div>
<a class="anchor" id="af7403bb5eca58ed464af08b3816d53fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AssetManager::_preload</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>State variable to manage reading JSON directories </p>

</div>
</div>
<a class="anchor" id="a6dd5801be71b152d62901bd028967d6e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; cugl::AssetManager::_wait</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wait variable to create a load barrier for directories. </p>

</div>
</div>
<a class="anchor" id="afff91aa818a5b3bccf4d0d864a9d6cd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a>&gt; cugl::AssetManager::_workers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The central thread for managing all of the loaders </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/assets/<a class="el" href="_c_u_asset_manager_8h_source.html">CUAssetManager.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

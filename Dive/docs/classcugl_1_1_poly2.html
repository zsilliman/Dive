<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::Poly2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcugl_1_1_poly2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Poly2 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_poly2_8h_source.html">CUPoly2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afb9c4b680316081c12ee189d7924e58b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58b">Type</a> { <a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58ba0db45d2a4141101bdfe48e3314cfbca3">Type::UNDEFINED</a>, 
<a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58bad0dea69649a83749aa6bdf176092e8c9">Type::SOLID</a>, 
<a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58ba5ffb5f0d0de78321df46fc7c93ca64a3">Type::PATH</a>
 }<tr class="separator:afb9c4b680316081c12ee189d7924e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad36500275b41ae48913824f24cb59428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ad36500275b41ae48913824f24cb59428">Poly2</a> ()</td></tr>
<tr class="separator:ad36500275b41ae48913824f24cb59428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb274b29f3beb7d0999deeb5190b8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a63eb274b29f3beb7d0999deeb5190b8a">Poly2</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;vertices)</td></tr>
<tr class="separator:a63eb274b29f3beb7d0999deeb5190b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06391d85e35d124a30eb3cb9df65017a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a06391d85e35d124a30eb3cb9df65017a">Poly2</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices)</td></tr>
<tr class="separator:a06391d85e35d124a30eb3cb9df65017a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd60a8920a146c79a83dc748b47c759e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#afd60a8920a146c79a83dc748b47c759e">Poly2</a> (const std::vector&lt; float &gt; &amp;vertices)</td></tr>
<tr class="separator:afd60a8920a146c79a83dc748b47c759e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f36810e705ca7b62303862eee0974b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a80f36810e705ca7b62303862eee0974b">Poly2</a> (const std::vector&lt; float &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices)</td></tr>
<tr class="separator:a80f36810e705ca7b62303862eee0974b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e707a670cbfbad9fc9c1704192e344"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a34e707a670cbfbad9fc9c1704192e344">Poly2</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *vertices, int vertsize, int voffset=0)</td></tr>
<tr class="separator:a34e707a670cbfbad9fc9c1704192e344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b4bfc4f24ba6742d629ef31f776448"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ae3b4bfc4f24ba6742d629ef31f776448">Poly2</a> (float *vertices, int vertsize, int voffset=0)</td></tr>
<tr class="separator:ae3b4bfc4f24ba6742d629ef31f776448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6450ffb767c19da595744b540133ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a8d6450ffb767c19da595744b540133ec">Poly2</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *vertices, int vertsize, unsigned short *indices, int indxsize, int voffset=0, int ioffset=0)</td></tr>
<tr class="separator:a8d6450ffb767c19da595744b540133ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97df2a939da3168588aa720ef1a17a74"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a97df2a939da3168588aa720ef1a17a74">Poly2</a> (float *vertices, int vertsize, unsigned short *indices, int indxsize, int voffset=0, int ioffset=0)</td></tr>
<tr class="separator:a97df2a939da3168588aa720ef1a17a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21093987251fe8a1ecf4b880a7b320a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a21093987251fe8a1ecf4b880a7b320a8">Poly2</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a21093987251fe8a1ecf4b880a7b320a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6a814620aab3d2de59582a307bca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a02c6a814620aab3d2de59582a307bca8">Poly2</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;poly)</td></tr>
<tr class="separator:a02c6a814620aab3d2de59582a307bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7032492194adb847e017fc8438ca073a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a7032492194adb847e017fc8438ca073a">Poly2</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, bool solid=true)</td></tr>
<tr class="separator:a7032492194adb847e017fc8438ca073a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9fd41a7666abf2ca1bd337ecf5054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a98c9fd41a7666abf2ca1bd337ecf5054">~Poly2</a> ()</td></tr>
<tr class="separator:a98c9fd41a7666abf2ca1bd337ecf5054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e51d73ea036f2efa9123d3952916ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aa1e51d73ea036f2efa9123d3952916ee">operator=</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;other)</td></tr>
<tr class="separator:aa1e51d73ea036f2efa9123d3952916ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d097e4cd083f54a55d2d07a7c63a5a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a4d097e4cd083f54a55d2d07a7c63a5a1">operator=</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;other)</td></tr>
<tr class="separator:a4d097e4cd083f54a55d2d07a7c63a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890335eb6b20a1084645e2027167bf50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a890335eb6b20a1084645e2027167bf50">operator=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a890335eb6b20a1084645e2027167bf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33366d9d9a73620d93591dfdd78f177d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;vertices)</td></tr>
<tr class="separator:a33366d9d9a73620d93591dfdd78f177d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0480801f958d45fcb378fac23d6c40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a3a0480801f958d45fcb378fac23d6c40">set</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices)</td></tr>
<tr class="separator:a3a0480801f958d45fcb378fac23d6c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca03a89eba69a6f74989a19fe2ca7b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aca03a89eba69a6f74989a19fe2ca7b4d">set</a> (const std::vector&lt; float &gt; &amp;vertices)</td></tr>
<tr class="separator:aca03a89eba69a6f74989a19fe2ca7b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c1be0aea329ce663f02d0065ce5841"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ae8c1be0aea329ce663f02d0065ce5841">set</a> (const std::vector&lt; float &gt; &amp;vertices, const std::vector&lt; unsigned short &gt; &amp;indices)</td></tr>
<tr class="separator:ae8c1be0aea329ce663f02d0065ce5841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4805abe53f4fdb76c046c176fd8e6f2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a4805abe53f4fdb76c046c176fd8e6f2e">set</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *vertices, int vertsize, int voffset=0)</td></tr>
<tr class="separator:a4805abe53f4fdb76c046c176fd8e6f2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd63ea82a14f2a73931885aa75d2eb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#acfd63ea82a14f2a73931885aa75d2eb6">set</a> (float *vertices, int vertsize, int voffset=0)</td></tr>
<tr class="separator:acfd63ea82a14f2a73931885aa75d2eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac38edc6b65a320d83b6266bc0a8c58d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ac38edc6b65a320d83b6266bc0a8c58d0">set</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *vertices, int vertsize, unsigned short *indices, int indxsize, int voffset=0, int ioffset=0)</td></tr>
<tr class="separator:ac38edc6b65a320d83b6266bc0a8c58d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f93de785b610670c64c3640617dfe9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a31f93de785b610670c64c3640617dfe9">set</a> (float *vertices, int vertsize, unsigned short *indices, int indxsize, int voffset=0, int ioffset=0)</td></tr>
<tr class="separator:a31f93de785b610670c64c3640617dfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28397786382add4ef7f89e0ed85c4a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a28397786382add4ef7f89e0ed85c4a4f">set</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a28397786382add4ef7f89e0ed85c4a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd52a2ddf2eb203be67661335add755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a1cd52a2ddf2eb203be67661335add755">set</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, bool solid=true)</td></tr>
<tr class="separator:a1cd52a2ddf2eb203be67661335add755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6958e6551dfbc82a1f70ee67887f0258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a6958e6551dfbc82a1f70ee67887f0258">clear</a> ()</td></tr>
<tr class="separator:a6958e6551dfbc82a1f70ee67887f0258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0598d572bf9beb51f0a17e768b739d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5e0598d572bf9beb51f0a17e768b739d">setIndices</a> (const std::vector&lt; unsigned short &gt; &amp;indices)</td></tr>
<tr class="separator:a5e0598d572bf9beb51f0a17e768b739d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea2a26691e66f18e51f8b81425f9576"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a8ea2a26691e66f18e51f8b81425f9576">setIndices</a> (unsigned short *indices, int indxsize, int ioffset=0)</td></tr>
<tr class="separator:a8ea2a26691e66f18e51f8b81425f9576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3e5d08c0cecdfa24c190d9c856f7f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a6e3e5d08c0cecdfa24c190d9c856f7f6">isStandardized</a> ()</td></tr>
<tr class="separator:a6e3e5d08c0cecdfa24c190d9c856f7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a7b607f80ae7f8ef42048feec688d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a50a7b607f80ae7f8ef42048feec688d3">isValid</a> ()</td></tr>
<tr class="separator:a50a7b607f80ae7f8ef42048feec688d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f230e31f94b97e1182005ffe58b8e67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5f230e31f94b97e1182005ffe58b8e67">size</a> () const </td></tr>
<tr class="separator:a5f230e31f94b97e1182005ffe58b8e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97aca3085821cffadf4bddc792c7b6f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aa97aca3085821cffadf4bddc792c7b6f">indexSize</a> () const </td></tr>
<tr class="separator:aa97aca3085821cffadf4bddc792c7b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62777945434b34ba0b5be4133639d208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a62777945434b34ba0b5be4133639d208">at</a> (int index)</td></tr>
<tr class="separator:a62777945434b34ba0b5be4133639d208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9357998e39862b69ff0d11368b7a5121"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a9357998e39862b69ff0d11368b7a5121">getVertices</a> () const </td></tr>
<tr class="separator:a9357998e39862b69ff0d11368b7a5121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9103431dbaa82699e919448f1644b359"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned short &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a9103431dbaa82699e919448f1644b359">getIndices</a> () const </td></tr>
<tr class="separator:a9103431dbaa82699e919448f1644b359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72266712589d82f0b6a2b49c2a4e68f6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned short &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a72266712589d82f0b6a2b49c2a4e68f6">getIndices</a> ()</td></tr>
<tr class="separator:a72266712589d82f0b6a2b49c2a4e68f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50bf5ec96a7cb4777ad066cd230650d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a50bf5ec96a7cb4777ad066cd230650d5">getBounds</a> () const </td></tr>
<tr class="separator:a50bf5ec96a7cb4777ad066cd230650d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa25523fb7e0c93ce796fe18608f0878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58b">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aaa25523fb7e0c93ce796fe18608f0878">getType</a> () const </td></tr>
<tr class="separator:aaa25523fb7e0c93ce796fe18608f0878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7249d39f2ed3943e21e83580af2af502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a7249d39f2ed3943e21e83580af2af502">setType</a> (<a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58b">Type</a> type)</td></tr>
<tr class="separator:a7249d39f2ed3943e21e83580af2af502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd955e9a4490209fb083c9b97f4c331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aadd955e9a4490209fb083c9b97f4c331">operator*=</a> (float scale)</td></tr>
<tr class="separator:aadd955e9a4490209fb083c9b97f4c331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae34fd1a8bd543bac4b4ea4668d7d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#afae34fd1a8bd543bac4b4ea4668d7d8c">operator*=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale)</td></tr>
<tr class="separator:afae34fd1a8bd543bac4b4ea4668d7d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4bc214a1acbfb72d922cd6965f7e9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#acc4bc214a1acbfb72d922cd6965f7e9b">operator*=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:acc4bc214a1acbfb72d922cd6965f7e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccc10956ac546f4fee38e0999bc995c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aeccc10956ac546f4fee38e0999bc995c">operator*=</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:aeccc10956ac546f4fee38e0999bc995c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355a0700d44a713bd0ad8c46c14d042d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a355a0700d44a713bd0ad8c46c14d042d">operator/=</a> (float scale)</td></tr>
<tr class="separator:a355a0700d44a713bd0ad8c46c14d042d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d49437ae995277f282099b417f09c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a10d49437ae995277f282099b417f09c0">operator/=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale)</td></tr>
<tr class="separator:a10d49437ae995277f282099b417f09c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac040b2285273f3084bae4ccfe5de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a96ac040b2285273f3084bae4ccfe5de0">operator+=</a> (float offset)</td></tr>
<tr class="separator:a96ac040b2285273f3084bae4ccfe5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616325b1dab7f3154342879f616a21a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a616325b1dab7f3154342879f616a21a3">operator+=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a616325b1dab7f3154342879f616a21a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311dfe1493e17b55a8a6053639acb7b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a311dfe1493e17b55a8a6053639acb7b8">operator-=</a> (float offset)</td></tr>
<tr class="separator:a311dfe1493e17b55a8a6053639acb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5b2840cf68ef766ded36eeb7063e7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5c5b2840cf68ef766ded36eeb7063e7f">operator-=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a5c5b2840cf68ef766ded36eeb7063e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53320bbfd1ce8925633c67915f10c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ad53320bbfd1ce8925633c67915f10c11">operator*</a> (float scale) const </td></tr>
<tr class="separator:ad53320bbfd1ce8925633c67915f10c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415db5955f7aef89ead8ca78b95f7b97"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a415db5955f7aef89ead8ca78b95f7b97">operator*</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale) const </td></tr>
<tr class="separator:a415db5955f7aef89ead8ca78b95f7b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111deb52b32c543469d5c95d2a1f94b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a111deb52b32c543469d5c95d2a1f94b5">operator*=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform) const </td></tr>
<tr class="separator:a111deb52b32c543469d5c95d2a1f94b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033bb7266739b2b92dad5f1d2ac2388c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a033bb7266739b2b92dad5f1d2ac2388c">operator*</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform) const </td></tr>
<tr class="separator:a033bb7266739b2b92dad5f1d2ac2388c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f339a79f8bef5bde99c319083d2021a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a7f339a79f8bef5bde99c319083d2021a">operator/</a> (float scale) const </td></tr>
<tr class="separator:a7f339a79f8bef5bde99c319083d2021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18deca15960c885255d7f5fe12557b3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a18deca15960c885255d7f5fe12557b3d">operator/</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale) const </td></tr>
<tr class="separator:a18deca15960c885255d7f5fe12557b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154a9e8188f5c095a677bea7a675a9ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a154a9e8188f5c095a677bea7a675a9ea">operator+</a> (float offset) const </td></tr>
<tr class="separator:a154a9e8188f5c095a677bea7a675a9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd1dc4915cc93b62250eb42ba11e5e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a4cd1dc4915cc93b62250eb42ba11e5e0">operator+</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset) const </td></tr>
<tr class="separator:a4cd1dc4915cc93b62250eb42ba11e5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f415df334678257b7fb42e3c05130c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a92f415df334678257b7fb42e3c05130c">operator-</a> (float offset)</td></tr>
<tr class="separator:a92f415df334678257b7fb42e3c05130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40621c7918c24b1c9feaaa997a4a54a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a40621c7918c24b1c9feaaa997a4a54a8">operator-</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;offset)</td></tr>
<tr class="separator:a40621c7918c24b1c9feaaa997a4a54a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5461e684322b056bf1b11bf73d1aae7d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5461e684322b056bf1b11bf73d1aae7d">convexHull</a> () const </td></tr>
<tr class="separator:a5461e684322b056bf1b11bf73d1aae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf81f0f797a093ed2ee11b3cfeda8cca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#adf81f0f797a093ed2ee11b3cfeda8cca">contains</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point) const </td></tr>
<tr class="separator:adf81f0f797a093ed2ee11b3cfeda8cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5624673421dfcb3d333ff7a2b98765b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5624673421dfcb3d333ff7a2b98765b1">incident</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, float variance=CU_MATH_EPSILON) const </td></tr>
<tr class="separator:a5624673421dfcb3d333ff7a2b98765b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9023c12b1e5bfc2bbd60c3cfcb0fd022"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a9023c12b1e5bfc2bbd60c3cfcb0fd022">createLine</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;dest)</td></tr>
<tr class="separator:a9023c12b1e5bfc2bbd60c3cfcb0fd022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceecf7243411a3be16e31990222c9c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a2ceecf7243411a3be16e31990222c9c6">createLine</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;dest, <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *dst)</td></tr>
<tr class="separator:a2ceecf7243411a3be16e31990222c9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e66c55cb05a75056e07f9b693f78f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a86e66c55cb05a75056e07f9b693f78f9">createTriangle</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;a, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;b, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;c, bool solid=true)</td></tr>
<tr class="separator:a86e66c55cb05a75056e07f9b693f78f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e7281304b3d46c297212d3fdd60a83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a02e7281304b3d46c297212d3fdd60a83">createTriangle</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;a, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;b, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;c, <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *dst, bool solid=true)</td></tr>
<tr class="separator:a02e7281304b3d46c297212d3fdd60a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420d106f9125756b312abaa78e15140"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ac420d106f9125756b312abaa78e15140">createEllipse</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;center, const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;<a class="el" href="classcugl_1_1_poly2.html#a5f230e31f94b97e1182005ffe58b8e67">size</a>, unsigned int segments, bool solid=true)</td></tr>
<tr class="separator:ac420d106f9125756b312abaa78e15140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ed5e7ff8b00676770b002f735a3360"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ab8ed5e7ff8b00676770b002f735a3360">createEllipse</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;center, const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;<a class="el" href="classcugl_1_1_poly2.html#a5f230e31f94b97e1182005ffe58b8e67">size</a>, unsigned int segments, <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *dst, bool solid=true)</td></tr>
<tr class="separator:ab8ed5e7ff8b00676770b002f735a3360"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a95f7d4c3ba0a567a3f24818e00230bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95f7d4c3ba0a567a3f24818e00230bce"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CubicSplineApproximator</b></td></tr>
<tr class="separator:a95f7d4c3ba0a567a3f24818e00230bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c05fc3ec7fc37ee87f0811d29c641d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0c05fc3ec7fc37ee87f0811d29c641d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleTriangulator</b></td></tr>
<tr class="separator:aa0c05fc3ec7fc37ee87f0811d29c641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbfd4a1cf0486f90f10c75f16b31d50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbbfd4a1cf0486f90f10c75f16b31d50"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DelaunayTriangulator</b></td></tr>
<tr class="separator:abbbfd4a1cf0486f90f10c75f16b31d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab91533a672665634de9ee32f50bb02"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ab91533a672665634de9ee32f50bb02"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PathOutliner</b></td></tr>
<tr class="separator:a0ab91533a672665634de9ee32f50bb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d1086b5dcb5abd906b47bab26ba05b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a50d1086b5dcb5abd906b47bab26ba05b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PathExtruder</b></td></tr>
<tr class="separator:a50d1086b5dcb5abd906b47bab26ba05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef5e90dbed6e69b06346ceeddb4b0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#af8ef5e90dbed6e69b06346ceeddb4b0a">operator*</a> (float scale, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:af8ef5e90dbed6e69b06346ceeddb4b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40e0be6c0458b8479c68e9455f75396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ae40e0be6c0458b8479c68e9455f75396">operator*</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;scale, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:ae40e0be6c0458b8479c68e9455f75396"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to represent a simple polygon.</p>
<p>This class is intended to represent any polygon (including non-convex polygons) that does not have holes or self-interections. This class performs no verification. It will not check for holes or self-intersections; those are the responsibility of the programmer.</p>
<p>When instantiating this class, the user should provide a set of indices which will be used in rendering. These indices can either represent a triangulation of the polygon, or they can represent a traversal (for a wireframe). Provided that these indices are in "normal" form, it can provide support a for basic geometry queries, such as wether a point is inside the polygon.</p>
<p>There are two normal forms, depending on the value of the type attribute. If the polygon is SOLID, then the indices are a set of triangles. That is, there are three times as many indices as triangles, and a point is in the polygon if it is contained in any one of the triangles. Solid polygons do not support triangle fans or strips.</p>
<p>If the polygon is a PATH, then the indices are a set of lines. That is, there are two times as many indices as triangles, and a point is in the polygon if it is incident on any of the lines. Non-solid (or path) polygons do not support line strips.</p>
<p>Generating indices for a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> can be nontrivial. While this class has standard constructors, allowing the programmer full control, most <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> objects are created through alternate means. For simple shapes, like lines, triangles, and ellipses, this class has several static constructors.</p>
<p>For more complex shapes, we have several <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> factories. These factories allow for delegating index computation to a separate thread, if it takes too long. These factories are as follows:</p>
<p><a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a>: This is a simple earclipping-triangulator for tesselating simple, solid polygons (e.g. no holes or self-intersections).</p>
<p><a class="el" href="">ComplexTriangulator</a>: This is a wrapper for the advanced Poly2Tri triangulator. This triangulator can tesselate complex solid polygons (e.g. those with holes or self-intersections).</p>
<p><a class="el" href="classcugl_1_1_path_outliner.html">PathOutliner</a>: This is a tool is used to generate indices for a path polygon. It has several options, that allow it to make useful wireframes for debugging.</p>
<p><a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a>: This is a tool is used to generate a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object from a Cubic Bezier curve.</p>
<p><a class="el" href="classcugl_1_1_path_extruder.html">PathExtruder</a>: This is a tool can take a path polygon and convert it into a solid polygon. This solid polygon is the same as the path, except that the path now has a width and a mitre at the joints. This tool is different from the other tools in that it generates new vertices in addition to the indices.</p>
<p><a class="el" href="">PolygonClipper</a>: This is a wrapper for the Clipper package, which provides 2d constructive area geometry support. It allows you to compute the intersection or union of multiple solid polygons. Like <a class="el" href="classcugl_1_1_path_extruder.html">PathExtruder</a>, it also generates new vertices in addition to the indices. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="afb9c4b680316081c12ee189d7924e58b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58b">cugl::Poly2::Type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This enum is used to determine the normal form for the indices. Any rendering classes should use this type as a hint for how to render the polygon. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="afb9c4b680316081c12ee189d7924e58ba0db45d2a4141101bdfe48e3314cfbca3"></a>UNDEFINED&#160;</td><td class="fielddoc">
<p>This polygon either has no indices, or they are not in a normal form. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afb9c4b680316081c12ee189d7924e58bad0dea69649a83749aa6bdf176092e8c9"></a>SOLID&#160;</td><td class="fielddoc">
<p>This polygon represents a solid shape. The indices are a sequence of triangles. That is, the number of indices is divisible by three, with each triplet forming a triangle. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="afb9c4b680316081c12ee189d7924e58ba5ffb5f0d0de78321df46fc7c93ca64a3"></a>PATH&#160;</td><td class="fielddoc">
<p>This polygon represents a path outline. The indices are a sequence of line segments. That is, the number of indices is divisible by two, with each pair forming a segment. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad36500275b41ae48913824f24cb59428"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an empty polygon.</p>
<p>The created polygon has no vertices and no triangulation. The bounding box is trivial. </p>

</div>
</div>
<a class="anchor" id="a63eb274b29f3beb7d0999deeb5190b8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices</p>
<p>The new polygon has no indices and the type is UNDEFINED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a06391d85e35d124a30eb3cb9df65017a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This constructor will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afd60a8920a146c79a83dc748b47c759e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices</p>
<p>The new polygon has no indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>The new polygon has no indices and the type is UNDEFINED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80f36810e705ca7b62303862eee0974b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices and indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This constructor will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a34e707a670cbfbad9fc9c1704192e344"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices</p>
<p>The new polygon has no indices and the type is UNDEFINED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3b4bfc4f24ba6742d629ef31f776448"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>The new polygon has no indices and the type is UNDEFINED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d6450ffb767c19da595744b540133ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This constructor will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon </td></tr>
    <tr><td class="paramname">ioffset</td><td>The offset in indices to start from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97df2a939da3168588aa720ef1a17a74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices and indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This constructor will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon </td></tr>
    <tr><td class="paramname">ioffset</td><td>The offset in indices to start from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a21093987251fe8a1ecf4b880a7b320a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of the given polygon.</p>
<p>Both the vertices and the indices are copied. No references to the original polygon are kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02c6a814620aab3d2de59582a307bca8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy with the resource of the given polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to take from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7032492194adb847e017fc8438ca073a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon for the given rectangle.</p>
<p>The polygon will have four vertices, one for each corner of the rectangle. This optional argument (which is true by default) will initialize the indices with a triangulation of the rectangle. In other words, the type will be SOLID. This is faster than using one of the more heavy-weight triangulators.</p>
<p>If solid is false, it will still generate indices, but will be a PATH instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy </td></tr>
    <tr><td class="paramname">solid</td><td>Whether to treat this rectangle as a solid polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98c9fd41a7666abf2ca1bd337ecf5054"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::~Poly2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the given polygon, freeing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a62777945434b34ba0b5be4133639d208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&amp; cugl::Poly2::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the attribute at the given index.</p>
<p>This accessor will allow you to change the (singular) vertex. It is intended to allow minor distortions to the polygon without changing the underlying mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The attribute index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the attribute at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a6958e6551dfbc82a1f70ee67887f0258"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the contents of this polygon and sets the type to UNDEFINED</p>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="adf81f0f797a093ed2ee11b3cfeda8cca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this polygon contains the given point.</p>
<p>This method returns false is the polygon is not SOLID. If it is solid, it checks for containment within the associated triangles. It includes points on the polygon border.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this polygon contains the given point. </dd></dl>

</div>
</div>
<a class="anchor" id="a5461e684322b056bf1b11bf73d1aae7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt; cugl::Poly2::convexHull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of points forming the convex hull of this polygon.</p>
<p>The returned set of points is guaranteed to be a counter-clockwise traversal of the hull.</p>
<p>The points on the convex hull define the "border" of the shape. In addition to minimizing the number of vertices, this is useful for determining whether or not a point lies on the boundary.</p>
<p>This implementation is adapted from the example at</p>
<p><a href="http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/">http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/</a></p>
<dl class="section return"><dt>Returns</dt><dd>the set of points forming the convex hull of this polygon. </dd></dl>

</div>
</div>
<a class="anchor" id="ac420d106f9125756b312abaa78e15140"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::createEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon that represents an ellipse of the given dimensions.</p>
<p>The indices will be generated automatically. If the value solid is true, then the type will be SOLID. Otherwise, the type will be PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The ellipse center point. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the ellipse. </td></tr>
    <tr><td class="paramname">segments</td><td>The number of segments to use. </td></tr>
    <tr><td class="paramname">solid</td><td>If true, treat this ellipse as a SOLID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new polygon representing an ellipse. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8ed5e7ff8b00676770b002f735a3360"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::Poly2::createEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon that represents an ellipse of the given dimensions.</p>
<p>The indices will be generated automatically. If the value solid is true, then the type will be SOLID. Otherwise, the type will be PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The ellipse center point. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the ellipse. </td></tr>
    <tr><td class="paramname">segments</td><td>The number of segments to use. </td></tr>
    <tr><td class="paramname">dst</td><td>A polygon to store the result in. </td></tr>
    <tr><td class="paramname">solid</td><td>If true, treat this ellipse as a SOLID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a9023c12b1e5bfc2bbd60c3cfcb0fd022"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::createLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon that represents a line segment from origin to dest.</p>
<p>The polygon will have indices and the type will be PATH</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The line origin. </td></tr>
    <tr><td class="paramname">dest</td><td>The line destination.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new polygon representing a line segment. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ceecf7243411a3be16e31990222c9c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::Poly2::createLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon that represents a line segment from origin to dest.</p>
<p>This alternate constructor does not allocate the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object. Instead, it sets the contents of <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> pointer.</p>
<p>The polygon will have indices and the type will be PATH</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The line origin. </td></tr>
    <tr><td class="paramname">dest</td><td>The line destination. </td></tr>
    <tr><td class="paramname">dst</td><td>A polygon to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a86e66c55cb05a75056e07f9b693f78f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::createTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon that represents a simple triangle.</p>
<p>The indices will be generated automatically. If the value solid is true, then the type will be SOLID. Otherwise, the type will be PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first vertex. </td></tr>
    <tr><td class="paramname">b</td><td>The second vertex. </td></tr>
    <tr><td class="paramname">c</td><td>The third vertex. </td></tr>
    <tr><td class="paramname">solid</td><td>If true, treat this triangle as a SOLID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new polygon representing a triangle. </dd></dl>

</div>
</div>
<a class="anchor" id="a02e7281304b3d46c297212d3fdd60a83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::Poly2::createTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon that represents a simple triangle.</p>
<p>This alternate constructor does not allocate the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object. Instead, it sets the contents of <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> pointer.</p>
<p>The indices will be generated automatically. If the value solid is true, then the type will be SOLID. Otherwise, the type will be PATH.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first vertex. </td></tr>
    <tr><td class="paramname">b</td><td>The second vertex. </td></tr>
    <tr><td class="paramname">c</td><td>The third vertex. </td></tr>
    <tr><td class="paramname">dst</td><td>A polygon to store the result in. </td></tr>
    <tr><td class="paramname">solid</td><td>If true, treat this triangle as a SOLID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a50bf5ec96a7cb4777ad066cd230650d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Poly2::getBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounding box for the polygon</p>
<p>The bounding box is the minimal rectangle that contains all of the vertices in this polygon. It is recomputed whenever the vertices are set.</p>
<dl class="section return"><dt>Returns</dt><dd>the bounding box for the polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a9103431dbaa82699e919448f1644b359"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;unsigned short&gt;&amp; cugl::Poly2::getIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to list of indices.</p>
<p>This accessor will not permit any changes to the index array. To change the array, you must change the polygon via a <a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vertex array </dd></dl>

</div>
</div>
<a class="anchor" id="a72266712589d82f0b6a2b49c2a4e68f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned short&gt;&amp; cugl::Poly2::getIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to list of indices.</p>
<p>This accessor will not permit any changes to the index array. To change the array, you must change the polygon via a <a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set()</a> method.</p>
<p>This non-const version of the method is used by triangulators.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vertex array </dd></dl>

</div>
</div>
<a class="anchor" id="aaa25523fb7e0c93ce796fe18608f0878"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58b">Type</a> cugl::Poly2::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of this polygon.</p>
<p>The type determines the proper form of the indices.</p>
<p>If the polygon is SOLID, there should be three times as many indices as vertices. Each triplet should define a triangle over the vertices.</p>
<p>If the polygon is PATH, there should be two times as many indices as vertices. Each pair should define a line segment over the vertices.</p>
<p>If the polygon is UNDEFINED, the index list should be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>the type of this polygon. </dd></dl>

</div>
</div>
<a class="anchor" id="a9357998e39862b69ff0d11368b7a5121"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt;&amp; cugl::Poly2::getVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of vertices</p>
<p>This accessor will not permit any changes to the vertex array. To change the array, you must change the polygon via a <a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vertex array </dd></dl>

</div>
</div>
<a class="anchor" id="a5624673421dfcb3d333ff7a2b98765b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::incident </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>CU_MATH_EPSILON</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given point is on the boundary of this polygon.</p>
<p>This method returns false is the polygon is not SOLID or PATH. If it is a path, it checks that the point is within variance of the a line segment on the path.</p>
<p>If it is solid, it checks that the point is within variance of the convex hull. The convex hull is not a fast computation, so this method should be used with care.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to test </td></tr>
    <tr><td class="paramname">variance</td><td>The distance tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given point is on the boundary of this polygon. </dd></dl>

</div>
</div>
<a class="anchor" id="aa97aca3085821cffadf4bddc792c7b6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Poly2::indexSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of indices in a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of indices in a polygon. </dd></dl>

</div>
</div>
<a class="anchor" id="a6e3e5d08c0cecdfa24c190d9c856f7f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::isStandardized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the indices are in the proper normal form.</p>
<p>If the polygon is SOLID, this method will return true if the number of indices is divisible by three.</p>
<p>If the polygon is PATH, this method will return true if the number of indices is divisible by two.</p>
<p>If the polygon is UNDEFINED, this method will return true if there are no indices.</p>
<p>This method does not validate that the indices are with in range. See <a class="el" href="classcugl_1_1_poly2.html#a50a7b607f80ae7f8ef42048feec688d3">isValid()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the indices are in the proper normal form. </dd></dl>

</div>
</div>
<a class="anchor" id="a50a7b607f80ae7f8ef42048feec688d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the indices are all valid.</p>
<p>This method is a heavier-weight version of <a class="el" href="classcugl_1_1_poly2.html#a6e3e5d08c0cecdfa24c190d9c856f7f6">isStandardized()</a>. It verifies that the number of indices is correct, and that they are all in range.</p>
<p>If the polygon is SOLID, this method will return true if the number of indices is divisible by three and if the index values are all in range.</p>
<p>If the polygon is PATH, this method will return true if the number of indices is divisible by two and if the index values are all in range.</p>
<p>If the polygon is UNDEFINED, this method will return true if there are no indices.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the indices are all valid. </dd></dl>

</div>
</div>
<a class="anchor" id="ad53320bbfd1ce8925633c67915f10c11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a415db5955f7aef89ead8ca78b95f7b97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices non-uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a033bb7266739b2b92dad5f1d2ac2388c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by transforming all of the vertices of this polygon.</p>
<p>The vertices are transformed as points. The z-value is 0.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed polygon </dd></dl>

</div>
</div>
<a class="anchor" id="aadd955e9a4490209fb083c9b97f4c331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="afae34fd1a8bd543bac4b4ea4668d7d8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nonuniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled non-uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="acc4bc214a1acbfb72d922cd6965f7e9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon with the vertices transformed </dd></dl>

</div>
</div>
<a class="anchor" id="aeccc10956ac546f4fee38e0999bc995c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms all of the vertices of this polygon.</p>
<p>The vertices are transformed as points. The z-value is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon with the vertices transformed </dd></dl>

</div>
</div>
<a class="anchor" id="a111deb52b32c543469d5c95d2a1f94b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by transforming all of the vertices of this polygon.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a154a9e8188f5c095a677bea7a675a9ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator+ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a4cd1dc4915cc93b62250eb42ba11e5e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices non-uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a96ac040b2285273f3084bae4ccfe5de0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator+= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="a616325b1dab7f3154342879f616a21a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated non-uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="a92f415df334678257b7fb42e3c05130c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator- </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a40621c7918c24b1c9feaaa997a4a54a8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices non-uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a311dfe1493e17b55a8a6053639acb7b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator-= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c5b2840cf68ef766ded36eeb7063e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated non-uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f339a79f8bef5bde99c319083d2021a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator/ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a18deca15960c885255d7f5fe12557b3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices non-uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a class="anchor" id="a355a0700d44a713bd0ad8c46c14d042d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator/= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="a10d49437ae995277f282099b417f09c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nonuniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled non-uniformly. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e51d73ea036f2efa9123d3952916ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this polygon to be a copy of the given one.</p>
<p>All of the contents are copied, so that this polygon does not hold any references to elements of the other polygon. This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The polygon to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a4d097e4cd083f54a55d2d07a7c63a5a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this polygon to be have the resources of the given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The polygon to take from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a890335eb6b20a1084645e2027167bf50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this polygon to be a copy of the given rectangle.</p>
<p>The polygon will have four vertices, one for each corner of the rectangle. In addition, this assignment will initialize the indices with a simple triangulation of the rectangle. The type will be SOLID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a33366d9d9a73620d93591dfdd78f177d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices</p>
<p>The resulting polygon has no indices and the type is UNDEFINED.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a3a0480801f958d45fcb378fac23d6c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This method will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="aca03a89eba69a6f74989a19fe2ca7b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>The resulting polygon has no indices and the type is UNDEFINED.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="ae8c1be0aea329ce663f02d0065ce5841"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a polygon to have the given vertices and indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This method will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a4805abe53f4fdb76c046c176fd8e6f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices.</p>
<p>The resulting polygon has no indices and the type is UNDEFINED.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="acfd63ea82a14f2a73931885aa75d2eb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>The resulting polygon has no indices and the type is UNDEFINED.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="ac38edc6b65a320d83b6266bc0a8c58d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This method will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon </td></tr>
    <tr><td class="paramname">ioffset</td><td>The offset in indices to start from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a31f93de785b610670c64c3640617dfe9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>voffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices and indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This method will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices </td></tr>
    <tr><td class="paramname">voffset</td><td>The offset in vertices to start the polygon </td></tr>
    <tr><td class="paramname">ioffset</td><td>The offset in indices to start from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a28397786382add4ef7f89e0ed85c4a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this polygon to be a copy of the given one.</p>
<p>All of the contents are copied, so that this polygon does not hold any references to elements of the other polygon. This method returns a reference to this polygon for chaining.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a1cd52a2ddf2eb203be67661335add755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to represent the given rectangle.</p>
<p>The polygon will have four vertices, one for each corner of the rectangle. This optional argument (which is true by default) will initialize the indices with a triangulation of the rectangle. In other words, the type will be SOLID. This is faster than using one of the more heavy-weight triangulators.</p>
<p>If solid is false, it will still generate indices, but will be a PATH instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy </td></tr>
    <tr><td class="paramname">solid</td><td>Whether to treat this rectangle as a solid polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a5e0598d572bf9beb51f0a17e768b739d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::setIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned short &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the indices for this polygon to the ones given.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>This method will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The vector of indices for the shape</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a8ea2a26691e66f18e51f8b81425f9576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::setIndices </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the indices for this polygon to the ones given.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The provided array is copied. The polygon does not retain a reference.</p>
<p>This method will assign a type accoring to the multiplicity of the indices. If the number of indices n is correct for a closed or open path of all vertices (e.g. 2n or 2n-2), then the type will be PATH. Otherwise, if n is divisible by 3 it will be SOLID. All other values will be UNDEFINED, and the user must manually set the type.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices </td></tr>
    <tr><td class="paramname">ioffset</td><td>The offset in indices to start from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a7249d39f2ed3943e21e83580af2af502"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Poly2::setType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html#afb9c4b680316081c12ee189d7924e58b">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the type of this polygon.</p>
<p>The type determines the proper form of the indices.</p>
<p>If the polygon is SOLID, there should be three times as many indices as vertices. Each triplet should define a triangle over the vertices.</p>
<p>If the polygon is PATH, there should be two times as many indices as vertices. Each pair should define a line segment over the vertices.</p>
<p>If the polygon is UNDEFINED, the index list should be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of this polygon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f230e31f94b97e1182005ffe58b8e67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Poly2::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of vertices in a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of vertices in a polygon. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="af8ef5e90dbed6e69b06346ceeddb4b0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a class="anchor" id="ae40e0be6c0458b8479c68e9455f75396"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices non-uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/<a class="el" href="_c_u_poly2_8h_source.html">CUPoly2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

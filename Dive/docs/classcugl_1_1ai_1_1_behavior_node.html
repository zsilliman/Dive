<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::ai::BehaviorNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><b>ai</b></li><li class="navelem"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcugl_1_1ai_1_1_behavior_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::ai::BehaviorNode Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_behavior_node_8h_source.html">CUBehaviorNode.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cugl::ai::BehaviorNode:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcugl_1_1ai_1_1_behavior_node.png" usemap="#cugl::ai::BehaviorNode_map" alt=""/>
  <map id="cugl::ai::BehaviorNode_map" name="cugl::ai::BehaviorNode_map">
<area href="classcugl_1_1ai_1_1_composite_node.html" alt="cugl::ai::CompositeNode" shape="rect" coords="156,56,302,80"/>
<area href="classcugl_1_1ai_1_1_decorator_node.html" alt="cugl::ai::DecoratorNode" shape="rect" coords="546,56,692,80"/>
<area href="classcugl_1_1ai_1_1_leaf_node.html" alt="cugl::ai::LeafNode" shape="rect" coords="702,56,848,80"/>
<area href="classcugl_1_1ai_1_1_priority_node.html" alt="cugl::ai::PriorityNode" shape="rect" coords="0,112,146,136"/>
<area href="classcugl_1_1ai_1_1_random_node.html" alt="cugl::ai::RandomNode" shape="rect" coords="156,112,302,136"/>
<area href="classcugl_1_1ai_1_1_selector_node.html" alt="cugl::ai::SelectorNode" shape="rect" coords="312,112,458,136"/>
<area href="classcugl_1_1ai_1_1_inverter_node.html" alt="cugl::ai::InverterNode" shape="rect" coords="468,112,614,136"/>
<area href="classcugl_1_1ai_1_1_timer_node.html" alt="cugl::ai::TimerNode" shape="rect" coords="624,112,770,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa17c64a77b699d5d61b5824abd4d9c90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">State</a> : unsigned int { <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90a6b273343c454f9c53dcfc9c4ccf171d2">State::INACTIVE</a> = 0, 
<a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90a43491564ebcfd38568918efbd6e840fd">State::RUNNING</a> = 1, 
<a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90a99b2439e63f73ad515f7ab2447a80673">State::PAUSED</a> = 2, 
<a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90a2c616b2713e2e0aed04b4c4752c88133">State::FINISHED</a> = 3
 }<tr class="separator:aa17c64a77b699d5d61b5824abd4d9c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a778e8773de8a50664d1aa91391685a25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a778e8773de8a50664d1aa91391685a25">BehaviorNode</a> ()</td></tr>
<tr class="separator:a778e8773de8a50664d1aa91391685a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7539199fbad7d579017fe17adc011043"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a7539199fbad7d579017fe17adc011043">~BehaviorNode</a> ()</td></tr>
<tr class="separator:a7539199fbad7d579017fe17adc011043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17307ee6021187843ce6d48284d7b2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17307ee6021187843ce6d48284d7b2d">init</a> (const std::string &amp;name)</td></tr>
<tr class="separator:aa17307ee6021187843ce6d48284d7b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d69020b038be2f25d7e977f6acc9b5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ae9d69020b038be2f25d7e977f6acc9b5">dispose</a> ()</td></tr>
<tr class="separator:ae9d69020b038be2f25d7e977f6acc9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4008e5a72f0ef42fd7e74729a0c8aeda"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a4008e5a72f0ef42fd7e74729a0c8aeda">getName</a> () const </td></tr>
<tr class="separator:a4008e5a72f0ef42fd7e74729a0c8aeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f17de6c0fc4c33c83990c18710c671"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#af6f17de6c0fc4c33c83990c18710c671">getPriority</a> () const </td></tr>
<tr class="separator:af6f17de6c0fc4c33c83990c18710c671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef29c469d9478a1438a656b2ad62e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a3ef29c469d9478a1438a656b2ad62e09">getState</a> () const </td></tr>
<tr class="separator:a3ef29c469d9478a1438a656b2ad62e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ccd150a615761047f3837b8259b247"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ab3ccd150a615761047f3837b8259b247">setState</a> (<a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a> state)</td></tr>
<tr class="separator:ab3ccd150a615761047f3837b8259b247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dade77235e3a5ad3b0929ee25eb56ba"><td class="memItemLeft" align="right" valign="top">std::function&lt; float()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a8dade77235e3a5ad3b0929ee25eb56ba">getPrioritizer</a> () const </td></tr>
<tr class="separator:a8dade77235e3a5ad3b0929ee25eb56ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8119ce96204968f1a365858681372ef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a8119ce96204968f1a365858681372ef2">setPrioritizer</a> (const std::function&lt; float()&gt; &amp;func)</td></tr>
<tr class="separator:a8119ce96204968f1a365858681372ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab78347c7de5ea0ca6bada96da17c751d"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ab78347c7de5ea0ca6bada96da17c751d">toString</a> (bool verbose=false) const </td></tr>
<tr class="separator:ab78347c7de5ea0ca6bada96da17c751d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf0dfa5a5e47bab913aa3c54dfe63b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#acbf0dfa5a5e47bab913aa3c54dfe63b4">operator std::string</a> () const </td></tr>
<tr class="separator:acbf0dfa5a5e47bab913aa3c54dfe63b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f0fd81502a62c002106eb5c4c3b879"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ae0f0fd81502a62c002106eb5c4c3b879">getParent</a> () const </td></tr>
<tr class="separator:ae0f0fd81502a62c002106eb5c4c3b879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e585f06c5558b4131be776c78be74e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a60e585f06c5558b4131be776c78be74e">setParent</a> (<a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> *parent)</td></tr>
<tr class="separator:a60e585f06c5558b4131be776c78be74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1f4f012f70707f1ea6fda592116038f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ae1f4f012f70707f1ea6fda592116038f">removeFromParent</a> ()</td></tr>
<tr class="separator:ae1f4f012f70707f1ea6fda592116038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c2631e1fc51f1765d966319c70d94a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a45c2631e1fc51f1765d966319c70d94a">getParentalOffset</a> () const </td></tr>
<tr class="separator:a45c2631e1fc51f1765d966319c70d94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae985584754b814e894f7a23d21479943"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ae985584754b814e894f7a23d21479943">getChildCount</a> () const </td></tr>
<tr class="separator:ae985584754b814e894f7a23d21479943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c986983401750d3fa32ea94bc2231ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a7c986983401750d3fa32ea94bc2231ed">getChildren</a> () const </td></tr>
<tr class="separator:a7c986983401750d3fa32ea94bc2231ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18fe8f324694af8ef361a861bd043d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ac18fe8f324694af8ef361a861bd043d5">getChild</a> (Uint32 pos) const </td></tr>
<tr class="separator:ac18fe8f324694af8ef361a861bd043d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cad63b4e52c990e4c776ae99830bc12"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cad63b4e52c990e4c776ae99830bc12"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a2cad63b4e52c990e4c776ae99830bc12">getChild</a> (Uint32 pos) const </td></tr>
<tr class="separator:a2cad63b4e52c990e4c776ae99830bc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747a1ad59147972549bc627df995e331"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a747a1ad59147972549bc627df995e331">getNodeByName</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a747a1ad59147972549bc627df995e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a7e8ab1962cf96f2096738ccbaacee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a50a7e8ab1962cf96f2096738ccbaacee">getNodeByName</a> (const char *name) const </td></tr>
<tr class="separator:a50a7e8ab1962cf96f2096738ccbaacee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6ea040989d1f19e5ab310d6b245956"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:add6ea040989d1f19e5ab310d6b245956"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#add6ea040989d1f19e5ab310d6b245956">getNodeByName</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:add6ea040989d1f19e5ab310d6b245956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb1ffe84d6b865497855a1b2e800af0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afeb1ffe84d6b865497855a1b2e800af0"><td class="memTemplItemLeft" align="right" valign="top">const T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#afeb1ffe84d6b865497855a1b2e800af0">getNodeByName</a> (const char *name) const </td></tr>
<tr class="separator:afeb1ffe84d6b865497855a1b2e800af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a230b527166678e3ec52cae6dc76aa9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a0a230b527166678e3ec52cae6dc76aa9">reset</a> ()</td></tr>
<tr class="separator:a0a230b527166678e3ec52cae6dc76aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236fbd574d1f12d977485bc530be012a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a236fbd574d1f12d977485bc530be012a">pause</a> ()</td></tr>
<tr class="separator:a236fbd574d1f12d977485bc530be012a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f4fab4acf1ea06340752819080042e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ac2f4fab4acf1ea06340752819080042e">resume</a> ()</td></tr>
<tr class="separator:ac2f4fab4acf1ea06340752819080042e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a9adbe91458ecc8d08b4546ab0fa7b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ae4a9adbe91458ecc8d08b4546ab0fa7b">preempt</a> ()</td></tr>
<tr class="separator:ae4a9adbe91458ecc8d08b4546ab0fa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9087e5a37071ba0b1cf61369ace31e99"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a9087e5a37071ba0b1cf61369ace31e99">start</a> ()</td></tr>
<tr class="separator:a9087e5a37071ba0b1cf61369ace31e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b7f2fc3f0283bde009432776ef1bce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#af0b7f2fc3f0283bde009432776ef1bce">query</a> (float dt)=0</td></tr>
<tr class="separator:af0b7f2fc3f0283bde009432776ef1bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36049552bb4b456160224abb4105830"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa36049552bb4b456160224abb4105830">update</a> (float dt)=0</td></tr>
<tr class="separator:aa36049552bb4b456160224abb4105830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a17b02c3c7e9003128f09703af127d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a9a17b02c3c7e9003128f09703af127d0">setPriority</a> (float priority)</td></tr>
<tr class="separator:a9a17b02c3c7e9003128f09703af127d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34aa97efaa734ea6cf1c3907daa3ec94"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a34aa97efaa734ea6cf1c3907daa3ec94">removeChild</a> (Uint32 pos)</td></tr>
<tr class="separator:a34aa97efaa734ea6cf1c3907daa3ec94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d301581018527138ca03f256d10a15c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a5d301581018527138ca03f256d10a15c">addChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt; child)</td></tr>
<tr class="separator:a5d301581018527138ca03f256d10a15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5d9e4f799743270f398720c2516fb9cc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a5d9e4f799743270f398720c2516fb9cc">compareSiblings</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt; &amp;a, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt; &amp;b)</td></tr>
<tr class="separator:a5d9e4f799743270f398720c2516fb9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab5ff29ab37e037e5ef5520fee400227d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#ab5ff29ab37e037e5ef5520fee400227d">_name</a></td></tr>
<tr class="separator:ab5ff29ab37e037e5ef5520fee400227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4c938dbb77611ba5e6182f5a606701"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aab4c938dbb77611ba5e6182f5a606701">_classname</a></td></tr>
<tr class="separator:aab4c938dbb77611ba5e6182f5a606701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c90f9e2d474df37023560409ce48745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a2c90f9e2d474df37023560409ce48745">_parent</a></td></tr>
<tr class="separator:a2c90f9e2d474df37023560409ce48745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb10cc25d973463fbcee1d9382b63b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a2cb10cc25d973463fbcee1d9382b63b0">_state</a></td></tr>
<tr class="separator:a2cb10cc25d973463fbcee1d9382b63b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcd47c67085d20c181cd9ba371fd120"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aebcd47c67085d20c181cd9ba371fd120">_priority</a></td></tr>
<tr class="separator:aebcd47c67085d20c181cd9ba371fd120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767b0edceff4e0387cb0a16b06e156aa"><td class="memItemLeft" align="right" valign="top">std::function&lt; float()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a767b0edceff4e0387cb0a16b06e156aa">_prioritizer</a></td></tr>
<tr class="separator:a767b0edceff4e0387cb0a16b06e156aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb8fbf93c6186d543606f51802614a6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a0fb8fbf93c6186d543606f51802614a6">_children</a></td></tr>
<tr class="separator:a0fb8fbf93c6186d543606f51802614a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21719648fbe6a666fd5cb18dc45bd69d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a21719648fbe6a666fd5cb18dc45bd69d">_activeChild</a></td></tr>
<tr class="separator:a21719648fbe6a666fd5cb18dc45bd69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8404db37258783a2b9b71afd4ee14be1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#a8404db37258783a2b9b71afd4ee14be1">_childOffset</a></td></tr>
<tr class="separator:a8404db37258783a2b9b71afd4ee14be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract class for a behavior tree node.</p>
<p>This class is a base class for the individual nodes of the behavior tree. Behavior tree nodes are either composite, decorator, or leaf nodes. A leaf node has no children, a decorator has only one, and a composite has one or more. Only leaf nodes have actions attached.</p>
<p>A behavior tree is a construction of behavior nodes. The top node without a parent is the the root of the tree. The tree chooses the action to run based on the priority value of each of the root's descendents. The tree must use an update function to run on each tick, updating the state of each node. The root node of a behavior tree returns the state of the selected leaf node to run.</p>
<p>This class has abstract methods for calculating the priority and updating, which are implemented by the subclasses.</p>
<p>Behavior trees should be managed by a <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>, which creates each <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> from a <a class="el" href="classcugl_1_1ai_1_1_behavior_node_def.html">BehaviorNodeDef</a> and runs and updates the behavior trees. While in the <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>, a behavior tree cannot be modified by any outside methods and any references to the nodes of the behavior tree will be constant. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aa17c64a77b699d5d61b5824abd4d9c90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">cugl::ai::BehaviorNode::State</a> : unsigned int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enumeration indicating the current state of the tree node.</p>
<p>Behaviors are long running, across multiple animation frames. Therefore, we need to track them in the same way that we would track an audio asset. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa17c64a77b699d5d61b5824abd4d9c90a6b273343c454f9c53dcfc9c4ccf171d2"></a>INACTIVE&#160;</td><td class="fielddoc">
<p>The node is neither running nor has already finished with an action. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa17c64a77b699d5d61b5824abd4d9c90a43491564ebcfd38568918efbd6e840fd"></a>RUNNING&#160;</td><td class="fielddoc">
<p>The node is active and currently running. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa17c64a77b699d5d61b5824abd4d9c90a99b2439e63f73ad515f7ab2447a80673"></a>PAUSED&#160;</td><td class="fielddoc">
<p>The node is active but currently paused. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa17c64a77b699d5d61b5824abd4d9c90a2c616b2713e2e0aed04b4c4752c88133"></a>FINISHED&#160;</td><td class="fielddoc">
<p>The node is finished with an action. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a778e8773de8a50664d1aa91391685a25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ai::BehaviorNode::BehaviorNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an uninitialized behavior tree node.</p>
<p>You should never call this constructor directly. Instead, you should allocate a node with the <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a> instance. </p>

</div>
</div>
<a class="anchor" id="a7539199fbad7d579017fe17adc011043"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ai::BehaviorNode::~BehaviorNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this node, disposing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5d301581018527138ca03f256d10a15c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ai::BehaviorNode::addChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the child at the end of the child list of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5d9e4f799743270f398720c2516fb9cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cugl::ai::BehaviorNode::compareSiblings </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if sibling a has a larger priority than sibling b.</p>
<p>This method is used by std::sort to sort the children. Ties are broken from the offset of the children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first child </td></tr>
    <tr><td class="paramname">b</td><td>The second child</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if sibling a is has a larger priority than sibling b. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9d69020b038be2f25d7e977f6acc9b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disposes all of the resources used by this node, including any descendants.</p>
<p>A disposed node can be safely reinitialized. Any children owned by this node will be released. They will be deleted if no other object owns them. This method should only be called by <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1ai_1_1_random_node.html#af7cb2afa3ee073e4b5aea9cf9b866e3a">cugl::ai::RandomNode</a>, <a class="el" href="classcugl_1_1ai_1_1_composite_node.html#ab6ee81a91eb38331e15661d6de9d35f1">cugl::ai::CompositeNode</a>, <a class="el" href="classcugl_1_1ai_1_1_timer_node.html#a3e98c26b6d26958d145f7a6ef65b4e06">cugl::ai::TimerNode</a>, and <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#aaae850c62076e643ad4c58978be2a29d">cugl::ai::LeafNode</a>.</p>

</div>
</div>
<a class="anchor" id="ac18fe8f324694af8ef361a861bd043d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>* cugl::ai::BehaviorNode::getChild </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a (weak) pointer to the child node at the given position.</p>
<p>The purpose of this pointer is to allow access to the subtree of a behavior tree. It does not grant ownership, as ownership is confined to <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a (weak) pointer to the child node at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cad63b4e52c990e4c776ae99830bc12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* cugl::ai::BehaviorNode::getChild </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a (weak) pointer to the child node at the given position.</p>
<p>The purpose of this pointer is to allow access to the subtree of a behavior tree. It does not grant ownership, as ownership is confined to <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>.</p>
<p>This version of the method performs a dynamic typecast to the correct type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a (weak) pointer to the child node at the given position. </dd></dl>

</div>
</div>
<a class="anchor" id="ae985584754b814e894f7a23d21479943"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::ai::BehaviorNode::getChildCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of children of this composite node.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of children of this composite node. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c986983401750d3fa32ea94bc2231ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>*&gt; cugl::ai::BehaviorNode::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the list of (weak) references to the node's children.</p>
<p>The purpose of this collection is to allow access to the subtree of a behavior tree. It does not grant ownership, as ownership is confined to <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the list of (weak) references the node's children. </dd></dl>

</div>
</div>
<a class="anchor" id="a4008e5a72f0ef42fd7e74729a0c8aeda"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::ai::BehaviorNode::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is used to identify the node.</p>
<p>This name is used to identify nodes in a behavior tree. It is used by the <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a> to access this node.</p>
<dl class="section return"><dt>Returns</dt><dd>a string that is used to identify the node. </dd></dl>

</div>
</div>
<a class="anchor" id="a747a1ad59147972549bc627df995e331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>* cugl::ai::BehaviorNode::getNodeByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (first) node with the given name.</p>
<p>This method performs a recursive search down the behavior tree. If there is more than one node with the given name, it returns the first one that is found in an unspecified search order. As a result, names should be unique for best results.</p>
<p>The purpose of this pointer is to allow access to the subtree of a behavior tree. It does not grant ownership, as ownership is confined to <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) node with the given name. </dd></dl>

</div>
</div>
<a class="anchor" id="a50a7e8ab1962cf96f2096738ccbaacee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>* cugl::ai::BehaviorNode::getNodeByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) node with the given name.</p>
<p>This method performs a recursive search down the behavior tree. If there is more than one node with the given name, it returns the first one that is found in an unspecified search order. As a result, names should be unique for best results.</p>
<p>The purpose of this pointer is to allow access to the subtree of a behavior tree. It does not grant ownership, as ownership is confined to <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) node with the given name. </dd></dl>

</div>
</div>
<a class="anchor" id="add6ea040989d1f19e5ab310d6b245956"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* cugl::ai::BehaviorNode::getNodeByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) node with the given name.</p>
<p>This method performs a recursive search down the behavior tree. If there is more than one node with the given name, it returns the first one that is found in an unspecified search order. As a result, names should be unique for best results.</p>
<p>The purpose of this pointer is to allow access to the subtree of a behavior tree. It does not grant ownership, as ownership is confined to <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>.</p>
<p>This version of the method performs a dynamic typecast to the correct type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) node with the given name. </dd></dl>

</div>
</div>
<a class="anchor" id="afeb1ffe84d6b865497855a1b2e800af0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* cugl::ai::BehaviorNode::getNodeByName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) node with the given name.</p>
<p>This method performs a recursive search down the behavior tree. If there is more than one node with the given name, it returns the first one that is found in an unspecified search order. As a result, names should be unique for best results.</p>
<p>The purpose of this pointer is to allow access to the subtree of a behavior tree. It does not grant ownership, as ownership is confined to <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>.</p>
<p>This version of the method performs a dynamic typecast to the correct type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) node with the given name. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0f0fd81502a62c002106eb5c4c3b879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>* cugl::ai::BehaviorNode::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a (weak) pointer to the parent node.</p>
<p>The purpose of this pointer is to climb back up the behavior tree. No child asserts ownership of its parent.</p>
<dl class="section return"><dt>Returns</dt><dd>a (weak) pointer to the parent node. </dd></dl>

</div>
</div>
<a class="anchor" id="a45c2631e1fc51f1765d966319c70d94a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::ai::BehaviorNode::getParentalOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the offset of this behavior tree node within its parent node.</p>
<p>If this node is a root node, it will return -1.</p>
<dl class="section return"><dt>Returns</dt><dd>The child offset of this behavior node. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dade77235e3a5ad3b0929ee25eb56ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;float()&gt; cugl::ai::BehaviorNode::getPrioritizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the priority function for this node.</p>
<p>This function should return a value between 0 and 1 representing the priority. When this function is defined, it overrides the rules that this node uses for defining its priority in <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#af0b7f2fc3f0283bde009432776ef1bce">query</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the priority function for this node. </dd></dl>

</div>
</div>
<a class="anchor" id="af6f17de6c0fc4c33c83990c18710c671"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::ai::BehaviorNode::getPriority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current priority of this node.</p>
<p>This priority value is used to determine the relevance of a node in comparison to other nodes. This value is between 0 and 1. Higher priority nodes are more likely to be selected. It will be updated each time <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#af0b7f2fc3f0283bde009432776ef1bce">query</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>a float that signifies the priority of this behavior tree node. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ef29c469d9478a1438a656b2ad62e09"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a> cugl::ai::BehaviorNode::getState </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the state of this node.</p>
<p>If this node has no parent, then this is the state of the behavior tree.</p>
<dl class="section return"><dt>Returns</dt><dd>the state of this node. </dd></dl>

</div>
</div>
<a class="anchor" id="aa17307ee6021187843ce6d48284d7b2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::ai::BehaviorNode::init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a behavior tree node with the given name.</p>
<p>You should never call this method directly. Instead, you should initialize a node with the <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a> instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the behavior node</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a class="anchor" id="acbf0dfa5a5e47bab913aa3c54dfe63b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ai::BehaviorNode::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from a <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> to a string. </p>

</div>
</div>
<a class="anchor" id="a236fbd574d1f12d977485bc530be012a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::pause </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pauses this running node and all running nodes below it in the tree.</p>
<p>A paused node can be resumed later. This method has no effect on values stored within nodes, and values (such as priority or timer delay) will not be updated while nodes are paused. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#af4afaa6ca9a30ed90d88aac2c9ef618e">cugl::ai::LeafNode</a>.</p>

</div>
</div>
<a class="anchor" id="ae4a9adbe91458ecc8d08b4546ab0fa7b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::preempt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops this node from running.</p>
<p>This method also stops any running nodes under this one if they exist. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1ai_1_1_timer_node.html#a090c0c33514c3d43a2f1c3f5efa1ae55">cugl::ai::TimerNode</a>, and <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#a51d02169670ef5430bea88c9390b9d86">cugl::ai::LeafNode</a>.</p>

</div>
</div>
<a class="anchor" id="af0b7f2fc3f0283bde009432776ef1bce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::query </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates the priority value(s) for this node.</p>
<p>This method recursively determines the priority of this node and all of its children. The priority may be determined by a user-provided priority function or by the default priority function of the class.</p>
<p>When this method is complete, it will chose a child node to run, but will not run it. Unlike <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa36049552bb4b456160224abb4105830">update</a>, this method is guaranteed to run every time step in <a class="el" href="classcugl_1_1ai_1_1_behavior_manager.html">BehaviorManager</a>, provided that the root node is running.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The elapsed time since the last frame. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classcugl_1_1ai_1_1_timer_node.html#a948f24380d5fac09ab34a66fdc19c206">cugl::ai::TimerNode</a>, <a class="el" href="classcugl_1_1ai_1_1_composite_node.html#a7d756ddf4c76034ee11c9cfbfcd58575">cugl::ai::CompositeNode</a>, <a class="el" href="classcugl_1_1ai_1_1_random_node.html#ac0b1778a18912c4bdf83bc27db8aa90d">cugl::ai::RandomNode</a>, <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#a4b58fc98bb6a4dbdcdedb487724051a5">cugl::ai::LeafNode</a>, <a class="el" href="classcugl_1_1ai_1_1_decorator_node.html#af71c48f530aa9da539790e2c37a5e5af">cugl::ai::DecoratorNode</a>, and <a class="el" href="classcugl_1_1ai_1_1_inverter_node.html#acabfc49773b069a8bea10a053815b634">cugl::ai::InverterNode</a>.</p>

</div>
</div>
<a class="anchor" id="a34aa97efaa734ea6cf1c3907daa3ec94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>&gt; cugl::ai::BehaviorNode::removeChild </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the child at the given position from this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the child node that will be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child removed at the given position </dd></dl>

</div>
</div>
<a class="anchor" id="ae1f4f012f70707f1ea6fda592116038f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ai::BehaviorNode::removeFromParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes this node from its parent.</p>
<p>If this node has no parent, nothing happens. </p>

</div>
</div>
<a class="anchor" id="a0a230b527166678e3ec52cae6dc76aa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets this node and all nodes below it to an uninitialized state.</p>
<p>This method also resets any class values to those set at the start of the tree. This method allows the node to be started again, as if it had not been run before. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1ai_1_1_timer_node.html#a3543bae9722373a31640fdb590c4ead4">cugl::ai::TimerNode</a>, and <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#a065ef6c2380a1a0351e925ea7fe6e95d">cugl::ai::LeafNode</a>.</p>

</div>
</div>
<a class="anchor" id="ac2f4fab4acf1ea06340752819080042e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resumes a paused node and all paused nodes below it in the tree.</p>
<p>Values such as priority or timer delay will not have been updated while the node was paused. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#a82adfa5e7d756ad7b30f52437fcda299">cugl::ai::LeafNode</a>.</p>

</div>
</div>
<a class="anchor" id="a60e585f06c5558b4131be776c78be74e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ai::BehaviorNode::setParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the parent of this node.</p>
<p>The purpose of this pointer is to climb back up the behavior tree. No child asserts ownership of its parent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8119ce96204968f1a365858681372ef2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ai::BehaviorNode::setPrioritizer </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; float()&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the priority function for this node.</p>
<p>This function should return a value between 0 and 1 representing the priority. When this function is defined, it overrides the rules that this node uses for defining its priority in <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#af0b7f2fc3f0283bde009432776ef1bce">query</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The priority function for this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a17b02c3c7e9003128f09703af127d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ai::BehaviorNode::setPriority </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the priority of this node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">priority</td><td>The priority of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3ccd150a615761047f3837b8259b247"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::setState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the state of this node.</p>
<p>If this node has no parent, then this is the state of the behavior tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>The state of this node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1ai_1_1_timer_node.html#a13a153d42e8ae4b09f900e94e9d6ad8d">cugl::ai::TimerNode</a>.</p>

</div>
</div>
<a class="anchor" id="a9087e5a37071ba0b1cf61369ace31e99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::ai::BehaviorNode::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes this node for execution.</p>
<p>When called this node moves from an uninitialized state to one where the <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa36049552bb4b456160224abb4105830">update()</a> function is safe to be called. </p>

</div>
</div>
<a class="anchor" id="ab78347c7de5ea0ca6bada96da17c751d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cugl::ai::BehaviorNode::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string representation of this node for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this node for debugging purposes. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1ai_1_1_random_node.html#a4b02638eff863c2b0b1f61f710a896f0">cugl::ai::RandomNode</a>, <a class="el" href="classcugl_1_1ai_1_1_timer_node.html#aa10a9e6d5424288d3bf6d990cdfbeda4">cugl::ai::TimerNode</a>, and <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#a14a61083e08d169bde840542c722d4e4">cugl::ai::LeafNode</a>.</p>

</div>
</div>
<a class="anchor" id="aa36049552bb4b456160224abb4105830"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a> cugl::ai::BehaviorNode::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates this node and any active children.</p>
<p>This method runs the update function, which executes to active child (if not a leaf) or the associated action (if a leaf). This method is not guaranteed to execute every time step; only if the node is the root of the tree or is selected as part of the active path.</p>
<p>If a node is not a leaf node and it has no active children, then the method will return INACTIVE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dt</td><td>The elapsed time since the last frame.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the state of this node after updating. </dd></dl>

<p>Implemented in <a class="el" href="classcugl_1_1ai_1_1_timer_node.html#a7b2b25c4b5e42c5d0c0296e82643934a">cugl::ai::TimerNode</a>, <a class="el" href="classcugl_1_1ai_1_1_composite_node.html#a6eea7b766210e3f4052dd18408679a6d">cugl::ai::CompositeNode</a>, <a class="el" href="classcugl_1_1ai_1_1_leaf_node.html#a68d787757c064dce891e3ed94390e5a9">cugl::ai::LeafNode</a>, and <a class="el" href="classcugl_1_1ai_1_1_decorator_node.html#a4b118dc96ddfa648900a226064b7b506">cugl::ai::DecoratorNode</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a21719648fbe6a666fd5cb18dc45bd69d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::ai::BehaviorNode::_activeChild</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The index of the child running (-1 if no child is currently running). </p>

</div>
</div>
<a class="anchor" id="a8404db37258783a2b9b71afd4ee14be1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::ai::BehaviorNode::_childOffset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (current) child offset of this node (-1 if root) </p>

</div>
</div>
<a class="anchor" id="a0fb8fbf93c6186d543606f51802614a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>&gt; &gt; cugl::ai::BehaviorNode::_children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array of children for this composite node. </p>

</div>
</div>
<a class="anchor" id="aab4c938dbb77611ba5e6182f5a606701"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::ai::BehaviorNode::_classname</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of this class (for debugging polymorphism). </p>

</div>
</div>
<a class="anchor" id="ab5ff29ab37e037e5ef5520fee400227d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::ai::BehaviorNode::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The descriptive, identifying name of the node. </p>

</div>
</div>
<a class="anchor" id="a2c90f9e2d474df37023560409ce48745"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html">BehaviorNode</a>* cugl::ai::BehaviorNode::_parent</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A weaker pointer to the parent (or null if root). </p>

</div>
</div>
<a class="anchor" id="a767b0edceff4e0387cb0a16b06e156aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;float()&gt; cugl::ai::BehaviorNode::_prioritizer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current priority function for this behavior node. </p>

</div>
</div>
<a class="anchor" id="aebcd47c67085d20c181cd9ba371fd120"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::ai::BehaviorNode::_priority</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current priority, or relevance of this node. </p>

</div>
</div>
<a class="anchor" id="a2cb10cc25d973463fbcee1d9382b63b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1ai_1_1_behavior_node.html#aa17c64a77b699d5d61b5824abd4d9c90">BehaviorNode::State</a> cugl::ai::BehaviorNode::_state</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current state of this node. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/ai/behavior/<a class="el" href="_c_u_behavior_node_8h_source.html">CUBehaviorNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::BinaryReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcugl_1_1_binary_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::BinaryReader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_binary_reader_8h_source.html">CUBinaryReader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb4d1875bdd81139d57c5d2c985e0f45"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#aeb4d1875bdd81139d57c5d2c985e0f45">BinaryReader</a> ()</td></tr>
<tr class="separator:aeb4d1875bdd81139d57c5d2c985e0f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0a3dbac8e882d826e9cc2787af7eb1c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ad0a3dbac8e882d826e9cc2787af7eb1c">~BinaryReader</a> ()</td></tr>
<tr class="separator:ad0a3dbac8e882d826e9cc2787af7eb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae224ac21c73059b719214c62b10ed3ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ae224ac21c73059b719214c62b10ed3ab">init</a> (const std::string &amp;file)</td></tr>
<tr class="separator:ae224ac21c73059b719214c62b10ed3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a192bbca25d41d0513f88e1c9b3eba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#aa0a192bbca25d41d0513f88e1c9b3eba">init</a> (const char *file)</td></tr>
<tr class="separator:aa0a192bbca25d41d0513f88e1c9b3eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b5d3f41746a53bc48c19c5ceb988d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a03b5d3f41746a53bc48c19c5ceb988d7">init</a> (const <a class="el" href="classcugl_1_1_pathname.html">Pathname</a> &amp;file)</td></tr>
<tr class="separator:a03b5d3f41746a53bc48c19c5ceb988d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538dcf42fcdb104c9768a94bc7b3a83d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a538dcf42fcdb104c9768a94bc7b3a83d">init</a> (const std::string &amp;file, unsigned int capacity)</td></tr>
<tr class="separator:a538dcf42fcdb104c9768a94bc7b3a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314c6d63d6f6d99505dc58e73fef3879"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a314c6d63d6f6d99505dc58e73fef3879">init</a> (const char *file, unsigned int capacity)</td></tr>
<tr class="separator:a314c6d63d6f6d99505dc58e73fef3879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7620244aac7c2f34bf9369469aed84e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a7620244aac7c2f34bf9369469aed84e2">init</a> (const <a class="el" href="classcugl_1_1_pathname.html">Pathname</a> &amp;file, unsigned int capacity)</td></tr>
<tr class="separator:a7620244aac7c2f34bf9369469aed84e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f74fbb5c97b6229d09bcbeeccf227fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a6f74fbb5c97b6229d09bcbeeccf227fe">initWithAsset</a> (const std::string &amp;file)</td></tr>
<tr class="separator:a6f74fbb5c97b6229d09bcbeeccf227fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab373695de707a34d9286f06e10f2073e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ab373695de707a34d9286f06e10f2073e">initWithAsset</a> (const char *file)</td></tr>
<tr class="separator:ab373695de707a34d9286f06e10f2073e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e9fcaa7c437160bbc3e97f42e791f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ae3e9fcaa7c437160bbc3e97f42e791f6">initWithAsset</a> (const std::string &amp;file, unsigned int capacity)</td></tr>
<tr class="separator:ae3e9fcaa7c437160bbc3e97f42e791f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b3db912f8c256bf7ce5ddb7d1b42a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a18b3db912f8c256bf7ce5ddb7d1b42a3">initWithAsset</a> (const char *file, unsigned int capacity)</td></tr>
<tr class="separator:a18b3db912f8c256bf7ce5ddb7d1b42a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d970cf5cc1c13cb2ff4be6300304f66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a7d970cf5cc1c13cb2ff4be6300304f66">reset</a> ()</td></tr>
<tr class="separator:a7d970cf5cc1c13cb2ff4be6300304f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52349a673fdc6c99e644c346df254c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a52349a673fdc6c99e644c346df254c16">close</a> ()</td></tr>
<tr class="separator:a52349a673fdc6c99e644c346df254c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3b9d96dc02f7309f1dfe0940db5f22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a0b3b9d96dc02f7309f1dfe0940db5f22">ready</a> (unsigned int bytes=1) const </td></tr>
<tr class="separator:a0b3b9d96dc02f7309f1dfe0940db5f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e35b6a8fe667d7fea128e6f8828c95"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a15e35b6a8fe667d7fea128e6f8828c95">readChar</a> ()</td></tr>
<tr class="separator:a15e35b6a8fe667d7fea128e6f8828c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4259df3b2f7c7733a95e6fc52c7bc05e"><td class="memItemLeft" align="right" valign="top">Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a4259df3b2f7c7733a95e6fc52c7bc05e">readByte</a> ()</td></tr>
<tr class="separator:a4259df3b2f7c7733a95e6fc52c7bc05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f3a9f852d2c985a41384c6ad4a2213"><td class="memItemLeft" align="right" valign="top">Sint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ae6f3a9f852d2c985a41384c6ad4a2213">readSint16</a> ()</td></tr>
<tr class="separator:ae6f3a9f852d2c985a41384c6ad4a2213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c98eb17532292f68eac97575fe67bd8"><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a1c98eb17532292f68eac97575fe67bd8">readUint16</a> ()</td></tr>
<tr class="separator:a1c98eb17532292f68eac97575fe67bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd5c0cf6b56d2784ffb5cfb21fb9f09"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#affd5c0cf6b56d2784ffb5cfb21fb9f09">readSint32</a> ()</td></tr>
<tr class="separator:affd5c0cf6b56d2784ffb5cfb21fb9f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b373ddbe929d95b763d686deb5813e9"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a7b373ddbe929d95b763d686deb5813e9">readUint32</a> ()</td></tr>
<tr class="separator:a7b373ddbe929d95b763d686deb5813e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7d27dc7fb954e808c6a41a93515795"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a8c7d27dc7fb954e808c6a41a93515795">readSint64</a> ()</td></tr>
<tr class="separator:a8c7d27dc7fb954e808c6a41a93515795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b9595e484a67eeeea8255628c845f6"><td class="memItemLeft" align="right" valign="top">Uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#aa1b9595e484a67eeeea8255628c845f6">readUint64</a> ()</td></tr>
<tr class="separator:aa1b9595e484a67eeeea8255628c845f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883271d2bd37184ca0322634097adbcb"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a883271d2bd37184ca0322634097adbcb">readFloat</a> ()</td></tr>
<tr class="separator:a883271d2bd37184ca0322634097adbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef15e8f16153a7ffd60dbe75b2072fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#afef15e8f16153a7ffd60dbe75b2072fb">readDouble</a> ()</td></tr>
<tr class="separator:afef15e8f16153a7ffd60dbe75b2072fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4e7d2356884811c04295ccb47a5754"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> (char *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:a2a4e7d2356884811c04295ccb47a5754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad423003e5a73684165a7cfc634da4d50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ad423003e5a73684165a7cfc634da4d50">read</a> (Uint8 *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:ad423003e5a73684165a7cfc634da4d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaef4c232f9acfe6c68229510681027"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#aaeaef4c232f9acfe6c68229510681027">read</a> (Sint16 *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:aaeaef4c232f9acfe6c68229510681027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71baff95f7e5f63287fb3322cf804a94"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a71baff95f7e5f63287fb3322cf804a94">read</a> (Uint16 *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:a71baff95f7e5f63287fb3322cf804a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32af94a6353d6d5389042df7ae79e9a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a32af94a6353d6d5389042df7ae79e9a4">read</a> (Sint32 *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:a32af94a6353d6d5389042df7ae79e9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3572bab3339e07c48e44273a53031ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#aa3572bab3339e07c48e44273a53031ef">read</a> (Uint32 *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:aa3572bab3339e07c48e44273a53031ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa140c7d4a6728050199b2941aecb8e4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#aa140c7d4a6728050199b2941aecb8e4c">read</a> (Sint64 *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:aa140c7d4a6728050199b2941aecb8e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a3e00eb6068e76bcf3a4ffacafaea7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ac8a3e00eb6068e76bcf3a4ffacafaea7">read</a> (Uint64 *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:ac8a3e00eb6068e76bcf3a4ffacafaea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b8c99776bd196d30aed9ee6d6476da"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a82b8c99776bd196d30aed9ee6d6476da">read</a> (float *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:a82b8c99776bd196d30aed9ee6d6476da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454cd49c6695490aa9a1bfef26363d04"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a454cd49c6695490aa9a1bfef26363d04">read</a> (double *buffer, size_t maximum, size_t offset=0)</td></tr>
<tr class="separator:a454cd49c6695490aa9a1bfef26363d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab454233a0330232b861c49a8561d47be"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#ab454233a0330232b861c49a8561d47be">alloc</a> (const std::string &amp;file)</td></tr>
<tr class="separator:ab454233a0330232b861c49a8561d47be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed2f773feade13ff8e94d93d73e06b2"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a6ed2f773feade13ff8e94d93d73e06b2">alloc</a> (const char *file)</td></tr>
<tr class="separator:a6ed2f773feade13ff8e94d93d73e06b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2e47bae4020b8d4f6a1688f079c273"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a9b2e47bae4020b8d4f6a1688f079c273">alloc</a> (const std::string &amp;file, unsigned int capacity)</td></tr>
<tr class="separator:a9b2e47bae4020b8d4f6a1688f079c273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3461d6694a935c467e5c7f6d939dee77"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a3461d6694a935c467e5c7f6d939dee77">alloc</a> (const char *file, unsigned int capacity)</td></tr>
<tr class="separator:a3461d6694a935c467e5c7f6d939dee77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256ba8d3cfb64503e94886eeb315d71e"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a256ba8d3cfb64503e94886eeb315d71e">allocWithAsset</a> (const std::string &amp;file)</td></tr>
<tr class="separator:a256ba8d3cfb64503e94886eeb315d71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba4d1ea37da43b44eae3a6b26755c5c5"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#aba4d1ea37da43b44eae3a6b26755c5c5">allocWithAsset</a> (const char *file)</td></tr>
<tr class="separator:aba4d1ea37da43b44eae3a6b26755c5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67986a8f8a3bed705c253a405276c337"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a67986a8f8a3bed705c253a405276c337">allocWithAsset</a> (const std::string &amp;file, unsigned int capacity)</td></tr>
<tr class="separator:a67986a8f8a3bed705c253a405276c337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1918e895a931c0e3dbc4e21114d24a28"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a1918e895a931c0e3dbc4e21114d24a28">allocWithAsset</a> (const char *file, unsigned int capacity)</td></tr>
<tr class="separator:a1918e895a931c0e3dbc4e21114d24a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a45143712f50f5a91248998e9ef4d9875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a45143712f50f5a91248998e9ef4d9875">fill</a> (unsigned int bytes=1)</td></tr>
<tr class="separator:a45143712f50f5a91248998e9ef4d9875"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a67adcd3430ab0bb66be9a52e748f92fd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a67adcd3430ab0bb66be9a52e748f92fd">_name</a></td></tr>
<tr class="separator:a67adcd3430ab0bb66be9a52e748f92fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3553880e92f6749c5f2c6f6bd3f988"><td class="memItemLeft" align="right" valign="top">SDL_RWops *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a2b3553880e92f6749c5f2c6f6bd3f988">_stream</a></td></tr>
<tr class="separator:a2b3553880e92f6749c5f2c6f6bd3f988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571e56a9da852826deb08498670476db"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a571e56a9da852826deb08498670476db">_ssize</a></td></tr>
<tr class="separator:a571e56a9da852826deb08498670476db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f59fc44a6f5c3124674d0b5b5def54"><td class="memItemLeft" align="right" valign="top">Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a96f59fc44a6f5c3124674d0b5b5def54">_scursor</a></td></tr>
<tr class="separator:a96f59fc44a6f5c3124674d0b5b5def54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c21aa3dbd3038f1d9a93c5f32cbfd0"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a34c21aa3dbd3038f1d9a93c5f32cbfd0">_buffer</a></td></tr>
<tr class="separator:a34c21aa3dbd3038f1d9a93c5f32cbfd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5dc0e76ee627fff300dc84644d15c2"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#acc5dc0e76ee627fff300dc84644d15c2">_capacity</a></td></tr>
<tr class="separator:acc5dc0e76ee627fff300dc84644d15c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd56c9e3168c42b6d96c1504715005b9"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#acd56c9e3168c42b6d96c1504715005b9">_bufsize</a></td></tr>
<tr class="separator:acd56c9e3168c42b6d96c1504715005b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b40ec4442d9983368e96562860891"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_binary_reader.html#a301b40ec4442d9983368e96562860891">_bufoff</a></td></tr>
<tr class="separator:a301b40ec4442d9983368e96562860891"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Simple cross-platform reader for binary files.</p>
<p>This class provides a simple Java-style reader for decoding binary files. All data is marshalled from network order, ensuring that the files are supported across multiple platforms.</p>
<p>Note that this reader does not refer to the integral types as short, int, long, etc. Those types are NOT cross-platform. For example, a long is 8 bytes on Unix/OS X, but 4 bytes on Win32 platforms.</p>
<p>By default, this class (and every class in the io package) accesses the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you want to access another directory, you will need to specify an absolute path for the file name. Keep in mind that absolute paths are very dangerous on mobile devices, because they do not have proper file systems. You should confine all files to either the asset or the save directory. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aeb4d1875bdd81139d57c5d2c985e0f45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::BinaryReader::BinaryReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a binary reader with no assigned file.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate an object on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a class="anchor" id="ad0a3dbac8e882d826e9cc2787af7eb1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::BinaryReader::~BinaryReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this reader and all of its resources.</p>
<p>Calls to the destructor will close the file if it is not already closed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab454233a0330232b861c49a8561d47be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ed2f773feade13ff8e94d93d73e06b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::alloc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b2e47bae4020b8d4f6a1688f079c273"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file with the specified capacity.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file </td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file with the specified capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="a3461d6694a935c467e5c7f6d939dee77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::alloc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file with the specified capacity.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file </td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file with the specified capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="a256ba8d3cfb64503e94886eeb315d71e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::allocWithAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file. </dd></dl>

</div>
</div>
<a class="anchor" id="aba4d1ea37da43b44eae3a6b26755c5c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::allocWithAsset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file. </dd></dl>

</div>
</div>
<a class="anchor" id="a67986a8f8a3bed705c253a405276c337"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::allocWithAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file with the specified capacity.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file</td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file with the specified capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="a1918e895a931c0e3dbc4e21114d24a28"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_binary_reader.html">BinaryReader</a>&gt; cugl::BinaryReader::allocWithAsset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated reader for the given file with the specified capacity.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file</td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated reader for the given file with the specified capacity. </dd></dl>

</div>
</div>
<a class="anchor" id="a52349a673fdc6c99e644c346df254c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BinaryReader::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the stream, releasing all resources</p>
<p>Any attempts to read from a closed stream will fail. Calling this method on a previously closed stream has no effect. </p>

</div>
</div>
<a class="anchor" id="a45143712f50f5a91248998e9ef4d9875"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BinaryReader::fill </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bytes</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills the storage buffer to capacity</p>
<p>This cuts down on the number of reads to the file by allowing us to read from the file in predefined chunks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The minimum number of bytes to ensure in the stream </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae224ac21c73059b719214c62b10ed3ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa0a192bbca25d41d0513f88e1c9b3eba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a03b5d3f41746a53bc48c19c5ceb988d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_pathname.html">Pathname</a> &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a538dcf42fcdb104c9768a94bc7b3a83d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a reader for the given file with the specified capacity.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file </td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a314c6d63d6f6d99505dc58e73fef3879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a reader for the given file with the specified capacity.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file </td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7620244aac7c2f34bf9369469aed84e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_pathname.html">Pathname</a> &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a reader for the given file with the specified capacity.</p>
<p>If the file is a relative path, this reader will look for the file in the application save directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#ad6298e91ad790bd7fbb54da1682cb818">Application::getSaveDirectory()</a>}. If you wish to <a class="el" href="classcugl_1_1_binary_reader.html#a2a4e7d2356884811c04295ccb47a5754">read</a> a file in any other directory, you must provide an absolute path.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the path (absolute or relative) to the file </td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f74fbb5c97b6229d09bcbeeccf227fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::initWithAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab373695de707a34d9286f06e10f2073e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::initWithAsset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a reader for the given file.</p>
<p>The reader will have the default buffer capacity for reading chunks from the file.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3e9fcaa7c437160bbc3e97f42e791f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::initWithAsset </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a reader for the given file with the specified capacity.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file </td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a18b3db912f8c256bf7ce5ddb7d1b42a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::initWithAsset </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a reader for the given file with the specified capacity.</p>
<p>This initializer assumes that the file name is a relative path. It will search the application assert directory {</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_application.html#a6e26e6eb8f983034fc72e07a6011dfae">Application::getAssetDirectory()</a>} for the file and return false if it cannot find it there.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>the relative path to the file </td></tr>
    <tr><td class="paramname">capacity</td><td>the buffer capacity for reading chunks</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the reader is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a4e7d2356884811c04295ccb47a5754"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of characters from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of characters read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="ad423003e5a73684165a7cfc634da4d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">Uint8 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of bytes from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="aaeaef4c232f9acfe6c68229510681027"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">Sint16 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of 16 bit signed integers from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of 16 bit signed integers read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a71baff95f7e5f63287fb3322cf804a94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of 16 bit unsigned integers from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of 16 bit unsigned integers read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a32af94a6353d6d5389042df7ae79e9a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">Sint32 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of 32 bit signed integers from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of 32 bit signed integers read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="aa3572bab3339e07c48e44273a53031ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of 32 bit unsigned integers from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of 32 bit unsigned integers read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="aa140c7d4a6728050199b2941aecb8e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">Sint64 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of 32 bit signed integers from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of 32 bit signed integers read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="ac8a3e00eb6068e76bcf3a4ffacafaea7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">Uint64 *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of 32 bit unsigned integers from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of 32 bit unsigned integers read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a82b8c99776bd196d30aed9ee6d6476da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of floats from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of floats read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a454cd49c6695490aa9a1bfef26363d04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::BinaryReader::read </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a sequence of doubles from the stream.</p>
<p>The function will attempt to read up to maximum number of elements. It will return the actual number of elements read (which may be 0).</p>
<p>The values are marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The array to store the data when read </td></tr>
    <tr><td class="paramname">maximum</td><td>The maximum number of elements to read from the stream </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to start in the buffer array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of doubles read from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a4259df3b2f7c7733a95e6fc52c7bc05e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint8 cugl::BinaryReader::readByte </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single byte from the stream</p>
<dl class="section return"><dt>Returns</dt><dd>a single byte from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a15e35b6a8fe667d7fea128e6f8828c95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char cugl::BinaryReader::readChar </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single character from the stream</p>
<dl class="section return"><dt>Returns</dt><dd>a single character from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="afef15e8f16153a7ffd60dbe75b2072fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cugl::BinaryReader::readDouble </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single double from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single double from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a883271d2bd37184ca0322634097adbcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::BinaryReader::readFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single float from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single float from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="ae6f3a9f852d2c985a41384c6ad4a2213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint16 cugl::BinaryReader::readSint16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single 16 bit signed integer from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single 16 bit signed integer from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="affd5c0cf6b56d2784ffb5cfb21fb9f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 cugl::BinaryReader::readSint32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single 32 bit signed integer from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single 32 bit signed integer from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a8c7d27dc7fb954e808c6a41a93515795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 cugl::BinaryReader::readSint64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single 32 bit signed integer from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single 32 bit signed integer from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a1c98eb17532292f68eac97575fe67bd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 cugl::BinaryReader::readUint16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single 16 bit unsigned integer from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single 16 bit unsigned integer from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a7b373ddbe929d95b763d686deb5813e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 cugl::BinaryReader::readUint32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single 32 bit unsigned integer from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single 32 bit unsigned integer from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="aa1b9595e484a67eeeea8255628c845f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint64 cugl::BinaryReader::readUint64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a single 32 bit unsigned integer from the stream</p>
<p>The value is marshalled from network order, ensuring that the binary file is compatible against all platforms.</p>
<dl class="section return"><dt>Returns</dt><dd>a single 32 bit unsigned integer from the stream </dd></dl>

</div>
</div>
<a class="anchor" id="a0b3b9d96dc02f7309f1dfe0940db5f22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BinaryReader::ready </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>bytes</em> = <code>1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there is still data to read.</p>
<p>This method will return false if the stream is closed, or if there are too few bytes remaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bytes</td><td>The number of bytes required</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there is enough data left to read </dd></dl>

</div>
</div>
<a class="anchor" id="a7d970cf5cc1c13cb2ff4be6300304f66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BinaryReader::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the stream back to the beginning</p>
<p>This allows the stream to be read a second time. It may even be called if the stream has been closed. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a34c21aa3dbd3038f1d9a93c5f32cbfd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* cugl::BinaryReader::_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The temporary transfer buffer </p>

</div>
</div>
<a class="anchor" id="a301b40ec4442d9983368e96562860891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 cugl::BinaryReader::_bufoff</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current offset in the read buffer </p>

</div>
</div>
<a class="anchor" id="acd56c9e3168c42b6d96c1504715005b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 cugl::BinaryReader::_bufsize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer capacity </p>

</div>
</div>
<a class="anchor" id="acc5dc0e76ee627fff300dc84644d15c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 cugl::BinaryReader::_capacity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The buffer capacity </p>

</div>
</div>
<a class="anchor" id="a67adcd3430ab0bb66be9a52e748f92fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::BinaryReader::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The (full) path for the file </p>

</div>
</div>
<a class="anchor" id="a96f59fc44a6f5c3124674d0b5b5def54"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 cugl::BinaryReader::_scursor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The cursor into the SDL I/O stream </p>

</div>
</div>
<a class="anchor" id="a571e56a9da852826deb08498670476db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Sint64 cugl::BinaryReader::_ssize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The SDL I/O stream size </p>

</div>
</div>
<a class="anchor" id="a2b3553880e92f6749c5f2c6f6bd3f988"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SDL_RWops* cugl::BinaryReader::_stream</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The SDL I/O stream for reading </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/io/<a class="el" href="_c_u_binary_reader_8h_source.html">CUBinaryReader.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

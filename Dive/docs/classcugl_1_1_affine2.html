<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::Affine2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcugl_1_1_affine2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Affine2 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_affine2_8h_source.html">CUAffine2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b8cdc57a2fefbe3b701bd13b1b9c8c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a4b8cdc57a2fefbe3b701bd13b1b9c8c3">Affine2</a> ()</td></tr>
<tr class="separator:a4b8cdc57a2fefbe3b701bd13b1b9c8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab97798b85f16c036eea8f5902f64853"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aab97798b85f16c036eea8f5902f64853">Affine2</a> (float m11, float m12, float m21, float m22, float tx, float ty)</td></tr>
<tr class="separator:aab97798b85f16c036eea8f5902f64853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec4e6f35e898ccd5846066e25eb0d38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#adec4e6f35e898ccd5846066e25eb0d38">Affine2</a> (const float *mat)</td></tr>
<tr class="separator:adec4e6f35e898ccd5846066e25eb0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a28b046f97e022fd688d0850179e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0f2a28b046f97e022fd688d0850179e7">Affine2</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;copy)</td></tr>
<tr class="separator:a0f2a28b046f97e022fd688d0850179e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641ade00a492018865a14b382afc870d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a641ade00a492018865a14b382afc870d">Affine2</a> (<a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;copy)</td></tr>
<tr class="separator:a641ade00a492018865a14b382afc870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25af9673fe7343a4989130f2227fabf7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a25af9673fe7343a4989130f2227fabf7">~Affine2</a> ()</td></tr>
<tr class="separator:a25af9673fe7343a4989130f2227fabf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc78fab6e7925504813d05d8133b35b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#accc78fab6e7925504813d05d8133b35b">operator=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:accc78fab6e7925504813d05d8133b35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6488ba992de5a72c48523724cb1f30d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a6488ba992de5a72c48523724cb1f30d9">operator=</a> (<a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;mat)</td></tr>
<tr class="separator:a6488ba992de5a72c48523724cb1f30d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d463f5418645f7b54ae1ea46951e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab8d463f5418645f7b54ae1ea46951e95">operator=</a> (const float *array)</td></tr>
<tr class="separator:ab8d463f5418645f7b54ae1ea46951e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccaf334303ae3e95b208b9af65d328e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#afccaf334303ae3e95b208b9af65d328e">set</a> (float m11, float m12, float m21, float m22, float tx, float ty)</td></tr>
<tr class="separator:afccaf334303ae3e95b208b9af65d328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af278299eff6733d7c28199aca350fc3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#af278299eff6733d7c28199aca350fc3e">set</a> (const float *mat)</td></tr>
<tr class="separator:af278299eff6733d7c28199aca350fc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add02033567fa0f676563557c689e5039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#add02033567fa0f676563557c689e5039">set</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:add02033567fa0f676563557c689e5039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01e54686c9af28b75ccd200cfd3dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#acd01e54686c9af28b75ccd200cfd3dd3">setIdentity</a> ()</td></tr>
<tr class="separator:acd01e54686c9af28b75ccd200cfd3dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6f551ca7edcaecaad777b2811d7c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#adc6f551ca7edcaecaad777b2811d7c82">setZero</a> ()</td></tr>
<tr class="separator:adc6f551ca7edcaecaad777b2811d7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e0fa346a069ff55aa36df5ea6fe630"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a52e0fa346a069ff55aa36df5ea6fe630">add</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v)</td></tr>
<tr class="separator:a52e0fa346a069ff55aa36df5ea6fe630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0f0d313b39dc576646fe6b493d158b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#afe0f0d313b39dc576646fe6b493d158b">subtract</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v)</td></tr>
<tr class="separator:afe0f0d313b39dc576646fe6b493d158b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d6387f69944fb7fcd76f2f11ec8ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a52d6387f69944fb7fcd76f2f11ec8ccb">multiply</a> (float scalar)</td></tr>
<tr class="separator:a52d6387f69944fb7fcd76f2f11ec8ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dfc881e0e6937b67588cdf5f16f7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab6dfc881e0e6937b67588cdf5f16f7c3">multiply</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff)</td></tr>
<tr class="separator:ab6dfc881e0e6937b67588cdf5f16f7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc06d785c74d017b9816e35dbacd615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a8fc06d785c74d017b9816e35dbacd615">invert</a> ()</td></tr>
<tr class="separator:a8fc06d785c74d017b9816e35dbacd615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35415e1246f5ae94a17cbf1346cfbf2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a35415e1246f5ae94a17cbf1346cfbf2f">getInverse</a> () const </td></tr>
<tr class="separator:a35415e1246f5ae94a17cbf1346cfbf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca81f9ee3ba6692aea6beccd27303972"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aca81f9ee3ba6692aea6beccd27303972">operator+=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v)</td></tr>
<tr class="separator:aca81f9ee3ba6692aea6beccd27303972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90669e49f3fe8aa7a57f40b5d08f7846"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a90669e49f3fe8aa7a57f40b5d08f7846">operator-=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v)</td></tr>
<tr class="separator:a90669e49f3fe8aa7a57f40b5d08f7846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbc0227e613c4aeab18712a5bafda68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1dbc0227e613c4aeab18712a5bafda68">operator*=</a> (float scalar)</td></tr>
<tr class="separator:a1dbc0227e613c4aeab18712a5bafda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44980076db2f8ce759ed8faa8e3cd765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a44980076db2f8ce759ed8faa8e3cd765">operator*=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff)</td></tr>
<tr class="separator:a44980076db2f8ce759ed8faa8e3cd765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cb204005a006435b1eb92b88f6b6ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a25cb204005a006435b1eb92b88f6b6ec">operator+</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v) const </td></tr>
<tr class="separator:a25cb204005a006435b1eb92b88f6b6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dd8b62004051346771bb8a1fe29dd6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a09dd8b62004051346771bb8a1fe29dd6">operator-</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v) const </td></tr>
<tr class="separator:a09dd8b62004051346771bb8a1fe29dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2f03c3b3ac54bdd37a65f1b6b125d5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7b2f03c3b3ac54bdd37a65f1b6b125d5">operator*</a> (float scalar) const </td></tr>
<tr class="separator:a7b2f03c3b3ac54bdd37a65f1b6b125d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2cebe32336ef78efd0f3a0f32a9d42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7f2cebe32336ef78efd0f3a0f32a9d42">operator*</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const </td></tr>
<tr class="separator:a7f2cebe32336ef78efd0f3a0f32a9d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09095ce7e82e05d8af4090935191ee88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a09095ce7e82e05d8af4090935191ee88">isExactly</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const </td></tr>
<tr class="separator:a09095ce7e82e05d8af4090935191ee88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cfb3d5376f85394be73e618398afc5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a16cfb3d5376f85394be73e618398afc5">equals</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat, float variance=CU_MATH_EPSILON) const </td></tr>
<tr class="separator:a16cfb3d5376f85394be73e618398afc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1126fc549bdeaf63a9ae5a165c41605c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1126fc549bdeaf63a9ae5a165c41605c">operator==</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const </td></tr>
<tr class="separator:a1126fc549bdeaf63a9ae5a165c41605c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0365bfd9575c6800749e284c1ad9ef9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0365bfd9575c6800749e284c1ad9ef9f">operator!=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const </td></tr>
<tr class="separator:a0365bfd9575c6800749e284c1ad9ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f12254a6a6eee7993ececc7461440c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a47f12254a6a6eee7993ececc7461440c">isIdentity</a> (float variance=0.0f) const </td></tr>
<tr class="separator:a47f12254a6a6eee7993ececc7461440c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d84a23d1adbc9c1f72097547bb627f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a18d84a23d1adbc9c1f72097547bb627f">isInvertible</a> (float variance=CU_MATH_EPSILON) const </td></tr>
<tr class="separator:a18d84a23d1adbc9c1f72097547bb627f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d2e130651e80c5029f9188ab62e9a1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a02d2e130651e80c5029f9188ab62e9a1">getDeterminant</a> () const </td></tr>
<tr class="separator:a02d2e130651e80c5029f9188ab62e9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9c28468d4f2fc0181369249e4f5b9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a3b9c28468d4f2fc0181369249e4f5b9d">getScale</a> () const </td></tr>
<tr class="separator:a3b9c28468d4f2fc0181369249e4f5b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5113aacd39e0af552f37b154ce8b11"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#afb5113aacd39e0af552f37b154ce8b11">getRotation</a> () const </td></tr>
<tr class="separator:afb5113aacd39e0af552f37b154ce8b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfb7d0276f5436f725d660fc0ad3fc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aecfb7d0276f5436f725d660fc0ad3fc0">getTranslation</a> () const </td></tr>
<tr class="separator:aecfb7d0276f5436f725d660fc0ad3fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af48a832fe8e9a23e3f3141e23dbf65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a8af48a832fe8e9a23e3f3141e23dbf65">transform</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point) const </td></tr>
<tr class="separator:a8af48a832fe8e9a23e3f3141e23dbf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a0eb88e2a06ec1f4f1124f0dec40ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a67a0eb88e2a06ec1f4f1124f0dec40ba">transform</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect) const </td></tr>
<tr class="separator:a67a0eb88e2a06ec1f4f1124f0dec40ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9023ae447cea2fd1c1d3db512f6ea437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9023ae447cea2fd1c1d3db512f6ea437">rotate</a> (float angle)</td></tr>
<tr class="separator:a9023ae447cea2fd1c1d3db512f6ea437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6174a8cc971ac1ddddb4f83be35f7328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a6174a8cc971ac1ddddb4f83be35f7328">scale</a> (float value)</td></tr>
<tr class="separator:a6174a8cc971ac1ddddb4f83be35f7328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05004a3bfb113d59fdcf459c68acb050"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a05004a3bfb113d59fdcf459c68acb050">scale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;s)</td></tr>
<tr class="separator:a05004a3bfb113d59fdcf459c68acb050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0c20b4ee6f8ca381dcd51a82d0f5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9bc0c20b4ee6f8ca381dcd51a82d0f5c">scale</a> (float sx, float sy)</td></tr>
<tr class="separator:a9bc0c20b4ee6f8ca381dcd51a82d0f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084648d017fab0998081fa24e6a0da86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a084648d017fab0998081fa24e6a0da86">translate</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;t)</td></tr>
<tr class="separator:a084648d017fab0998081fa24e6a0da86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e30c145c1d2ec95c052f3154d6f1b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7e30c145c1d2ec95c052f3154d6f1b8f">translate</a> (float tx, float ty)</td></tr>
<tr class="separator:a7e30c145c1d2ec95c052f3154d6f1b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ba53e7d1e496ab116623d436840589"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a07ba53e7d1e496ab116623d436840589">toString</a> (bool verbose=false) const </td></tr>
<tr class="separator:a07ba53e7d1e496ab116623d436840589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844dc0b9067f5bc9d35b4a31ec853bdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a844dc0b9067f5bc9d35b4a31ec853bdb">operator std::string</a> () const </td></tr>
<tr class="separator:a844dc0b9067f5bc9d35b4a31ec853bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7235e7d4ffa055419cac609345029a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5a7235e7d4ffa055419cac609345029a">operator Mat4</a> () const </td></tr>
<tr class="separator:a5a7235e7d4ffa055419cac609345029a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3937a566d4aaf041696762ea42fd1d8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a3937a566d4aaf041696762ea42fd1d8b">Affine2</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a3937a566d4aaf041696762ea42fd1d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ae7869d91de19cba43df15791eb41a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a51ae7869d91de19cba43df15791eb41a">operator=</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a51ae7869d91de19cba43df15791eb41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e77b5955070cae1f4d600f1dd4ced53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0e77b5955070cae1f4d600f1dd4ced53">set</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a0e77b5955070cae1f4d600f1dd4ced53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23842cc46b2e7a76da1ac8315619971c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a23842cc46b2e7a76da1ac8315619971c">createScale</a> (float <a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>)</td></tr>
<tr class="separator:a23842cc46b2e7a76da1ac8315619971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59af20c78d7c7ec908416318a81df573"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a59af20c78d7c7ec908416318a81df573">createScale</a> (float <a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a59af20c78d7c7ec908416318a81df573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f4b086e6609b38ce884a4da147ee90"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a59f4b086e6609b38ce884a4da147ee90">createScale</a> (float sx, float sy)</td></tr>
<tr class="separator:a59f4b086e6609b38ce884a4da147ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada60bbed63d4ffaca69e1d0932ab451a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ada60bbed63d4ffaca69e1d0932ab451a">createScale</a> (float sx, float sy, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ada60bbed63d4ffaca69e1d0932ab451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7d5c6d750a1a23fe68faf189e760bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a2a7d5c6d750a1a23fe68faf189e760bb">createScale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;<a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>)</td></tr>
<tr class="separator:a2a7d5c6d750a1a23fe68faf189e760bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6090d7fe5706b11db6a116cf89a733aa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a6090d7fe5706b11db6a116cf89a733aa">createScale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;<a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a6090d7fe5706b11db6a116cf89a733aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49295f3f20239c8a2f5ac12a34aeffa5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a49295f3f20239c8a2f5ac12a34aeffa5">createRotation</a> (float angle)</td></tr>
<tr class="separator:a49295f3f20239c8a2f5ac12a34aeffa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab409739c8248a4e06b3e567821e295a7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab409739c8248a4e06b3e567821e295a7">createRotation</a> (float angle, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ab409739c8248a4e06b3e567821e295a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdd3b380a46dddce27fe47de8459ff6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5bdd3b380a46dddce27fe47de8459ff6">createTranslation</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;trans)</td></tr>
<tr class="separator:a5bdd3b380a46dddce27fe47de8459ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0107492d48a25d0a7e1ee56d5490c4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aa0107492d48a25d0a7e1ee56d5490c4a">createTranslation</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;trans, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:aa0107492d48a25d0a7e1ee56d5490c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9751801bb4f8f79f70aae42f2307d9b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9751801bb4f8f79f70aae42f2307d9b0">createTranslation</a> (float tx, float ty)</td></tr>
<tr class="separator:a9751801bb4f8f79f70aae42f2307d9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e249b90f0cf2bc2ec89084cfee46c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a72e249b90f0cf2bc2ec89084cfee46c6">createTranslation</a> (float tx, float ty, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a72e249b90f0cf2bc2ec89084cfee46c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f704d878f83a22e6eb5116bb57d45de"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0f704d878f83a22e6eb5116bb57d45de">add</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;<a class="el" href="classcugl_1_1_affine2.html#afbcdf67d85ed604e3cbf7d02b9902f1e">m</a>, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a0f704d878f83a22e6eb5116bb57d45de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a68da32331303689795e4c867b00e50"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a8a68da32331303689795e4c867b00e50">subtract</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m1, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;v, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a8a68da32331303689795e4c867b00e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0b39bc452cc3747a59171ab342741f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0a0b39bc452cc3747a59171ab342741f">multiply</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat, float scalar, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a0a0b39bc452cc3747a59171ab342741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad400dddda62cc2a1eef110ae980a52d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ad400dddda62cc2a1eef110ae980a52d3">multiply</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m1, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m2, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ad400dddda62cc2a1eef110ae980a52d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a21fb146cc2fd4a9904cfe011cb667c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5a21fb146cc2fd4a9904cfe011cb667c">invert</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m1, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a5a21fb146cc2fd4a9904cfe011cb667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8d1d512e57f813fd015d4063d4021c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a3a8d1d512e57f813fd015d4063d4021c">transform</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *dst)</td></tr>
<tr class="separator:a3a8d1d512e57f813fd015d4063d4021c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efffd0f43fadfa39ba22a925c76674e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_rect.html">Rect</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9efffd0f43fadfa39ba22a925c76674e">transform</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect, <a class="el" href="classcugl_1_1_rect.html">Rect</a> *dst)</td></tr>
<tr class="separator:a9efffd0f43fadfa39ba22a925c76674e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93a31399d061455211ac38aa0df509b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab93a31399d061455211ac38aa0df509b">rotate</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float angle, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ab93a31399d061455211ac38aa0df509b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7227ee03e3435e83e02420c9ae316bf2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float value, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a7227ee03e3435e83e02420c9ae316bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f817cc5adc1a1d87a6eb70c6ab5e78a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a6f817cc5adc1a1d87a6eb70c6ab5e78a">scale</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;s, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a6f817cc5adc1a1d87a6eb70c6ab5e78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117a0e82c455b939cb393032e1a1cfb7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a117a0e82c455b939cb393032e1a1cfb7">scale</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float sx, float sy, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a117a0e82c455b939cb393032e1a1cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbf60cd0f26a51e8386cc5bc054600b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1cbf60cd0f26a51e8386cc5bc054600b">translate</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;t, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a1cbf60cd0f26a51e8386cc5bc054600b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a88b03c8c38cb2f6fd611edfa7346d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#af8a88b03c8c38cb2f6fd611edfa7346d">translate</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float tx, float ty, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:af8a88b03c8c38cb2f6fd611edfa7346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1dbcda358f9544e9d4d7c9be16b20e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1c1dbcda358f9544e9d4d7c9be16b20e">decompose</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *<a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>, float *rot, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *trans)</td></tr>
<tr class="separator:a1c1dbcda358f9544e9d4d7c9be16b20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:afbcdf67d85ed604e3cbf7d02b9902f1e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#afbcdf67d85ed604e3cbf7d02b9902f1e">m</a> [4]</td></tr>
<tr class="separator:afbcdf67d85ed604e3cbf7d02b9902f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41227880aa39a39faca7ab14051dc37b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a41227880aa39a39faca7ab14051dc37b">offset</a></td></tr>
<tr class="separator:a41227880aa39a39faca7ab14051dc37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae026a9986f11addd15e11f4c2529cef7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ae026a9986f11addd15e11f4c2529cef7">ZERO</a></td></tr>
<tr class="separator:ae026a9986f11addd15e11f4c2529cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d528a1f040fa2769cf93d1b8ef58dc"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a89d528a1f040fa2769cf93d1b8ef58dc">ONE</a></td></tr>
<tr class="separator:a89d528a1f040fa2769cf93d1b8ef58dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdf7abfee94c17467aac4ee96610917"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aefdf7abfee94c17467aac4ee96610917">IDENTITY</a></td></tr>
<tr class="separator:aefdf7abfee94c17467aac4ee96610917"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class defines an affine transform on 2D space.</p>
<p>In the case where you are only manipulating 2D points, this class may be faster than <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>, even with the vectorization support. For an affine transform in 3d space, use <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>.</p>
<p>The affine transform is stored as a 4-element array (containing the core matrix, plus a <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset. Keeping with the convention of <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>, the core matrix is stored in column-order format. In addition, we assume that all operations are multiplied on the right. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a4b8cdc57a2fefbe3b701bd13b1b9c8c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the identity transform. </p><pre class="fragment">1  0
0  1 + (0,0)</pre> 
</div>
</div>
<a class="anchor" id="aab97798b85f16c036eea8f5902f64853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a matrix initialized to the specified values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m11</td><td>The first element of the first row. </td></tr>
    <tr><td class="paramname">m12</td><td>The second element of the first row. </td></tr>
    <tr><td class="paramname">m21</td><td>The first element of the second row. </td></tr>
    <tr><td class="paramname">m22</td><td>The second element of the second row. </td></tr>
    <tr><td class="paramname">tx</td><td>The translation offset for the x-coordinate. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adec4e6f35e898ccd5846066e25eb0d38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a matrix initialized to the specified column-major array.</p>
<p>The passed-in array is in column-major order, with the last two elements being the translation offset. Hence the memory layout of the array is as follows: </p><pre class="fragment">0   2
1   3 + (4,5)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>An array containing 6 elements in column-major order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f2a28b046f97e022fd688d0850179e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new transform that is the copy of the specified one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>The transform to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a641ade00a492018865a14b382afc870d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new transform that contains the resources of the specified one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>The transform contributing resources. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a25af9673fe7343a4989130f2227fabf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::~Affine2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys this transform, releasing all resources. </p>

</div>
</div>
<a class="anchor" id="a3937a566d4aaf041696762ea42fd1d8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an affine transform from the given matrix.</p>
<p>The z values are all uniformly ignored. However, it the final element of the matrix is not 1 (e.g. the translation has a w value of 1), then it divides the entire matrix before creating the affine transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a0f704d878f83a22e6eb5116bb57d45de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the specified offset to the given and stores the result in dst.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The initial transform. </td></tr>
    <tr><td class="paramname">v</td><td>The offset to add. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a52e0fa346a069ff55aa36df5ea6fe630"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the specified offset to this transform.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after addition. </dd></dl>

</div>
</div>
<a class="anchor" id="a49295f3f20239c8a2f5ac12a34aeffa5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createRotation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a rotation transform for the given angle.</p>
<p>The angle measurement is in radians. The rotation is counter clockwise about the z-axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a rotation transform for the given angle. </dd></dl>

</div>
</div>
<a class="anchor" id="ab409739c8248a4e06b3e567821e295a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createRotation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a rotation transform for the given angle, putting it in dst.</p>
<p>The angle measurement is in radians. The rotation is counter clockwise about the z-axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle (in radians). </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a23842cc46b2e7a76da1ac8315619971c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a uniform scale transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The amount to scale.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uniform scale transform. </dd></dl>

</div>
</div>
<a class="anchor" id="a59af20c78d7c7ec908416318a81df573"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a uniform scale transform, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The amount to scale. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a59f4b086e6609b38ce884a4da147ee90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a nonuniform scale transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nonuniform scale transform. </dd></dl>

</div>
</div>
<a class="anchor" id="ada60bbed63d4ffaca69e1d0932ab451a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a nonuniform scale transform, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a2a7d5c6d750a1a23fe68faf189e760bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a nonuniform scale transform from the given vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The nonuniform scale value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nonuniform scale transform from the given vector. </dd></dl>

</div>
</div>
<a class="anchor" id="a6090d7fe5706b11db6a116cf89a733aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a nonuniform scale transform from the given vector, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The nonuniform scale value. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a5bdd3b380a46dddce27fe47de8459ff6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a translation transform from the given offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trans</td><td>The translation offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a translation transform from the given offset </dd></dl>

</div>
</div>
<a class="anchor" id="aa0107492d48a25d0a7e1ee56d5490c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a translation transform from the given offset, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trans</td><td>The translation offset. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a9751801bb4f8f79f70aae42f2307d9b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a translation transform from the given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The translation on the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation on the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a translation transform from the given parameters. </dd></dl>

</div>
</div>
<a class="anchor" id="a72e249b90f0cf2bc2ec89084cfee46c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a translation transform from the given parameters, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The translation on the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation on the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a1c1dbcda358f9544e9d4d7c9be16b20e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cugl::Affine2::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes the scale, rotation and translation components of the given matrix.</p>
<p>To work properly, the matrix must have been constructed in the following order: scale, then rotate, then translation. While the rotation matrix will always be correct, the scale and translation are not guaranteed to be correct.</p>
<p>If any pointer is null, the method simply does not assign that result. However, it will still continue to compute the component with non-null vectors to store the result.</p>
<p>If the scale component is too small, then it may be impossible to extract the rotation. In that case, if the rotation pointer is not null, this method will return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to decompose. </td></tr>
    <tr><td class="paramname">scale</td><td>The scale component. </td></tr>
    <tr><td class="paramname">rot</td><td>The rotation component. </td></tr>
    <tr><td class="paramname">trans</td><td>The translation component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all requested components were properly extracted </dd></dl>

</div>
</div>
<a class="anchor" id="a16cfb3d5376f85394be73e618398afc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>CU_MATH_EPSILON</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the transforms are within tolerance of each other.</p>
<p>The tolerance is applied to each element of the transform individually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to compare against. </td></tr>
    <tr><td class="paramname">variance</td><td>The comparison tolerance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transforms are within tolerance of each other. </dd></dl>

</div>
</div>
<a class="anchor" id="a02d2e130651e80c5029f9188ab62e9a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Affine2::getDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the determinant of this transform.</p>
<p>The determinant is a feature of the core matrix. The offset is ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>the determinant of this transform. </dd></dl>

</div>
</div>
<a class="anchor" id="a35415e1246f5ae94a17cbf1346cfbf2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::getInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the inverse of this transform.</p>
<p>If the transform cannot be inverted, this method returns the zero transform.</p>
<p>Note: This does not modify the transform.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the inverse of this transform. </dd></dl>

</div>
</div>
<a class="anchor" id="afb5113aacd39e0af552f37b154ce8b11"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Affine2::getRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rotational angle of this transform.</p>
<p>If the scale component is too close to zero, we cannot extract the rotation. In that case, we return the zero angle. ( </p><dl class="section return"><dt>Returns</dt><dd>the rotational angle of this transform. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b9c28468d4f2fc0181369249e4f5b9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Affine2::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the scale component of this transform.</p>
<p>If the scale component of this matrix has negative parts, it is not possible to always extract the exact scalar component. In that case, a scale vector that is mathematically equivalent to the original scale vector is extracted and returned.</p>
<p>To work properly, the transform must have been constructed in the following order: scale, then rotate, then translation. In any other order, the scale is not guaranteed to be correct.</p>
<dl class="section return"><dt>Returns</dt><dd>the scale component of this transform. </dd></dl>

</div>
</div>
<a class="anchor" id="aecfb7d0276f5436f725d660fc0ad3fc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Affine2::getTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the translational component of this transform.</p>
<p>To work properly, the transform must have been constructed in the following order: scale, then rotate, then translation. In any other order, the translation is not guaranteed to be correct.</p>
<dl class="section return"><dt>Returns</dt><dd>the translational component of this transform. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a21fb146cc2fd4a9904cfe011cb667c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts m1 and stores the result in dst.</p>
<p>If the transform cannot be inverted, this method stores the zero transform in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The transform to negate. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a8fc06d785c74d017b9816e35dbacd615"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts this transform in place.</p>
<p>If the transform cannot be inverted, this method sets it to the zero transform.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after the inversion. </dd></dl>

</div>
</div>
<a class="anchor" id="a09095ce7e82e05d8af4090935191ee88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::isExactly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the transforms are exactly equal to each other.</p>
<p>This method may be unreliable given that the elements are floats. It should only be used to compared transform that have not undergone a lot of manipulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transforms are exactly equal to each other. </dd></dl>

</div>
</div>
<a class="anchor" id="a47f12254a6a6eee7993ececc7461440c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::isIdentity </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>0.0f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this transform is equal to the identity transform.</p>
<p>The optional comparison tolerance takes into accout that elements are floats and this may not be exact. The tolerance is applied to each element individually. By default, the match must be exact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variance</td><td>The comparison tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is equal to the identity transform. </dd></dl>

</div>
</div>
<a class="anchor" id="a18d84a23d1adbc9c1f72097547bb627f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::isInvertible </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>CU_MATH_EPSILON</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this transform is invertible.</p>
<p>The optional comparison tolerance takes into accout that elements are floats and this may not be exact. The tolerance is applied to the determinant of the core matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is invertible. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a0b39bc452cc3747a59171ab342741f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the specified transform by a scalar and stores the result in dst.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform. </td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar value. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="ad400dddda62cc2a1eef110ae980a52d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies m1 by the transform m2 and stores the result in dst.</p>
<p>Transform multiplication is defined as standard function composition. The transform m2 is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first transform to multiply. </td></tr>
    <tr><td class="paramname">m2</td><td>The second transform to multiply. </td></tr>
    <tr><td class="paramname">dst</td><td>A matrix to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a52d6387f69944fb7fcd76f2f11ec8ccb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the components of this transform by the specified scalar.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after multiplication. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6dfc881e0e6937b67588cdf5f16f7c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies this matrix by the specified one.</p>
<p>Transform multiplication is defined as standard function composition. The transform m2 is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to multiply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after multiplication. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a7235e7d4ffa055419cac609345029a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::operator <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cast from <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> to a <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>. </p>

</div>
</div>
<a class="anchor" id="a844dc0b9067f5bc9d35b4a31ec853bdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> to a string. </p>

</div>
</div>
<a class="anchor" id="a0365bfd9575c6800749e284c1ad9ef9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this transform is not equal to the given transform.</p>
<p>Comparison is exact, which may be unreliable given that the elements are floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is not equal to the given transform. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b2f03c3b3ac54bdd37a65f1b6b125d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of this matrix with all elements multiplied by the scalar.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<p>Note: This does not modify the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of this transform with the given scalar. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f2cebe32336ef78efd0f3a0f32a9d42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix product of this matrix with the given matrix.</p>
<p>Transform multiplication is defined as standard function composition. The transform aff is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<p>Note: This does not modify the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix product of this matrix with the given matrix. </dd></dl>

</div>
</div>
<a class="anchor" id="a1dbc0227e613c4aeab18712a5bafda68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator*= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the components of this transform by the specified scalar.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a44980076db2f8ce759ed8faa8e3cd765"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Right-multiplies this transform by the given transform.</p>
<p>Transform multiplication is defined as standard function composition. The transform aff is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a25cb204005a006435b1eb92b88f6b6ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the sum of this transform with the given offset.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<p>Note: This does not modify the transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of this transform with the given offset. </dd></dl>

</div>
</div>
<a class="anchor" id="aca81f9ee3ba6692aea6beccd27303972"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given offset to this transform in place.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a09dd8b62004051346771bb8a1fe29dd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the difference of this matrix with the given offset.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<p>Note: This does not modify the transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of this transform and the given offset. </dd></dl>

</div>
</div>
<a class="anchor" id="a90669e49f3fe8aa7a57f40b5d08f7846"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the given offset from this transform in place.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to subtract</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="accc78fab6e7925504813d05d8133b35b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those in the specified transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a6488ba992de5a72c48523724cb1f30d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the elements of this matrix to those in the specified one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to take resources from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8d463f5418645f7b54ae1ea46951e95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the values of this transform to those in the specified column-major array.</p>
<p>The passed-in array is in column-major order, with the last two elements being the translation offset. Hence the memory layout of the array is as follows: </p><pre class="fragment">0   2
1   3 + (4,5)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>An array containing 6 elements in column-major order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a51ae7869d91de19cba43df15791eb41a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those of the given matrix.</p>
<p>The z values are all uniformly ignored. However, it the final element of the matrix is not 1 (e.g. the translation has a w value of 1), then it divides the entire matrix before creating the affine transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a1126fc549bdeaf63a9ae5a165c41605c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this transform is equal to the given transform.</p>
<p>Comparison is exact, which may be unreliable given that the elements are floats. It should only be used to compared transform that have not undergone a lot of manipulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is equal to the given transform. </dd></dl>

</div>
</div>
<a class="anchor" id="ab93a31399d061455211ac38aa0df509b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a rotation to the given transform and stores the result in dst.</p>
<p>The rotation is in radians, counter-clockwise about the z-axis.</p>
<p>The rotation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to rotate. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle (in radians). </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a9023ae447cea2fd1c1d3db512f6ea437"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::rotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a rotation to this transform.</p>
<p>The rotation is in radians, counter-clockwise about the given axis.</p>
<p>The rotation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after rotation. </dd></dl>

</div>
</div>
<a class="anchor" id="a7227ee03e3435e83e02420c9ae316bf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a uniform scale to the given transform and stores the result in dst.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale. </td></tr>
    <tr><td class="paramname">value</td><td>The scalar to multiply by. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a6f817cc5adc1a1d87a6eb70c6ab5e78a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to the given transform and stores the result in dst.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale. </td></tr>
    <tr><td class="paramname">s</td><td>The vector storing the individual scaling factors </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a117a0e82c455b939cb393032e1a1cfb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to the given transform and stores the result in dst.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale. </td></tr>
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a6174a8cc971ac1ddddb4f83be35f7328"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a uniform scale to this transform.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after scaling. </dd></dl>

</div>
</div>
<a class="anchor" id="a05004a3bfb113d59fdcf459c68acb050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to this transform.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The vector storing the individual scaling factors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after scaling. </dd></dl>

</div>
</div>
<a class="anchor" id="a9bc0c20b4ee6f8ca381dcd51a82d0f5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to this transform.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after scaling. </dd></dl>

</div>
</div>
<a class="anchor" id="afccaf334303ae3e95b208b9af65d328e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the individal values of this transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m11</td><td>The first element of the first row. </td></tr>
    <tr><td class="paramname">m12</td><td>The second element of the first row. </td></tr>
    <tr><td class="paramname">m21</td><td>The first element of the second row. </td></tr>
    <tr><td class="paramname">m22</td><td>The second element of the second row. </td></tr>
    <tr><td class="paramname">tx</td><td>The translation offset for the x-coordinate. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-coordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="af278299eff6733d7c28199aca350fc3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the values of this transform to those in the specified column-major array.</p>
<p>The passed-in array is in column-major order, with the last two elements being the translation offset. Hence the memory layout of the array is as follows: </p><pre class="fragment">0   2
1   3 + (4,5)
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>An array containing 6 elements in column-major order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="add02033567fa0f676563557c689e5039"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those in the specified transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e77b5955070cae1f4d600f1dd4ced53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those of the given matrix.</p>
<p>The z values are all uniformly ignored. However, it the final element of the matrix is not 1 (e.g. the translation has a w value of 1), then it divides the entire matrix before creating the affine transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="acd01e54686c9af28b75ccd200cfd3dd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this transform to the identity transform.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="adc6f551ca7edcaecaad777b2811d7c82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::setZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all elements of the current transform to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a68da32331303689795e4c867b00e50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the offset v from m and stores the result in dst.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The initial transform. </td></tr>
    <tr><td class="paramname">v</td><td>The offset to subtract. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="afe0f0d313b39dc576646fe6b493d158b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the specified offset from the current transform.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after subtraction. </dd></dl>

</div>
</div>
<a class="anchor" id="a07ba53e7d1e496ab116623d436840589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Affine2::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representation of this transform for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this transform for debugging purposes. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a8d1d512e57f813fd015d4063d4021c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>* cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the point and stores the result in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The affine transform. </td></tr>
    <tr><td class="paramname">point</td><td>The point to transform. </td></tr>
    <tr><td class="paramname">dst</td><td>A vector to store the transformed point in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a9efffd0f43fadfa39ba22a925c76674e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_rect.html">Rect</a>* cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_rect.html">Rect</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the rectangle and stores the result in dst.</p>
<p>This method transforms the four defining points of the rectangle. It then computes the minimal bounding box storing these four points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The affine transform. </td></tr>
    <tr><td class="paramname">rect</td><td>The rect to transform. </td></tr>
    <tr><td class="paramname">dst</td><td>A rect to store the transformed rectangle in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a8af48a832fe8e9a23e3f3141e23dbf65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the given point transformed.</p>
<p>Note: This does not modify the original point. To transform a point in place, use the static method (or the appropriate operator).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this point transformed. </dd></dl>

</div>
</div>
<a class="anchor" id="a67a0eb88e2a06ec1f4f1124f0dec40ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the given rectangle transformed.</p>
<p>This method transforms the four defining points of the rectangle. It then computes the minimal bounding box storing these four points</p>
<p>Note: This does not modify the original rectangle. To transform a point in place, use the static method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a1cbf60cd0f26a51e8386cc5bc054600b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to the given transform and stores the result in dst.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to translate. </td></tr>
    <tr><td class="paramname">t</td><td>The vector storing the individual translation offsets </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="af8a88b03c8c38cb2f6fd611edfa7346d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to the given transform and stores the result in dst.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to translate. </td></tr>
    <tr><td class="paramname">tx</td><td>The translation offset for the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a084648d017fab0998081fa24e6a0da86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to this transform.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The vector storing the individual translation offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after translation. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e30c145c1d2ec95c052f3154d6f1b8f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to this transform.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The translation offset for the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after translation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="aefdf7abfee94c17467aac4ee96610917"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::IDENTITY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The identity transform (ones on the diagonal) </p>

</div>
</div>
<a class="anchor" id="afbcdf67d85ed604e3cbf7d02b9902f1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Affine2::m[4]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The core matrix </p>

</div>
</div>
<a class="anchor" id="a41227880aa39a39faca7ab14051dc37b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Affine2::offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The translation offset </p>

</div>
</div>
<a class="anchor" id="a89d528a1f040fa2769cf93d1b8ef58dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::ONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The transform with all ones </p>

</div>
</div>
<a class="anchor" id="ae026a9986f11addd15e11f4c2529cef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::ZERO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The transform with all zeroes </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/<a class="el" href="_c_u_affine2_8h_source.html">CUAffine2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

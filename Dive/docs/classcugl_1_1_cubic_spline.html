<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::CubicSpline Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcugl_1_1_cubic_spline-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::CubicSpline Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_cubic_spline_8h_source.html">CUCubicSpline.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a66300a78ac70b538151d271a2fe1e969"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a66300a78ac70b538151d271a2fe1e969">CubicSpline</a> ()</td></tr>
<tr class="separator:a66300a78ac70b538151d271a2fe1e969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2f09055d2a6d98c3e393c10c9ff0fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a4a2f09055d2a6d98c3e393c10c9ff0fb">CubicSpline</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point)</td></tr>
<tr class="separator:a4a2f09055d2a6d98c3e393c10c9ff0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae48d0fe717586297c375c9c2fda2a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a4ae48d0fe717586297c375c9c2fda2a7">CubicSpline</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;start, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;end)</td></tr>
<tr class="separator:a4ae48d0fe717586297c375c9c2fda2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a85a04d32d92948725d0a3222469af4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a3a85a04d32d92948725d0a3222469af4">CubicSpline</a> (const float *points, int size, int offset=0)</td></tr>
<tr class="separator:a3a85a04d32d92948725d0a3222469af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871ad1026047658bb41ddc60c6ed7679"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a871ad1026047658bb41ddc60c6ed7679">CubicSpline</a> (const std::vector&lt; float &gt; &amp;points)</td></tr>
<tr class="separator:a871ad1026047658bb41ddc60c6ed7679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35348b573a2a219b4cdcd939a7bcc49b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a35348b573a2a219b4cdcd939a7bcc49b">CubicSpline</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;points)</td></tr>
<tr class="separator:a35348b573a2a219b4cdcd939a7bcc49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8a0394caf57307b38111d54d9da9ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a5c8a0394caf57307b38111d54d9da9ee">CubicSpline</a> (const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;spline)</td></tr>
<tr class="separator:a5c8a0394caf57307b38111d54d9da9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfb63fe6d948da346cce939fb69fbdd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a3cfb63fe6d948da346cce939fb69fbdd">CubicSpline</a> (<a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&amp;spline)</td></tr>
<tr class="separator:a3cfb63fe6d948da346cce939fb69fbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49156b0aa5fe73b5788b7f73acd61706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a49156b0aa5fe73b5788b7f73acd61706">~CubicSpline</a> ()</td></tr>
<tr class="separator:a49156b0aa5fe73b5788b7f73acd61706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfb7180956127436344d64ec88a494d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#abbfb7180956127436344d64ec88a494d">operator=</a> (const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;spline)</td></tr>
<tr class="separator:abbfb7180956127436344d64ec88a494d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c760337ac8091fc79e2a50c0c6c99f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#af4c760337ac8091fc79e2a50c0c6c99f">operator=</a> (<a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&amp;spline)</td></tr>
<tr class="separator:af4c760337ac8091fc79e2a50c0c6c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3182e39fde8e03519a145acf8d77c4e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a3182e39fde8e03519a145acf8d77c4e4">set</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point)</td></tr>
<tr class="separator:a3182e39fde8e03519a145acf8d77c4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2724a98a9a3b919ff0661c9d904222e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#ac2724a98a9a3b919ff0661c9d904222e">set</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;start, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;end)</td></tr>
<tr class="separator:ac2724a98a9a3b919ff0661c9d904222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc49128a54fe254ec274bc554be1f8c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#acc49128a54fe254ec274bc554be1f8c3">set</a> (const float *points, int size, int offset=0)</td></tr>
<tr class="separator:acc49128a54fe254ec274bc554be1f8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903d4417ac1ec0bd23adbb991c43da50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a903d4417ac1ec0bd23adbb991c43da50">set</a> (const std::vector&lt; float &gt; &amp;points)</td></tr>
<tr class="separator:a903d4417ac1ec0bd23adbb991c43da50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210335b145ef7a141a13f4c58bf18a04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a210335b145ef7a141a13f4c58bf18a04">set</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;points)</td></tr>
<tr class="separator:a210335b145ef7a141a13f4c58bf18a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b60597e9895db55ff11e08d0423e27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a28b60597e9895db55ff11e08d0423e27">set</a> (const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;spline)</td></tr>
<tr class="separator:a28b60597e9895db55ff11e08d0423e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906957a5dae1359ee55c954901176263"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a906957a5dae1359ee55c954901176263">getSize</a> () const </td></tr>
<tr class="separator:a906957a5dae1359ee55c954901176263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa377a94397af19dfb6f4cbcfbd3bd0c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#aa377a94397af19dfb6f4cbcfbd3bd0c2">isClosed</a> () const </td></tr>
<tr class="separator:aa377a94397af19dfb6f4cbcfbd3bd0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320c9c6ba4f547b2c2e0025657faec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#af320c9c6ba4f547b2c2e0025657faec5">setClosed</a> (bool flag)</td></tr>
<tr class="separator:af320c9c6ba4f547b2c2e0025657faec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497db563b348234bf427d8a907f2335a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a497db563b348234bf427d8a907f2335a">getPoint</a> (float tp) const </td></tr>
<tr class="separator:a497db563b348234bf427d8a907f2335a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58a96ba86b40855817d9762f4525f46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#ac58a96ba86b40855817d9762f4525f46">setPoint</a> (float tp, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point)</td></tr>
<tr class="separator:ac58a96ba86b40855817d9762f4525f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b00b23de37c6568a754a25341368d67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a2b00b23de37c6568a754a25341368d67">getAnchor</a> (int index) const </td></tr>
<tr class="separator:a2b00b23de37c6568a754a25341368d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb57a2bc7209bf71b9a32379318dc35e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#aeb57a2bc7209bf71b9a32379318dc35e">setAnchor</a> (int index, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point)</td></tr>
<tr class="separator:aeb57a2bc7209bf71b9a32379318dc35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c7f3c6ddf71be27f880f0b0af388ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#ab2c7f3c6ddf71be27f880f0b0af388ff">getSmooth</a> (int index) const </td></tr>
<tr class="separator:ab2c7f3c6ddf71be27f880f0b0af388ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eae43022ae09885c6b3c7acaa77389f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a8eae43022ae09885c6b3c7acaa77389f">setSmooth</a> (int index, bool flag)</td></tr>
<tr class="separator:a8eae43022ae09885c6b3c7acaa77389f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6f106995292f59879b1b3a09ce8632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a4e6f106995292f59879b1b3a09ce8632">getTangent</a> (int index) const </td></tr>
<tr class="separator:a4e6f106995292f59879b1b3a09ce8632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542b710c37d28aae05025f20c78fe7d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a542b710c37d28aae05025f20c78fe7d7">setTangent</a> (int index, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;tang, bool symmetric=false)</td></tr>
<tr class="separator:a542b710c37d28aae05025f20c78fe7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82230f1686189b6194c05dcaccfbeaa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a82230f1686189b6194c05dcaccfbeaa8">getPolynomialX</a> (int segment) const </td></tr>
<tr class="separator:a82230f1686189b6194c05dcaccfbeaa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4481cb0155204a9cef4c6ab8f38d93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a5d4481cb0155204a9cef4c6ab8f38d93">getPolynomialY</a> (int segment) const </td></tr>
<tr class="separator:a5d4481cb0155204a9cef4c6ab8f38d93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1642504eb154024f6e004e334dcb49"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#acc1642504eb154024f6e004e334dcb49">getControlPoints</a> () const </td></tr>
<tr class="separator:acc1642504eb154024f6e004e334dcb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b094c0831eedd4f855d4a77219912e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a46b094c0831eedd4f855d4a77219912e">addAnchor</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point)</td></tr>
<tr class="separator:a46b094c0831eedd4f855d4a77219912e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec48f04d193f34196b7f946d4c417bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a1ec48f04d193f34196b7f946d4c417bf">addAnchor</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;tang)</td></tr>
<tr class="separator:a1ec48f04d193f34196b7f946d4c417bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0b2223a3b3a52a0613499696048b93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#ace0b2223a3b3a52a0613499696048b93">deleteAnchor</a> (int index)</td></tr>
<tr class="separator:ace0b2223a3b3a52a0613499696048b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e1aeb290dbf55cc8abd7093ee83674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#aa8e1aeb290dbf55cc8abd7093ee83674">insertAnchor</a> (float param)</td></tr>
<tr class="separator:aa8e1aeb290dbf55cc8abd7093ee83674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362bbe2b15026048946347364dccdebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a362bbe2b15026048946347364dccdebc">clear</a> ()</td></tr>
<tr class="separator:a362bbe2b15026048946347364dccdebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d7068741767213276eb6882de5c10d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#ac4d7068741767213276eb6882de5c10d">nearestPoint</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point) const </td></tr>
<tr class="separator:ac4d7068741767213276eb6882de5c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd54526e2badc08d98283b2861978c9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#aecd54526e2badc08d98283b2861978c9">nearestParameter</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point) const </td></tr>
<tr class="separator:aecd54526e2badc08d98283b2861978c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84344c659341dcec5eda3c247967556f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a84344c659341dcec5eda3c247967556f">nearestAnchor</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, float threshold) const </td></tr>
<tr class="separator:a84344c659341dcec5eda3c247967556f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c611714a27deb6b4b05544ceff931e1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a0c611714a27deb6b4b05544ceff931e1">nearestTangent</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, float threshold) const </td></tr>
<tr class="separator:a0c611714a27deb6b4b05544ceff931e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a177951b29f319857e7497a7222e5b244"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a177951b29f319857e7497a7222e5b244">getPoint</a> (int segment, float tp) const </td></tr>
<tr class="separator:a177951b29f319857e7497a7222e5b244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fdab40b5c11e3f0ea2fcb9b206da5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#af1fdab40b5c11e3f0ea2fcb9b206da5c">insertAnchor</a> (int segment, float param)</td></tr>
<tr class="separator:af1fdab40b5c11e3f0ea2fcb9b206da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1931c156d19f2a0a469872dc1819918a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a1931c156d19f2a0a469872dc1819918a">subdivide</a> (int segment, float tp, std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;left, std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;rght) const </td></tr>
<tr class="separator:a1931c156d19f2a0a469872dc1819918a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29392b1dbba593c6f6ff984015ffe334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_polynomial.html">Polynomial</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a29392b1dbba593c6f6ff984015ffe334">getProjectionPolynomial</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, int segment) const </td></tr>
<tr class="separator:a29392b1dbba593c6f6ff984015ffe334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d1d81230a9dbf6c1b5b72e67ce1c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a42d1d81230a9dbf6c1b5b72e67ce1c46">getProjectionSlow</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, int segment) const </td></tr>
<tr class="separator:a42d1d81230a9dbf6c1b5b72e67ce1c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49426310aa1869951318f2f5e93be228"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#a49426310aa1869951318f2f5e93be228">getProjectionFast</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;point, int segment) const </td></tr>
<tr class="separator:a49426310aa1869951318f2f5e93be228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af00cf5ecefe15d6b98214ca8969592d2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_cubic_spline.html#af00cf5ecefe15d6b98214ca8969592d2">subdivide</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;src, int soff, float tp, std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;left, std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;rght)</td></tr>
<tr class="separator:af00cf5ecefe15d6b98214ca8969592d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a95f7d4c3ba0a567a3f24818e00230bce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a95f7d4c3ba0a567a3f24818e00230bce"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>CubicSplineApproximator</b></td></tr>
<tr class="separator:a95f7d4c3ba0a567a3f24818e00230bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a spline of cubic beziers.</p>
<p>A bezier spline is a sequence of beziers, where the start of one is the begining of the other. A bezier spline may be open or closed. In a closed spline, the end of the last bezier is the beginning of the first (or in the case of a degenerate bezier, a bezier with the same beginning and end).</p>
<p>A single cubic bezier is represented by the four points. There are the two anchor points P1 and P2. These represent the start and end of the curve. In addition, each of these points has a tangent: T1 and T2. The curve is defined so that P1 has a right tangent of T1, and P2 has a left tangent of T2. The tangents themselves are given as points, not vectors (so the tangent vector is Tn-Pn). These four points are known as the control points. When we represent a bezier, we typically represent it as a list of four points in this order: P1, T1, T2, and P2.</p>
<p>In a bezier spline, the first anchor point of the next curve is the same as the last anchor point of the previous one. There is no need to duplicate this information. However, the tanget is not a duplicate, since anchor points on the interior of the spline have both a left and right tangent. Therefore, the control point list always has two tangents between any two anchors. Thus bezier spline of n beziers will contain 3n+1 control points.</p>
<p>This class does not contain any drawing functionality at all. If you wish to draw a bezier, create a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> approximation with the <a class="el" href="classcugl_1_1_cubic_spline_approximator.html">CubicSplineApproximator</a> factory. This factory creates a line-segment approximation of the bezier, in much the same way that we approximate circles or ellipses when drawing them. You can then use the many features for drawing a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object, such as extrusion or wireframes.</p>
<p>This class has a lot of advanced methods to detect the nearest anchor, tanget, or curve location to a point. These are designed so that you can edit a bezier in a level editor for you game. These methods determine the part of the bezier closest to you mouse location, so that you can select and edit them. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a66300a78ac70b538151d271a2fe1e969"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an empty spline.</p>
<p>This is a degenerate spline with no control points; it is open. </p>

</div>
</div>
<a class="anchor" id="a4a2f09055d2a6d98c3e393c10c9ff0fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a degenerate spline of one point</p>
<p>The minimum spline possible has 4 points: two anchors and two tangents. This sets them all to (x,y). As a degenerate spline, it is closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The bezier anchor point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ae48d0fe717586297c375c9c2fda2a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a spline of two points</p>
<p>The minimum spline possible has 4 points: two anchors and two tangents. This sets the start to be the first anchor point, and end to be the second. The tangents, are the same as the anchor points, which means that the tangents are degenerate. This has the effect of making the bezier a straight line from start to end. The spline is open, unless start and end are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The first bezier anchor point </td></tr>
    <tr><td class="paramname">end</td><td>The second bezier anchor point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a85a04d32d92948725d0a3222469af4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a spline from the given control points.</p>
<p>The control points must be specified in the form </p><pre class="fragment"> anchor, tangent, tangent, anchor, tangent ... anchor
</pre><p>That is, starts and ends with anchors, and every two anchors have two tangents (right of the first, left of the second) in between. As each point is two floats, the value size must be equal to 2 mod 6.</p>
<p>The created spline is open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The array of control points as floats </td></tr>
    <tr><td class="paramname">offset</td><td>The starting offset in the control point array </td></tr>
    <tr><td class="paramname">size</td><td>The number of floats to use in the array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a871ad1026047658bb41ddc60c6ed7679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a spline from the given control points.</p>
<p>The control points must be specified in the form </p><pre class="fragment"> anchor, tangent, tangent, anchor, tangent ... anchor
</pre><p>That is, starts and ends with anchors, and every two anchors have two tangents (right of the first, left of the second) in between. As each point is two floats, the size of the vector must be equal to 2 mod 6.</p>
<p>The created spline is open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vector of control points as floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35348b573a2a219b4cdcd939a7bcc49b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a spline from the given control points.</p>
<p>The control points must be specified in the form </p><pre class="fragment"> anchor, tangent, tangent, anchor, tangent ... anchor
</pre><p>That is, starts and ends with anchors, and every two anchors have two tangents (right of the first, left of the second) in between. The size of this vector must be equal to 1 mod 3.</p>
<p>The created spline is open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vector of control points </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c8a0394caf57307b38111d54d9da9ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a copy of the given spline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spline</td><td>The spline to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3cfb63fe6d948da346cce939fb69fbdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::CubicSpline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a spline with the resources of the given one</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spline</td><td>The spline to take from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49156b0aa5fe73b5788b7f73acd61706"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::CubicSpline::~CubicSpline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this spline, releasing all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a46b094c0831eedd4f855d4a77219912e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::CubicSpline::addAnchor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given point to the end of the spline, creating a new segment.</p>
<p>The new segment will start at the previous end of the last spline and extend to the given point. As closed splines have no end, this method will fail on closed beziers. You should use insertAnchor instead for closed beziers.</p>
<p>This version of the method adds a degenerate tangent point for the new anchor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the new anchor point to add to the end</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new number of segments in this spline </dd></dl>

</div>
</div>
<a class="anchor" id="a1ec48f04d193f34196b7f946d4c417bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::CubicSpline::addAnchor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>tang</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the given point to the end of the spline, creating a new segment.</p>
<p>The new segment will start at the previous end of the last spline and extend to the given point. As closed splines have no end, this method will fail on closed beziers. You should use insertAnchor instead for closed beziers.</p>
<p>This value tang is the left tangent of the new anchor point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the new anchor point to add to the end </td></tr>
    <tr><td class="paramname">tang</td><td>the left tangent of the new anchor point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new number of segments in this spline </dd></dl>

</div>
</div>
<a class="anchor" id="a362bbe2b15026048946347364dccdebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears all control points, producing a degenerate spline. </p>

</div>
</div>
<a class="anchor" id="ace0b2223a3b3a52a0613499696048b93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::deleteAnchor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the anchor point at the given index.</p>
<p>The point is deleted as well as both of its tangents (left and right). All remaining anchors after the deleted one will shift their indices down by one. Deletion is allowed on closed splines; the spline will remain closed after deletion.</p>
<p>If an open spline has n segments, then it has n+1 anchors. Similiarly, a closed spline had n anchors. The value index should be in the appropriate range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the anchor index to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b00b23de37c6568a754a25341368d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::CubicSpline::getAnchor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the anchor point at the given index.</p>
<p>If an open spline has n segments, then it has n+1 anchors. Similiarly, a closed spline had n anchors. The value index should be in the appropriate range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the anchor index (0..n+1 or 0..n)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the anchor point at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="acc1642504eb154024f6e004e334dcb49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt; cugl::CubicSpline::getControlPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the spline control points.</p>
<p>If the spline has n segments, then the list will have 6n+2 elements in it, representing the n+1 anchor points and the 2n tangents. The values will alternate </p><pre class="fragment"> anchor, tangent, tangent, anchor, tangent ... anchor
</pre><p>This is true even if the curve is closed. In that case, the first and last anchor points will be the same.</p>
<dl class="section return"><dt>Returns</dt><dd>the spline control points. </dd></dl>

</div>
</div>
<a class="anchor" id="a497db563b348234bf427d8a907f2335a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::CubicSpline::getPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the spline point for parameter tp.</p>
<p>A bezier spline is a parameterized curve. For a single bezier, it is parameterized with tp in 0..1, with tp = 0 representing the first anchor and tp = 1 representing the second. In the spline, we generalize this idea, where tp is an anchor if it is an int, and is inbetween the anchors floor(tp) and ceil(tp) otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>the parameterization value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the spline point for parameter tp </dd></dl>

</div>
</div>
<a class="anchor" id="a177951b29f319857e7497a7222e5b244"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::CubicSpline::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the spline point for parameter tp.</p>
<p>This method is like the public <a class="el" href="classcugl_1_1_cubic_spline.html#a497db563b348234bf427d8a907f2335a">getPoint()</a>, except that it is restricted to a single bezier segment. A bezier is parameterized with tp in 0..1, with tp = 0 representing the first anchor and tp = 1 representing the second. This method is used by the public <a class="el" href="classcugl_1_1_cubic_spline.html#a497db563b348234bf427d8a907f2335a">getPoint()</a> to compute its value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>the bezier segment to select from </td></tr>
    <tr><td class="paramname">tp</td><td>the parameterization value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the spline point for parameter tp </dd></dl>

</div>
</div>
<a class="anchor" id="a82230f1686189b6194c05dcaccfbeaa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_polynomial.html">Polynomial</a> cugl::CubicSpline::getPolynomialX </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the x-axis bezier polynomial for the given segment.</p>
<p>Bezier polynomials define the curve parameterization. They are two dimension polynomials that give a point. Rather than extend polynomial to support multidimensional data, we extract each axis separately.</p>
<p>We also cannot define a single polynomial for the entire spline, but we can do it for each segment. The result is a cubic poly, hence the name <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the x-axis bezier polynomial for the given segment. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d4481cb0155204a9cef4c6ab8f38d93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_polynomial.html">Polynomial</a> cugl::CubicSpline::getPolynomialY </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the y-axis bezier polynomial for the given segment.</p>
<p>Bezier polynomials define the curve parameterization. They are two dimension polynomials that give a point. Rather than extend polynomial to support multidimensional data, we extract each axis separately.</p>
<p>We also cannot define a single polynomial for the entire spline, but we can do it for each segment. The result is a cubic poly, hence the name <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the y-axis bezier polynomial for the given segment. </dd></dl>

</div>
</div>
<a class="anchor" id="a49426310aa1869951318f2f5e93be228"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::CubicSpline::getProjectionFast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the parameterization of the nearest point on the bezier segment.</p>
<p>The value is effectively the projection of the point onto the parametrized curve. See <a class="el" href="classcugl_1_1_cubic_spline.html#a497db563b348234bf427d8a907f2335a">getPoint()</a> for an explanation of how the parameterization work.</p>
<p>The value is effectively the projection of the point onto the parametrized curve. See <a class="el" href="classcugl_1_1_cubic_spline.html#a497db563b348234bf427d8a907f2335a">getPoint()</a> for an explanation of how the parameterization work. We compute this value using the projection polynomial, described at</p>
<p><a href="http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html">http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html</a></p>
<p>The value returned is a pair of the parameter, and its distance value. This allows us to compare this result to other segments, picking the best value for the entire spline.</p>
<p>This algorithm uses the projection polynomial, and searches for roots to find the best (max of 5) candidates. However, root finding may fail, do to singularities in Bairstow's Method. If the root finder fails, then the first element of the pair will be -1 (an invalid parameter).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the point to project </td></tr>
    <tr><td class="paramname">segment</td><td>the bezier segment to project upon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameterization of the nearest point on the spline. </dd></dl>

</div>
</div>
<a class="anchor" id="a29392b1dbba593c6f6ff984015ffe334"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_polynomial.html">Polynomial</a> cugl::CubicSpline::getProjectionPolynomial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the projection polynomial for the given point.</p>
<p>The projection polynomial is used to find the nearest value to point on the spline, as described at</p>
<p><a href="http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html">http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html</a></p>
<p>There is no one projection polynomial for the entire spline. Each segment bezier has its own polynomial.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the point to project </td></tr>
    <tr><td class="paramname">segment</td><td>the bezier segment to project upon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a42d1d81230a9dbf6c1b5b72e67ce1c46"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::CubicSpline::getProjectionSlow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the parameterization of the nearest point on the bezier segment.</p>
<p>The value is effectively the projection of the point onto the parametrized curve. See <a class="el" href="classcugl_1_1_cubic_spline.html#a497db563b348234bf427d8a907f2335a">getPoint()</a> for an explanation of how the parameterization work.</p>
<p>This version does not use the projection polynomial. Instead, it picks a parameter resolution and walks the entire length of the curve. The result is both slow and inexact (as the actual point may be in-between chose parameters). This version is only picked when getProjectionFast fails because of an error with root finding.</p>
<p>The value returned is a pair of the parameter, and its distance value. This allows us to compare this result to other segments, picking the best value for the entire spline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the point to project </td></tr>
    <tr><td class="paramname">segment</td><td>the bezier segment to project upon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameterization of the nearest point on the spline. </dd></dl>

</div>
</div>
<a class="anchor" id="a906957a5dae1359ee55c954901176263"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::CubicSpline::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of segments in this spline</p>
<p>Each segment is a bezier. To use the bezier methods associated with this class, you will need to know the correct segment.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of segments in this spline </dd></dl>

</div>
</div>
<a class="anchor" id="ab2c7f3c6ddf71be27f880f0b0af388ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::CubicSpline::getSmooth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the smoothness for the anchor point at the given index.</p>
<p>A smooth anchor is one in which the derivative of the curve at the anchor is continuous. Practically, this means that the left and right tangents are always parallel. Only a non-smooth anchor may form a "hinge".</p>
<p>If an open spline has n segments, then it has n+1 anchors. Similiarly, a closed spline had n anchors. The value index should be in the appropriate range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the anchor index (0..n+1 or 0..n)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smoothness for the anchor point at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e6f106995292f59879b1b3a09ce8632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::CubicSpline::getTangent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the tangent at the given index.</p>
<p>Tangents are specified as points, not vectors. To get the tangent vector for an anchor, you must subtract the anchor from its tangent point. Hence a curve is degenerate when the tangent and the anchor are the same.</p>
<p>If a spline has n segments, then it has 2n tangents. This is true regardless of whether it is open or closed. The value index should be in the appropriate range. An even index is a right tangent, while an odd index is a left tangent. If the spline is closed, then 2n-1 is the left tangent of the first point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the tangent index (0..2n)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tangent at the given index. </dd></dl>

</div>
</div>
<a class="anchor" id="aa8e1aeb290dbf55cc8abd7093ee83674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::insertAnchor </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new anchor point at parameter tp.</p>
<p>Inserting an anchor point does not change the curve. It just makes an existing point that was not an anchor, now an anchor. This is the natural behavior for inserting an index, as seen in Adobe Illustrator.</p>
<p>A bezier spline is a parameterized curve. For a single bezier, it is parameterized with tp in 0..1, with tp = 0 representing the first anchor and tp = 1 representing the second. In the spline, we generalize this idea, where tp is an anchor if it is an int, and is inbetween the anchors floor(tp) and ceil(tp) otherwise.</p>
<p>The tangents of the new anchor point will be determined by de Castlejau's. This is the natural behavior for inserting an anchor mid bezier, as seen in Adobe Illustrator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>the parameterization value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1fdab40b5c11e3f0ea2fcb9b206da5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::insertAnchor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts a new anchor point at parameter tp.</p>
<p>Inserting an anchor point does not change the curve. It just makes an existing point that was not an anchor, now an anchor. This is the natural behavior for inserting an index, as seen in Adobe Illustrator.</p>
<p>This version of <a class="el" href="classcugl_1_1_cubic_spline.html#aa8e1aeb290dbf55cc8abd7093ee83674">insertAnchor()</a> specifies the segment for insertion, simplifying the parameterization. For a single bezier, it is parameterized with tp in 0..1, with tp = 0 representing the first anchor and tp = 1 representing the second.</p>
<p>The tangents of the new anchor point will be determined by de Castlejau's. This is the natural behavior for inserting an anchor mid bezier, as seen in Adobe Illustrator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>the bezier segment to insert into </td></tr>
    <tr><td class="paramname">param</td><td>the parameterization value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa377a94397af19dfb6f4cbcfbd3bd0c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::CubicSpline::isClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the spline is closed.</p>
<p>A closed spline is one where the first and last anchor are the same. Hence the first and last tangents are tangents (right, and left, respectively) of the same point. This is relevant for the <a class="el" href="classcugl_1_1_cubic_spline.html#a542b710c37d28aae05025f20c78fe7d7">setTangent()</a> method, particularly if the change is meant to be symmetric.</p>
<p>A closed spline has no end. Therefore, anchors cannot be added to a closed spline. They may only be inserted between two other anchors.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the spline is closed </dd></dl>

</div>
</div>
<a class="anchor" id="a84344c659341dcec5eda3c247967556f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::CubicSpline::nearestAnchor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the anchor nearest the given point.</p>
<p>If there is no anchor whose distance to point is less than the square root of threshold (we use lengthSquared for speed), then this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the point to compare </td></tr>
    <tr><td class="paramname">threshold</td><td>the distance threshold for picking an anchor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the anchor nearest the given point. </dd></dl>

</div>
</div>
<a class="anchor" id="aecd54526e2badc08d98283b2861978c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::CubicSpline::nearestParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the parameterization of the nearest point on the spline.</p>
<p>The value is effectively the projection of the point onto the parametrized curve. See <a class="el" href="classcugl_1_1_cubic_spline.html#a497db563b348234bf427d8a907f2335a">getPoint()</a> for an explanation of how the parameterization work. We compute this value using the projection polynomial, described at</p>
<p><a href="http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html">http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the point to project</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parameterization of the nearest point on the spline. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4d7068741767213276eb6882de5c10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::CubicSpline::nearestPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the nearest point on the spline to the given point.</p>
<p>The value is effectively the projection of the point onto the curve. We compute this point using the projection polynomial, described at</p>
<p><a href="http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html">http://jazzros.blogspot.com/2011/03/projecting-point-on-bezier-curve.html</a></p>
<p>The point returned does not need to be an anchor point. It can be anywhere on the curve. This allows us a way to select a non-anchor point with the mouse (such as to add a new anchor point) in a level editor or other program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the point to project</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the nearest point on the spline to the given point. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c611714a27deb6b4b05544ceff931e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::CubicSpline::nearestTangent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index of the tangent nearest the given point.</p>
<p>If there is no tangent whose distance to point is less than the square root of threshold (we use lengthSquared for speed), then this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>the point to compare </td></tr>
    <tr><td class="paramname">threshold</td><td>the distance threshold for picking a tangent</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the tangent nearest the given point. </dd></dl>

</div>
</div>
<a class="anchor" id="abbfb7180956127436344d64ec88a494d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this spline to be a copy of the given spline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spline</td><td>The spline to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="af4c760337ac8091fc79e2a50c0c6c99f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this spline to have the resources of the given one</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spline</td><td>The spline to take from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a3182e39fde8e03519a145acf8d77c4e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this spline to be a degenerate degenerate of one point</p>
<p>The minimum spline possible has 4 points: two anchors and two tangents. This sets them all to (x,y). As a degenerate spline, it is closed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The bezier anchor point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="ac2724a98a9a3b919ff0661c9d904222e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this spline to be a line between two points</p>
<p>The minimum spline possible has 4 points: two anchors and two tangents. This sets the start to be the first anchor point, and end to be the second. The tangents, are the same as the anchor points, which means that the tangents are degenerate. This has the effect of making the bezier a straight line from start to end. The spline is open, unless start and end are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The first bezier anchor point </td></tr>
    <tr><td class="paramname">end</td><td>The second bezier anchor point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="acc49128a54fe254ec274bc554be1f8c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::set </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this spline to have the given control points.</p>
<p>The control points must be specified in the form </p><pre class="fragment"> anchor, tangent, tangent, anchor, tangent ... anchor
</pre><p>That is, starts and ends with anchors, and every two anchors have two tangents (right of the first, left of the second) in between. As each point is two floats, the value size must be equal to 2 mod 6.</p>
<p>This method makes the spline is open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The array of control points as floats </td></tr>
    <tr><td class="paramname">offset</td><td>The starting offset in the control point array </td></tr>
    <tr><td class="paramname">size</td><td>The number of floats to use in the array</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a903d4417ac1ec0bd23adbb991c43da50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this spline to have the given control points.</p>
<p>The control points must be specified in the form </p><pre class="fragment"> anchor, tangent, tangent, anchor, tangent ... anchor
</pre><p>That is, starts and ends with anchors, and every two anchors have two tangents (right of the first, left of the second) in between. As each point is two floats, the size of the vector must be equal to 2 mod 6.</p>
<p>This method makes the spline is open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vector of control points as floats</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a210335b145ef7a141a13f4c58bf18a04"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this spline to have the given control points.</p>
<p>The control points must be specified in the form </p><pre class="fragment"> anchor, tangent, tangent, anchor, tangent ... anchor
</pre><p>That is, starts and ends with anchors, and every two anchors have two tangents (right of the first, left of the second) in between. The size of this vector must be equal to 1 mod 3.</p>
<p>This method makes the spline is open.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vector of control points</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="a28b60597e9895db55ff11e08d0423e27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a>&amp; cugl::CubicSpline::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_cubic_spline.html">CubicSpline</a> &amp;&#160;</td>
          <td class="paramname"><em>spline</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this spline to be a copy of the given spline.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spline</td><td>The spline to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This spline, returned for chaining </dd></dl>

</div>
</div>
<a class="anchor" id="aeb57a2bc7209bf71b9a32379318dc35e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::setAnchor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the anchor point at the given index.</p>
<p>This method will change both the anchor and its associated tangets. The new tangents will have the same relative change in position. As a result, the bezier will still have the same shape locally. This is the natural behavior for changing an anchor, as seen in Adobe Illustrator.</p>
<p>If an open spline has n segments, then it has n+1 anchors. Similiarly, a closed spline had n anchors. The value index should be in the appropriate range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the anchor index (0..n+1 or 0..n) </td></tr>
    <tr><td class="paramname">point</td><td>the new value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af320c9c6ba4f547b2c2e0025657faec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::setClosed </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether the spline is closed.</p>
<p>A closed spline is one where the first and last anchor are the same. Hence the first and last tangents are tangents (right, and left, respectively) of the same point. This is relevant for the <a class="el" href="classcugl_1_1_cubic_spline.html#a542b710c37d28aae05025f20c78fe7d7">setTangent()</a> method, particularly if the change is meant to be symmetric.</p>
<p>A closed spline has no end. Therefore, anchors cannot be added to a closed spline. They may only be inserted between two other anchors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>whether the spline is closed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac58a96ba86b40855817d9762f4525f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::setPoint </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the spline point at parameter tp.</p>
<p>A bezier spline is a parameterized curve. For a single bezier, it is parameterized with tp in 0..1, with tp = 0 representing the first anchor and tp = 1 representing the second. In the spline, we generalize this idea, where tp is an anchor if it is an int, and is inbetween the anchors floor(tp) and ceil(tp) otherwise.</p>
<p>In this method, if tp is an int, it will just reassign the associated anchor value. Otherwise, this will insert a new anchor point at that parameter. This has a side-effect of changing the parameterization values for the curve, as the number of beziers has increased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tp</td><td>the parameterization value </td></tr>
    <tr><td class="paramname">point</td><td>the new value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eae43022ae09885c6b3c7acaa77389f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::setSmooth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the smoothness for the anchor point at the given index.</p>
<p>A smooth anchor is one in which the derivative of the curve at the anchor is continuous. Practically, this means that the left and right tangents are always parallel. Only a non-smooth anchor may form a "hinge".</p>
<p>If you set a non-smooth anchor to smooth, it will adjust the tangents accordingly. In particular, it will average the two tangents, making them parallel. This is the natural behavior for changing an smoothness, as seen in Adobe Illustrator.</p>
<p>If an open spline has n segments, then it has n+1 anchors. Similiarly, a closed spline had n anchors. The value index should be in the appropriate range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the anchor index (0..n+1 or 0..n) </td></tr>
    <tr><td class="paramname">flag</td><td>the anchor smoothness </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a542b710c37d28aae05025f20c78fe7d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::setTangent </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>tang</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the tangent at the given index.</p>
<p>Tangents are specified as points, not vectors. To get the tangent vector for an anchor, you must subtract the anchor from its tangent point. Hence a curve is degenerate when the tangent and the anchor are the same.</p>
<p>If the associated anchor point is smooth, changing the direction of the tangent vector will also change the direction of the other tangent vector (so that they remain parallel). However, changing only the magnitude will have no effect, unless symmetric is true. In that case, it will modify the other tangent so that it has the same magnitude and parallel direction. This is the natural behavior for changing a tangent, as seen in Adobe Illustrator.</p>
<p>If a spline has n segments, then it has 2n tangents. This is true regardless of whether it is open or closed. The value index should be in the appropriate range. An even index is a right tangent, while an odd index is a left tangent. If the spline is closed, then 2n-1 is the left tangent of the first point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the tangent index (0..2n) </td></tr>
    <tr><td class="paramname">tang</td><td>the new value to assign </td></tr>
    <tr><td class="paramname">symmetric</td><td>whether to make the other tangent symmetric </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1931c156d19f2a0a469872dc1819918a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::CubicSpline::subdivide </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rght</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies de Castlejau's to the given segment, putting the result in left &amp; right</p>
<p>de Castlejau's takes a parameter tp in (0,1) and splits the bezier into two, preserving the geometric information, but not the parameterization. The control points for the resulting two beziers are stored in left and right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segment</td><td>the bezier segment of this spine </td></tr>
    <tr><td class="paramname">tp</td><td>the parameter to split at </td></tr>
    <tr><td class="paramname">left</td><td>vector to store the left bezier </td></tr>
    <tr><td class="paramname">rght</td><td>vector to store the right bezier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af00cf5ecefe15d6b98214ca8969592d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cugl::CubicSpline::subdivide </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>soff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rght</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies de Castlejau's to a bezier, putting the result in left &amp; right</p>
<p>de Castlejau's takes a parameter tp in (0,1) and splits the bezier into two, preserving the geometric information, but not the parameterization. The control points for the resulting two beziers are stored in left and right.</p>
<p>This static method is not restricted to the current spline. It can work from any list of control points (and offset into those control points). This is useful for recursive subdivision.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the control point list for the bezier </td></tr>
    <tr><td class="paramname">soff</td><td>the offset into the control point list </td></tr>
    <tr><td class="paramname">tp</td><td>the parameter to split at </td></tr>
    <tr><td class="paramname">left</td><td>vector to store the left bezier </td></tr>
    <tr><td class="paramname">rght</td><td>vector to store the right bezier </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/<a class="el" href="_c_u_cubic_spline_8h_source.html">CUCubicSpline.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>CUGL 1.2: cugl::JsonValue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="web-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 1.2
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>cugl</b></li><li class="navelem"><a class="el" href="classcugl_1_1_json_value.html">JsonValue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_json_value-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::JsonValue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_json_value_8h_source.html">CUJsonValue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:acb13666c0569163d6a124f9247b423e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">Type</a> : int { <br />
&#160;&#160;<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8ab9ff2fa4972141b1d1d36cd80b81a279">Type::NullType</a> = 0, 
<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8ab0aebe765a463d2f7e8464016ef1eec2">Type::BoolType</a> = 1, 
<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8af9154b8320591f3b1fab4cf4c951e409">Type::NumberType</a> = 2, 
<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8ab900a78030fdadc18121e26865e75791">Type::StringType</a> = 3, 
<br />
&#160;&#160;<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8acb17ff5177bb277ed8dd79480aad9c27">Type::ArrayType</a> = 4, 
<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8ab74c375731dc50c662d6ce08befe2db0">Type::ObjectType</a> = 5
<br />
 }<tr class="separator:acb13666c0569163d6a124f9247b423e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae16e9f9c13471ba23458e201f91bb1c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ae16e9f9c13471ba23458e201f91bb1c9">JsonValue</a> ()</td></tr>
<tr class="separator:ae16e9f9c13471ba23458e201f91bb1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ecea97a3b78fbd4d6bfec46822e640"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a03ecea97a3b78fbd4d6bfec46822e640">~JsonValue</a> ()</td></tr>
<tr class="separator:a03ecea97a3b78fbd4d6bfec46822e640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd684d09191480c7864ee33c047f8a44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#acd684d09191480c7864ee33c047f8a44">init</a> (<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">Type</a> <a class="el" href="classcugl_1_1_json_value.html#abc3eb1456f383976599824d24a47d700">type</a>)</td></tr>
<tr class="separator:acd684d09191480c7864ee33c047f8a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225e55bd712a75ecdf7f306b31e8eaf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a225e55bd712a75ecdf7f306b31e8eaf3">init</a> (const std::string &amp;value)</td></tr>
<tr class="separator:a225e55bd712a75ecdf7f306b31e8eaf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473b77867af51cf16f338449dcda0605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a473b77867af51cf16f338449dcda0605">init</a> (const char *value)</td></tr>
<tr class="separator:a473b77867af51cf16f338449dcda0605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4915a2b664374437900c482a3703f3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a4915a2b664374437900c482a3703f3a0">init</a> (bool value)</td></tr>
<tr class="separator:a4915a2b664374437900c482a3703f3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad984b0067dd1cbf460cbefe25795e91c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad984b0067dd1cbf460cbefe25795e91c">init</a> (long value)</td></tr>
<tr class="separator:ad984b0067dd1cbf460cbefe25795e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248a9952a879edc85ac4678aeffb0b9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a248a9952a879edc85ac4678aeffb0b9b">init</a> (double value)</td></tr>
<tr class="separator:a248a9952a879edc85ac4678aeffb0b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4669f0818aba5bdd246173a3d6dd43d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ab4669f0818aba5bdd246173a3d6dd43d">initNull</a> ()</td></tr>
<tr class="separator:ab4669f0818aba5bdd246173a3d6dd43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904fd5baf53648ceeb09c957ed56236c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a904fd5baf53648ceeb09c957ed56236c">initArray</a> ()</td></tr>
<tr class="separator:a904fd5baf53648ceeb09c957ed56236c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456e62246c253fda0a786cc7e9151d8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a456e62246c253fda0a786cc7e9151d8d">initObject</a> ()</td></tr>
<tr class="separator:a456e62246c253fda0a786cc7e9151d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a13c84c6f73b24e5b466c9ad85db0d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a6a13c84c6f73b24e5b466c9ad85db0d4">initWithJson</a> (const std::string &amp;json)</td></tr>
<tr class="separator:a6a13c84c6f73b24e5b466c9ad85db0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a00592820366cb341c96d3a604ec21e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0a00592820366cb341c96d3a604ec21e">initWithJson</a> (const char *json)</td></tr>
<tr class="separator:a0a00592820366cb341c96d3a604ec21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3eb1456f383976599824d24a47d700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#abc3eb1456f383976599824d24a47d700">type</a> () const </td></tr>
<tr class="separator:abc3eb1456f383976599824d24a47d700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf284eb17b25e240a39608fd74f6b0a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aaf284eb17b25e240a39608fd74f6b0a6">isNull</a> () const </td></tr>
<tr class="separator:aaf284eb17b25e240a39608fd74f6b0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73a52f2084dfd237f0a8d18a8973176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ab73a52f2084dfd237f0a8d18a8973176">isNumber</a> () const </td></tr>
<tr class="separator:ab73a52f2084dfd237f0a8d18a8973176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f370126ba61ca4222edc7fff0ae99a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1f370126ba61ca4222edc7fff0ae99a0">isBool</a> () const </td></tr>
<tr class="separator:a1f370126ba61ca4222edc7fff0ae99a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083a66a565193fd6bd537423c9de0d19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a083a66a565193fd6bd537423c9de0d19">isString</a> () const </td></tr>
<tr class="separator:a083a66a565193fd6bd537423c9de0d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937e6742f050000d66b29b5894b229a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a937e6742f050000d66b29b5894b229a4">isValue</a> () const </td></tr>
<tr class="separator:a937e6742f050000d66b29b5894b229a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebffab19c701475b627e3cdf06a56b9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aebffab19c701475b627e3cdf06a56b9a">isArray</a> () const </td></tr>
<tr class="separator:aebffab19c701475b627e3cdf06a56b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a961bd69d43de4862031e3cd7a92b0282"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a961bd69d43de4862031e3cd7a92b0282">isObject</a> () const </td></tr>
<tr class="separator:a961bd69d43de4862031e3cd7a92b0282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15345e5a65432636dc601ffdd9f64c49"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a15345e5a65432636dc601ffdd9f64c49">asString</a> (const std::string &amp;defaultValue) const </td></tr>
<tr class="separator:a15345e5a65432636dc601ffdd9f64c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47e8ef8f67cfbde4f0e6674de47d934"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aa47e8ef8f67cfbde4f0e6674de47d934">asString</a> (const char *defaultValue=&quot;&quot;) const </td></tr>
<tr class="separator:aa47e8ef8f67cfbde4f0e6674de47d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c600ffcf3ba2975c55b286e7baeba29"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a9c600ffcf3ba2975c55b286e7baeba29">asFloat</a> (float defaultValue=0.0f) const </td></tr>
<tr class="separator:a9c600ffcf3ba2975c55b286e7baeba29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76dc1e9afaddd72e27d62c306453576"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad76dc1e9afaddd72e27d62c306453576">asDouble</a> (double defaultValue=0.0) const </td></tr>
<tr class="separator:ad76dc1e9afaddd72e27d62c306453576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eac25a09f3541d766f54996317c9d8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a27eac25a09f3541d766f54996317c9d8">asLong</a> (long defaultValue=0L) const </td></tr>
<tr class="separator:a27eac25a09f3541d766f54996317c9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a952206beca612476c1a8e67f012a4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a36a952206beca612476c1a8e67f012a4">asInt</a> (int defaultValue=0) const </td></tr>
<tr class="separator:a36a952206beca612476c1a8e67f012a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9e155b50245d06ff72b5ba6dc6168f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aad9e155b50245d06ff72b5ba6dc6168f">asBool</a> (bool defaultValue=false) const </td></tr>
<tr class="separator:aad9e155b50245d06ff72b5ba6dc6168f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f26c3d9059c0310742c3f50ae7129dd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0f26c3d9059c0310742c3f50ae7129dd">asStringArray</a> (const std::string &amp;defaultValue) const </td></tr>
<tr class="separator:a0f26c3d9059c0310742c3f50ae7129dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0961c86fe1638e914d8292bf187b5511"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0961c86fe1638e914d8292bf187b5511">asStringArray</a> (const char *defaultValue=&quot;&quot;) const </td></tr>
<tr class="separator:a0961c86fe1638e914d8292bf187b5511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a5fae5e9f4098767bb3fb1f1af8c1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a658a5fae5e9f4098767bb3fb1f1af8c1">asFloatArray</a> (float defaultValue=0.0f) const </td></tr>
<tr class="separator:a658a5fae5e9f4098767bb3fb1f1af8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca73be399278f2ea2a36be890dea59dd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aca73be399278f2ea2a36be890dea59dd">asDoubleArray</a> (double defaultValue=0.0) const </td></tr>
<tr class="separator:aca73be399278f2ea2a36be890dea59dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670c3cbb1d08311155f4c429eb87b422"><td class="memItemLeft" align="right" valign="top">std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a670c3cbb1d08311155f4c429eb87b422">asLongArray</a> (long defaultValue=0L) const </td></tr>
<tr class="separator:a670c3cbb1d08311155f4c429eb87b422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e52518d89bc16be293ef31d3ac4c5b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac1e52518d89bc16be293ef31d3ac4c5b">asIntArray</a> (int defaultValue=0) const </td></tr>
<tr class="separator:ac1e52518d89bc16be293ef31d3ac4c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98aff038f01c1a1473f59e4b3b2d046"><td class="memItemLeft" align="right" valign="top">std::vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac98aff038f01c1a1473f59e4b3b2d046">asBoolArray</a> (bool defaultValue=false)</td></tr>
<tr class="separator:ac98aff038f01c1a1473f59e4b3b2d046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564f223ce9656ee2b0bb6cacce5753a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a564f223ce9656ee2b0bb6cacce5753a5">set</a> (const std::string &amp;value)</td></tr>
<tr class="separator:a564f223ce9656ee2b0bb6cacce5753a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c81da96e5f4fcc45c6c9410e36f29dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1c81da96e5f4fcc45c6c9410e36f29dd">set</a> (const char *value)</td></tr>
<tr class="separator:a1c81da96e5f4fcc45c6c9410e36f29dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5888562a73aa46d7040cb8ed7373c949"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a5888562a73aa46d7040cb8ed7373c949">set</a> (long value)</td></tr>
<tr class="separator:a5888562a73aa46d7040cb8ed7373c949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a9d1272680c1e87564e8ab49f6929b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a68a9d1272680c1e87564e8ab49f6929b">set</a> (double value)</td></tr>
<tr class="separator:a68a9d1272680c1e87564e8ab49f6929b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dcf62c3a21f099b752bcdcba20aabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a93dcf62c3a21f099b752bcdcba20aabb">set</a> (bool value)</td></tr>
<tr class="separator:a93dcf62c3a21f099b752bcdcba20aabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fa443c760689fd7dea2f5b16ef8b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a88fa443c760689fd7dea2f5b16ef8b1f">setNull</a> ()</td></tr>
<tr class="separator:a88fa443c760689fd7dea2f5b16ef8b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403281b255603d26e7747f3a63cd9a32"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a> () const </td></tr>
<tr class="separator:a403281b255603d26e7747f3a63cd9a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbdf6422d20111f7bcfeca7f1711db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1cbdf6422d20111f7bcfeca7f1711db5">setKey</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a1cbdf6422d20111f7bcfeca7f1711db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40986d5fdb35f137bed1e7d83a13d979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a40986d5fdb35f137bed1e7d83a13d979">setKey</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a40986d5fdb35f137bed1e7d83a13d979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c46ac15ddcce16242324ea9ce903bbd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a> () const </td></tr>
<tr class="separator:a7c46ac15ddcce16242324ea9ce903bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab348e91e653ecdef8b6f821bb506702b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ab348e91e653ecdef8b6f821bb506702b">size</a> () const </td></tr>
<tr class="separator:ab348e91e653ecdef8b6f821bb506702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6769355b5037355b54ae9285fa8381a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a6769355b5037355b54ae9285fa8381a0">has</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:a6769355b5037355b54ae9285fa8381a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1b42f9bf05cccc002d44a5e2769df5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a2a1b42f9bf05cccc002d44a5e2769df5">has</a> (const char *name) const </td></tr>
<tr class="separator:a2a1b42f9bf05cccc002d44a5e2769df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969331c2cac5277e7eae58eb47b7837d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a969331c2cac5277e7eae58eb47b7837d">get</a> (int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>)</td></tr>
<tr class="separator:a969331c2cac5277e7eae58eb47b7837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b66758c75e501873f3c0582989ff2fa"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0b66758c75e501873f3c0582989ff2fa">get</a> (int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>) const </td></tr>
<tr class="separator:a0b66758c75e501873f3c0582989ff2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af616805cfe31728e0f30fa2dbb4ab381"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#af616805cfe31728e0f30fa2dbb4ab381">get</a> (const std::string &amp;name)</td></tr>
<tr class="separator:af616805cfe31728e0f30fa2dbb4ab381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d506030fcfbf0c6ad467000977cc93"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ae2d506030fcfbf0c6ad467000977cc93">get</a> (const std::string &amp;name) const </td></tr>
<tr class="separator:ae2d506030fcfbf0c6ad467000977cc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a268cd59b636ca94bec7e38004af61"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a14a268cd59b636ca94bec7e38004af61">get</a> (const char *name)</td></tr>
<tr class="separator:a14a268cd59b636ca94bec7e38004af61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1831b645d837e4f96d28f424684603e5"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1831b645d837e4f96d28f424684603e5">get</a> (const char *name) const </td></tr>
<tr class="separator:a1831b645d837e4f96d28f424684603e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793c37fa7cb4b5e4e5fb256d889acfb5"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a793c37fa7cb4b5e4e5fb256d889acfb5">getString</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::string &amp;defaultValue) const </td></tr>
<tr class="separator:a793c37fa7cb4b5e4e5fb256d889acfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60534197d8bd55ced45c81c3ba4097a6"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a60534197d8bd55ced45c81c3ba4097a6">getString</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const char *defaultValue=&quot;&quot;) const </td></tr>
<tr class="separator:a60534197d8bd55ced45c81c3ba4097a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d7e7ee18439625defd71abbdc13132"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a83d7e7ee18439625defd71abbdc13132">getString</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const char *defaultValue=&quot;&quot;) const </td></tr>
<tr class="separator:a83d7e7ee18439625defd71abbdc13132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a633602406b58873929901d5e33adc"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a72a633602406b58873929901d5e33adc">getString</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::string &amp;defaultValue) const </td></tr>
<tr class="separator:a72a633602406b58873929901d5e33adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bfe671831c8cc2d3044ac4bf41297b3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a7bfe671831c8cc2d3044ac4bf41297b3">getFloat</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, float defaultValue=0.0f) const </td></tr>
<tr class="separator:a7bfe671831c8cc2d3044ac4bf41297b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5bcbf5021d5858322e399fc4ec08ff"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0f5bcbf5021d5858322e399fc4ec08ff">getFloat</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, float defaultValue=0.0f) const </td></tr>
<tr class="separator:a0f5bcbf5021d5858322e399fc4ec08ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918140948c10b65cb505d40776b99a55"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a918140948c10b65cb505d40776b99a55">getDouble</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, double defaultValue=0.0) const </td></tr>
<tr class="separator:a918140948c10b65cb505d40776b99a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee6811b17d7db2d6d5c8e25973b983a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a8ee6811b17d7db2d6d5c8e25973b983a">getDouble</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, double defaultValue=0.0) const </td></tr>
<tr class="separator:a8ee6811b17d7db2d6d5c8e25973b983a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa144425517cc19e8cd9efb1c656c40"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1aa144425517cc19e8cd9efb1c656c40">getLong</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, long defaultValue=0L) const </td></tr>
<tr class="separator:a1aa144425517cc19e8cd9efb1c656c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b68e346db3bc5809eecc0f8044aeb5b"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a6b68e346db3bc5809eecc0f8044aeb5b">getLong</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, long defaultValue=0L) const </td></tr>
<tr class="separator:a6b68e346db3bc5809eecc0f8044aeb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1fe9ee294aac3933379f1fbf876c5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aba1fe9ee294aac3933379f1fbf876c5f">getInt</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, int defaultValue=0) const </td></tr>
<tr class="separator:aba1fe9ee294aac3933379f1fbf876c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee5958a3ebcb1b2df0603ac29d195c5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aaee5958a3ebcb1b2df0603ac29d195c5">getInt</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, int defaultValue=0) const </td></tr>
<tr class="separator:aaee5958a3ebcb1b2df0603ac29d195c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61ee92dd8faaf54cd52c543f5108c81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac61ee92dd8faaf54cd52c543f5108c81">getBool</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, bool defaultValue=false) const </td></tr>
<tr class="separator:ac61ee92dd8faaf54cd52c543f5108c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee9cb96636a66e5814404750f27dc62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a9ee9cb96636a66e5814404750f27dc62">getBool</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, bool defaultValue=false) const </td></tr>
<tr class="separator:a9ee9cb96636a66e5814404750f27dc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9193ffe73e30dd3070e23664b0f1bb"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a2b9193ffe73e30dd3070e23664b0f1bb">removeChild</a> (int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>)</td></tr>
<tr class="separator:a2b9193ffe73e30dd3070e23664b0f1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af588e919317d739edae0b9d8456511a2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#af588e919317d739edae0b9d8456511a2">removeChild</a> (const std::string &amp;name)</td></tr>
<tr class="separator:af588e919317d739edae0b9d8456511a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3690167611c8dcabe9b03ea107b6940b"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a3690167611c8dcabe9b03ea107b6940b">removeChild</a> (const char *name)</td></tr>
<tr class="separator:a3690167611c8dcabe9b03ea107b6940b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7739e4ae22b1fc142a188620617931c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aa7739e4ae22b1fc142a188620617931c">appendChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;child)</td></tr>
<tr class="separator:aa7739e4ae22b1fc142a188620617931c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43f6df318edd46cb22141cea7074dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#af43f6df318edd46cb22141cea7074dd8">appendChild</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;child)</td></tr>
<tr class="separator:af43f6df318edd46cb22141cea7074dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72406d154085f1e29804a004f928b6d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a72406d154085f1e29804a004f928b6d2">appendChild</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;child)</td></tr>
<tr class="separator:a72406d154085f1e29804a004f928b6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4168abaecd84ec2bdff2a0b9fc56b08d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a4168abaecd84ec2bdff2a0b9fc56b08d">insertChild</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;child)</td></tr>
<tr class="separator:a4168abaecd84ec2bdff2a0b9fc56b08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbd7de0639eccb764d9428a42f9a69e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1bbd7de0639eccb764d9428a42f9a69e">insertChild</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;child)</td></tr>
<tr class="separator:a1bbd7de0639eccb764d9428a42f9a69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69507b6699aba1b94079e21d60cc8c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a69507b6699aba1b94079e21d60cc8c75">insertChild</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;child)</td></tr>
<tr class="separator:a69507b6699aba1b94079e21d60cc8c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80d1d17e7875d41008896b73241420b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ab80d1d17e7875d41008896b73241420b">appendValue</a> (bool value)</td></tr>
<tr class="separator:ab80d1d17e7875d41008896b73241420b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae8745e7bcb86992ea5bfcdba416ecc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#abae8745e7bcb86992ea5bfcdba416ecc">appendValue</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, bool value)</td></tr>
<tr class="separator:abae8745e7bcb86992ea5bfcdba416ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08e417849b0938adf15aa76688bd715"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad08e417849b0938adf15aa76688bd715">appendValue</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, bool value)</td></tr>
<tr class="separator:ad08e417849b0938adf15aa76688bd715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e8399fffc5569d6df7bd93bd841d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a00e8399fffc5569d6df7bd93bd841d13">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, bool value)</td></tr>
<tr class="separator:a00e8399fffc5569d6df7bd93bd841d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d90b7eccc2a2b3340521e62166fdb14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a3d90b7eccc2a2b3340521e62166fdb14">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, bool value)</td></tr>
<tr class="separator:a3d90b7eccc2a2b3340521e62166fdb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0300ebb8fb94edfe2afd7e212bfbdffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0300ebb8fb94edfe2afd7e212bfbdffa">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, bool value)</td></tr>
<tr class="separator:a0300ebb8fb94edfe2afd7e212bfbdffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e65fd768db72013cbe545ba991dfc83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a7e65fd768db72013cbe545ba991dfc83">appendValue</a> (long value)</td></tr>
<tr class="separator:a7e65fd768db72013cbe545ba991dfc83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac738382e8ec663c53d461b4ef12bc3c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac738382e8ec663c53d461b4ef12bc3c3">appendValue</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, long value)</td></tr>
<tr class="separator:ac738382e8ec663c53d461b4ef12bc3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f5eb3a74522f208feab177e736e106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad3f5eb3a74522f208feab177e736e106">appendValue</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, long value)</td></tr>
<tr class="separator:ad3f5eb3a74522f208feab177e736e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708497d94d5237d4849314eb76407392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a708497d94d5237d4849314eb76407392">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, long value)</td></tr>
<tr class="separator:a708497d94d5237d4849314eb76407392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7eeb89c10220b62c7fd0c187199fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aaa7eeb89c10220b62c7fd0c187199fdb">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, long value)</td></tr>
<tr class="separator:aaa7eeb89c10220b62c7fd0c187199fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de03b1f173a6e913f66abeddac30272"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a8de03b1f173a6e913f66abeddac30272">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, long value)</td></tr>
<tr class="separator:a8de03b1f173a6e913f66abeddac30272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334cb0f209b5c5103ee6ca94eefc395d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a334cb0f209b5c5103ee6ca94eefc395d">appendValue</a> (double value)</td></tr>
<tr class="separator:a334cb0f209b5c5103ee6ca94eefc395d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1181846eccf5503bfbcde42bc7f0d24c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1181846eccf5503bfbcde42bc7f0d24c">appendValue</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, double value)</td></tr>
<tr class="separator:a1181846eccf5503bfbcde42bc7f0d24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c52a0f3954b3ca9a5c4eff1c03be2b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0c52a0f3954b3ca9a5c4eff1c03be2b9">appendValue</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, double value)</td></tr>
<tr class="separator:a0c52a0f3954b3ca9a5c4eff1c03be2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac140925b676069a25642146cebe422e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac140925b676069a25642146cebe422e6">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, double value)</td></tr>
<tr class="separator:ac140925b676069a25642146cebe422e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5ee8010ac4a64a247ba2969e82b71e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ace5ee8010ac4a64a247ba2969e82b71e">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, double value)</td></tr>
<tr class="separator:ace5ee8010ac4a64a247ba2969e82b71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51d7a4ddbefb6c175db1f61f1328185"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac51d7a4ddbefb6c175db1f61f1328185">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, double value)</td></tr>
<tr class="separator:ac51d7a4ddbefb6c175db1f61f1328185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e77806e06d8c94fa0dc436d965cc307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a8e77806e06d8c94fa0dc436d965cc307">appendValue</a> (const std::string &amp;value)</td></tr>
<tr class="separator:a8e77806e06d8c94fa0dc436d965cc307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a4e08b5d6a947c2c265ef6656917b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a64a4e08b5d6a947c2c265ef6656917b0">appendValue</a> (const char *value)</td></tr>
<tr class="separator:a64a4e08b5d6a947c2c265ef6656917b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01afc628d51cba1345f932fd29028ac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a01afc628d51cba1345f932fd29028ac9">appendValue</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::string &amp;value)</td></tr>
<tr class="separator:a01afc628d51cba1345f932fd29028ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2332122b9052856469f03b8b01f7cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad2332122b9052856469f03b8b01f7cfa">appendValue</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const char *value)</td></tr>
<tr class="separator:ad2332122b9052856469f03b8b01f7cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed337c4a93451639fd89fe7b80f8308e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aed337c4a93451639fd89fe7b80f8308e">appendValue</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::string &amp;value)</td></tr>
<tr class="separator:aed337c4a93451639fd89fe7b80f8308e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e87b8f6bca73180b119c6488ba15de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1e87b8f6bca73180b119c6488ba15de1">appendValue</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const char *value)</td></tr>
<tr class="separator:a1e87b8f6bca73180b119c6488ba15de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727d489082fe2eb57d577d66b6e28ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a727d489082fe2eb57d577d66b6e28ed2">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;value)</td></tr>
<tr class="separator:a727d489082fe2eb57d577d66b6e28ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76e60e5b8e43094e960adb10863d12c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad76e60e5b8e43094e960adb10863d12c">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *value)</td></tr>
<tr class="separator:ad76e60e5b8e43094e960adb10863d12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8969e7ee70c1a6905046d6f1fe7fd38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ae8969e7ee70c1a6905046d6f1fe7fd38">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::string &amp;value)</td></tr>
<tr class="separator:ae8969e7ee70c1a6905046d6f1fe7fd38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab616519631b2331ab980b9c1c3f14731"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ab616519631b2331ab980b9c1c3f14731">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const char *value)</td></tr>
<tr class="separator:ab616519631b2331ab980b9c1c3f14731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771dfcaecc5564a3ee2037a1f14d5ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a771dfcaecc5564a3ee2037a1f14d5ced">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const std::string &amp;value)</td></tr>
<tr class="separator:a771dfcaecc5564a3ee2037a1f14d5ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c86c5a872f9a68b9df8b77e5e2e9f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a32c86c5a872f9a68b9df8b77e5e2e9f1">insertValue</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>, const char *value)</td></tr>
<tr class="separator:a32c86c5a872f9a68b9df8b77e5e2e9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32409e42aec1549fa7140cbdfff0fd1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a32409e42aec1549fa7140cbdfff0fd1c">appendNull</a> ()</td></tr>
<tr class="separator:a32409e42aec1549fa7140cbdfff0fd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7297e9a75c52d94faed9e2f9ad4ec7d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a7297e9a75c52d94faed9e2f9ad4ec7d8">appendNull</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a7297e9a75c52d94faed9e2f9ad4ec7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4013aa4ac3aa5265e02f04a15913874"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aa4013aa4ac3aa5265e02f04a15913874">appendNull</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:aa4013aa4ac3aa5265e02f04a15913874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59731b3af7a1e5989819dfb8f1e927c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac59731b3af7a1e5989819dfb8f1e927c">insertNull</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>)</td></tr>
<tr class="separator:ac59731b3af7a1e5989819dfb8f1e927c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a4bbdbf2468fb83e3f3b6ac91b03a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a26a4bbdbf2468fb83e3f3b6ac91b03a2">insertNull</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a26a4bbdbf2468fb83e3f3b6ac91b03a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43cb476b068b46611ea44eaddcaaf6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad43cb476b068b46611ea44eaddcaaf6a">insertNull</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:ad43cb476b068b46611ea44eaddcaaf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef06a2d224bb4aedb7618bbeb4152d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a4ef06a2d224bb4aedb7618bbeb4152d9">appendArray</a> ()</td></tr>
<tr class="separator:a4ef06a2d224bb4aedb7618bbeb4152d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8736cb80db56685a383e80db7d5eb73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ac8736cb80db56685a383e80db7d5eb73">appendArray</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:ac8736cb80db56685a383e80db7d5eb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5512a0821d4e52724cd7ec79fbe99638"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a5512a0821d4e52724cd7ec79fbe99638">appendArray</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a5512a0821d4e52724cd7ec79fbe99638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2881807ccb54e7cb2a0f6efa948545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#abe2881807ccb54e7cb2a0f6efa948545">insertArray</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>)</td></tr>
<tr class="separator:abe2881807ccb54e7cb2a0f6efa948545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d0b9b0fe5ef387c29c722e51a5bfbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a05d0b9b0fe5ef387c29c722e51a5bfbb">insertArray</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a05d0b9b0fe5ef387c29c722e51a5bfbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4f8107427a0afb17d128affee5defd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a0d4f8107427a0afb17d128affee5defd">insertArray</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a0d4f8107427a0afb17d128affee5defd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1199e195897a041b6e2daf798262fd5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a1199e195897a041b6e2daf798262fd5e">appendObject</a> ()</td></tr>
<tr class="separator:a1199e195897a041b6e2daf798262fd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62e029bfe2cda0e21b6a4847d015c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#af62e029bfe2cda0e21b6a4847d015c6b">appendObject</a> (const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:af62e029bfe2cda0e21b6a4847d015c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50341120c1a51fb67e2a8d4b197f5567"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a50341120c1a51fb67e2a8d4b197f5567">appendObject</a> (const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:a50341120c1a51fb67e2a8d4b197f5567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f081cea4bd6e388953ab304f2a55577"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a9f081cea4bd6e388953ab304f2a55577">insertObject</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>)</td></tr>
<tr class="separator:a9f081cea4bd6e388953ab304f2a55577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae19cb5b1fd18ed6389d368499f1a20bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ae19cb5b1fd18ed6389d368499f1a20bf">insertObject</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const std::string &amp;<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:ae19cb5b1fd18ed6389d368499f1a20bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7f44877ec0a9553f1e4d9bbe08f4e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#abd7f44877ec0a9553f1e4d9bbe08f4e4">insertObject</a> (unsigned int <a class="el" href="classcugl_1_1_json_value.html#a7c46ac15ddcce16242324ea9ce903bbd">index</a>, const char *<a class="el" href="classcugl_1_1_json_value.html#a403281b255603d26e7747f3a63cd9a32">key</a>)</td></tr>
<tr class="separator:abd7f44877ec0a9553f1e4d9bbe08f4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4909be643b39f27bc1d27825690fefad"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a4909be643b39f27bc1d27825690fefad">toString</a> (bool format=true) const </td></tr>
<tr class="separator:a4909be643b39f27bc1d27825690fefad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ace6fd6b6b235c7b757612cfaef6b95bb"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ace6fd6b6b235c7b757612cfaef6b95bb">alloc</a> (<a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">Type</a> <a class="el" href="classcugl_1_1_json_value.html#abc3eb1456f383976599824d24a47d700">type</a>)</td></tr>
<tr class="separator:ace6fd6b6b235c7b757612cfaef6b95bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae6e6ca854e2a54ebc185b59895ea2fa"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aae6e6ca854e2a54ebc185b59895ea2fa">alloc</a> (const std::string &amp;value)</td></tr>
<tr class="separator:aae6e6ca854e2a54ebc185b59895ea2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476d16411be953cf6dcd427c4f537b8c"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a476d16411be953cf6dcd427c4f537b8c">alloc</a> (const char *value)</td></tr>
<tr class="separator:a476d16411be953cf6dcd427c4f537b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f73e095c667b1cadd5f835a39c76048"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a2f73e095c667b1cadd5f835a39c76048">alloc</a> (bool value)</td></tr>
<tr class="separator:a2f73e095c667b1cadd5f835a39c76048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20451605ea254bbc77134a3db46928c"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#ad20451605ea254bbc77134a3db46928c">alloc</a> (long value)</td></tr>
<tr class="separator:ad20451605ea254bbc77134a3db46928c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9b164087d165914ac9f366b7c540cd"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a7b9b164087d165914ac9f366b7c540cd">alloc</a> (double value)</td></tr>
<tr class="separator:a7b9b164087d165914ac9f366b7c540cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee26511c39abe2080a712dd08fc3d119"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#aee26511c39abe2080a712dd08fc3d119">allocNull</a> ()</td></tr>
<tr class="separator:aee26511c39abe2080a712dd08fc3d119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9983c372caf5df182b3c08d94d415db5"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a9983c372caf5df182b3c08d94d415db5">allocArray</a> ()</td></tr>
<tr class="separator:a9983c372caf5df182b3c08d94d415db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619a5cb7b3f0cd19dd3446645ff25fe5"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a619a5cb7b3f0cd19dd3446645ff25fe5">allocObject</a> ()</td></tr>
<tr class="separator:a619a5cb7b3f0cd19dd3446645ff25fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbfb0d413d0c61390eefe66994e2050"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a2cbfb0d413d0c61390eefe66994e2050">allocWithJson</a> (const std::string &amp;json)</td></tr>
<tr class="separator:a2cbfb0d413d0c61390eefe66994e2050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca6fa50dde7320c2fef4a12d5594556"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_json_value.html#a9ca6fa50dde7320c2fef4a12d5594556">allocWithJson</a> (const char *json)</td></tr>
<tr class="separator:a9ca6fa50dde7320c2fef4a12d5594556"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a node in a JSON DOM tree.</p>
<p>While each instance is a single node, there are many methods for traversing the node as a tree. A node only has a child if it is an array or an object type. All other types are leaves in the tree.</p>
<p>Children may be accessed by index or key regardless of whether or not the node is an array or object. However, keys are only guaranteed to be unique if the node is an object type. Hence the main usage of this feature is to "cast" object nodes to arrays.</p>
<p>This class uses cJSON as the underlying parsing engine. However, it manages memory automatically so that the user does not need to worry about deleting or allocating memory beyond the initial node itself. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="acb13666c0569163d6a124f9247b423e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">cugl::JsonValue::Type</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This enum represents the possible data types in a <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a></p>
<p>We do not distinguish numeric types (int, float, long, double) since the JSON specification does not distinguish between them. Instead, we freely convert between these values on access. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="acb13666c0569163d6a124f9247b423e8ab9ff2fa4972141b1d1d36cd80b81a279"></a>NullType&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> contains no value at all </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb13666c0569163d6a124f9247b423e8ab0aebe765a463d2f7e8464016ef1eec2"></a>BoolType&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> contains a boolean value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb13666c0569163d6a124f9247b423e8af9154b8320591f3b1fab4cf4c951e409"></a>NumberType&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> contains a numeric (int, float, etc.) value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb13666c0569163d6a124f9247b423e8ab900a78030fdadc18121e26865e75791"></a>StringType&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> contains a string value </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb13666c0569163d6a124f9247b423e8acb17ff5177bb277ed8dd79480aad9c27"></a>ArrayType&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> is an array whose contents are children of the node </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="acb13666c0569163d6a124f9247b423e8ab74c375731dc50c662d6ce08befe2db0"></a>ObjectType&#160;</td><td class="fielddoc">
<p>The <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> is an object whose contents are children of the node </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae16e9f9c13471ba23458e201f91bb1c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::JsonValue::JsonValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a null <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate an object on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a class="anchor" id="a03ecea97a3b78fbd4d6bfec46822e640"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::JsonValue::~JsonValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> and all of its resources.</p>
<p>If no other references own the descendants of this node, they will all be recursively deleted as well. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ace6fd6b6b235c7b757612cfaef6b95bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> of the given type.</p>
<p>The value of this node will be the default value of the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> of the given type. </dd></dl>

</div>
</div>
<a class="anchor" id="aae6e6ca854e2a54ebc185b59895ea2fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given string.</p>
<p>The node will have type StringType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (string) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given string. </dd></dl>

</div>
</div>
<a class="anchor" id="a476d16411be953cf6dcd427c4f537b8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::alloc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given string.</p>
<p>The node will have type StringType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (string) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given string. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f73e095c667b1cadd5f835a39c76048"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::alloc </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given boolean.</p>
<p>The node will have type BoolType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (boolean) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given boolean. </dd></dl>

</div>
</div>
<a class="anchor" id="ad20451605ea254bbc77134a3db46928c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::alloc </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given number.</p>
<p>The node will have type NumberType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (numeric) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given number. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b9b164087d165914ac9f366b7c540cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::alloc </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given number.</p>
<p>The node will have type NumberType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (numeric) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given number. </dd></dl>

</div>
</div>
<a class="anchor" id="a9983c372caf5df182b3c08d94d415db5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::allocArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> array.</p>
<p>The node will have type ArrayType. The node itself will have no value. The contents of the array are the children of this node.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> array. </dd></dl>

</div>
</div>
<a class="anchor" id="aee26511c39abe2080a712dd08fc3d119"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::allocNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated null <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> (e.g. it has no value).</p>
<p>The node will have type NullType.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated null <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> (e.g. it has no value). </dd></dl>

</div>
</div>
<a class="anchor" id="a619a5cb7b3f0cd19dd3446645ff25fe5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::allocObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> object.</p>
<p>The node will have type ObjectType. The node itself will have no value. The contents of the object are the children of this node.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a2cbfb0d413d0c61390eefe66994e2050"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::allocWithJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> from the given JSON string.</p>
<p>This initializer will parse the JSON string and construct a full JSON tree for the string, if possible. The children are all owned by this node will be deleted when this node is deleted (provided there are no other references).</p>
<p>If there is a parsing error, this method will return nullptr. Detailed information about the parsing error will be passed to an assert. Hence error messages are suppressed if asserts are turned off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> from the given JSON string. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ca6fa50dde7320c2fef4a12d5594556"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::allocWithJson </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> from the given JSON string.</p>
<p>This initializer will parse the JSON string and construct a full JSON tree for the string, if possible. The children are all owned by this node will be deleted when this node is deleted (provided there are no other references).</p>
<p>If there is a parsing error, this method will return nullptr. Detailed information about the parsing error will be passed to an assert. Hence error messages are suppressed if asserts are turned off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> from the given JSON string. </dd></dl>

</div>
</div>
<a class="anchor" id="a4ef06a2d224bb4aedb7618bbeb4152d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) array and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key). </p>

</div>
</div>
<a class="anchor" id="ac8736cb80db56685a383e80db7d5eb73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) array and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5512a0821d4e52724cd7ec79fbe99638"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendArray </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) array and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7739e4ae22b1fc142a188620617931c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the given child to the end of this array or object.</p>
<p>The child will be added to the next available position in the array. If it is an object, it will use the current key of this object.</p>
<p>This method will fail if this node is not an array or object type. If is an object type, it will fail if the key to the child is not unique.</p>
<p>This node will acquire ownership of the child, preventing it from being deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af43f6df318edd46cb22141cea7074dd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends the given child to the end of this object.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<p>This node will acquire ownership of the child, preventing it from being deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">child</td><td>The child node to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a72406d154085f1e29804a004f928b6d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendChild </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends the given child to the end of this object.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<p>This node will acquire ownership of the child, preventing it from being deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">child</td><td>The child node to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32409e42aec1549fa7140cbdfff0fd1c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with no value and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key). </p>

</div>
</div>
<a class="anchor" id="a7297e9a75c52d94faed9e2f9ad4ec7d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendNull </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with no value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4013aa4ac3aa5265e02f04a15913874"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendNull </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with no value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1199e195897a041b6e2daf798262fd5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) object and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key). </p>

</div>
</div>
<a class="anchor" id="af62e029bfe2cda0e21b6a4847d015c6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendObject </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) object and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50341120c1a51fb67e2a8d4b197f5567"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendObject </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) object and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab80d1d17e7875d41008896b73241420b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a boolean value and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The boolean value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abae8745e7bcb86992ea5bfcdba416ecc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a boolean value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The boolean value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad08e417849b0938adf15aa76688bd715"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a boolean value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The boolean value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e65fd768db72013cbe545ba991dfc83"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a long value and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The long value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac738382e8ec663c53d461b4ef12bc3c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a long value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The long value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3f5eb3a74522f208feab177e736e106"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a long value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The long value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a334cb0f209b5c5103ee6ca94eefc395d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a double value and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The double value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1181846eccf5503bfbcde42bc7f0d24c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a double value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The double value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c52a0f3954b3ca9a5c4eff1c03be2b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a double value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The double value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8e77806e06d8c94fa0dc436d965cc307"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64a4e08b5d6a947c2c265ef6656917b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and appends it to the end.</p>
<p>The child will be added to the next available position in the array.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01afc628d51cba1345f932fd29028ac9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2332122b9052856469f03b8b01f7cfa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed337c4a93451639fd89fe7b80f8308e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e87b8f6bca73180b119c6488ba15de1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::appendValue </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and appends with the given key.</p>
<p>The child will be added to the next available position in the array. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad9e155b50245d06ff72b5ba6dc6168f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::asBool </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this node as a bool.</p>
<p>This method will fail if the node is not a value type. Otherwise, if the node is not a BoolType or NumberType, it will return the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to return if the node is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node as a bool. </dd></dl>

</div>
</div>
<a class="anchor" id="ac98aff038f01c1a1473f59e4b3b2d046"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;bool&gt; cugl::JsonValue::asBoolArray </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the children of this value as a vector of bools</p>
<p>This method will fail if the node is not an array or object. For each child, it will attempt to convert it to a bool. If it cannot, it will use the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if a child is not a bool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the children of this value as a vector of bools </dd></dl>

</div>
</div>
<a class="anchor" id="ad76dc1e9afaddd72e27d62c306453576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cugl::JsonValue::asDouble </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this node as a double.</p>
<p>This method will fail if the node is not a value type. Otherwise, if the node is not a NumberType, it will return the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to return if the node is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node as a double. </dd></dl>

</div>
</div>
<a class="anchor" id="aca73be399278f2ea2a36be890dea59dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; cugl::JsonValue::asDoubleArray </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the children of this value as a vector of doubles</p>
<p>This method will fail if the node is not an array or object. For each child, it will attempt to convert it to a double. If it cannot, it will use the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if a child is not a double</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the children of this value as a vector of doubles </dd></dl>

</div>
</div>
<a class="anchor" id="a9c600ffcf3ba2975c55b286e7baeba29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::JsonValue::asFloat </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this node as a float.</p>
<p>This method will fail if the node is not a value type. Otherwise, if the node is not a NumberType, it will return the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to return if the node is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node as a float. </dd></dl>

</div>
</div>
<a class="anchor" id="a658a5fae5e9f4098767bb3fb1f1af8c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt; cugl::JsonValue::asFloatArray </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the children of this value as a vector of floats</p>
<p>This method will fail if the node is not an array or object. For each child, it will attempt to convert it to a float. If it cannot, it will use the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if a child is not a float</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the children of this value as a vector of floats </dd></dl>

</div>
</div>
<a class="anchor" id="a36a952206beca612476c1a8e67f012a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::JsonValue::asInt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this node as a int.</p>
<p>This method will fail if the node is not a value type. Otherwise, if the node is not a NumberType, it will return the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to return if the node is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node as a int. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1e52518d89bc16be293ef31d3ac4c5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; cugl::JsonValue::asIntArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the children of this value as a vector of ints</p>
<p>This method will fail if the node is not an array or object. For each child, it will attempt to convert it to an int. If it cannot, it will use the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if a child is not an int</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the children of this value as a vector of ints </dd></dl>

</div>
</div>
<a class="anchor" id="a27eac25a09f3541d766f54996317c9d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long cugl::JsonValue::asLong </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0L</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this node as a long.</p>
<p>This method will fail if the node is not a value type. Otherwise, if the node is not a NumberType, it will return the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to return if the node is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node as a long. </dd></dl>

</div>
</div>
<a class="anchor" id="a670c3cbb1d08311155f4c429eb87b422"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;long&gt; cugl::JsonValue::asLongArray </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0L</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the children of this value as a vector of longs</p>
<p>This method will fail if the node is not an array or object. For each child, it will attempt to convert it to a long. If it cannot, it will use the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if a child is not a long</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the children of this value as a vector of longs </dd></dl>

</div>
</div>
<a class="anchor" id="a15345e5a65432636dc601ffdd9f64c49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::JsonValue::asString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns this node as a string.</p>
<p>This method will fail if the node is not a value type. Otherwise, if the node is not a StringType, it will return the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to return if the node is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="aa47e8ef8f67cfbde4f0e6674de47d934"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::JsonValue::asString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns this node as a string.</p>
<p>This method will fail if the node is not a value type. Otherwise, if the node is not a StringType, it will return the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to return if the node is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>this node as a string. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f26c3d9059c0310742c3f50ae7129dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::JsonValue::asStringArray </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the children of this value as a vector of strings</p>
<p>This method will fail if the node is not an array or object. For each child, it will attempt to convert it to a string. If it cannot, it will use the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if a child is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the children of this value as a vector of strings </dd></dl>

</div>
</div>
<a class="anchor" id="a0961c86fe1638e914d8292bf187b5511"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::JsonValue::asStringArray </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>&quot;&quot;</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the children of this value as a vector of strings</p>
<p>This method will fail if the node is not an array or object. For each child, it will attempt to convert it to a string. If it cannot, it will use the default value instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if a child is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the children of this value as a vector of strings </dd></dl>

</div>
</div>
<a class="anchor" id="a969331c2cac5277e7eae58eb47b7837d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the specified index.</p>
<p>This method will fail if the node is not an array or object type. If the index is out of bounds, this method will return nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index into the child array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the specified index. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b66758c75e501873f3c0582989ff2fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the specified index.</p>
<p>This method will fail if the node is not an array or object type. If the index is out of bounds, this method will return nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index into the child array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the specified index. </dd></dl>

</div>
</div>
<a class="anchor" id="af616805cfe31728e0f30fa2dbb4ab381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child with the specified key.</p>
<p>This method will fail if the node is not an object type. If there is no child with this key, the method returns nullptr. If the node is somehow corrupted and there is more than one child of this name, it will return the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key identifying the child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="ae2d506030fcfbf0c6ad467000977cc93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child with the specified key.</p>
<p>This method will fail if the node is not an object type. If there is no child with this key, the method returns nullptr. If the node is somehow corrupted and there is more than one child of this name, it will return the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key identifying the child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a14a268cd59b636ca94bec7e38004af61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the child with the specified key.</p>
<p>This method will fail if the node is not an object type. If there is no child with this key, the method returns nullptr. If the node is somehow corrupted and there is more than one child of this name, it will return the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key identifying the child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a1831b645d837e4f96d28f424684603e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::get </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the child with the specified key.</p>
<p>This method will fail if the node is not an object type. If there is no child with this key, the method returns nullptr. If the node is somehow corrupted and there is more than one child of this name, it will return the first one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key identifying the child.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="ac61ee92dd8faaf54cd52c543f5108c81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::getBool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the boolean value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a boolean value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asBool(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a boolean</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ee9cb96636a66e5814404750f27dc62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::getBool </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the boolean value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a boolean value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asBool(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a boolean</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the boolean value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a918140948c10b65cb505d40776b99a55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cugl::JsonValue::getDouble </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asDouble(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a8ee6811b17d7db2d6d5c8e25973b983a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double cugl::JsonValue::getDouble </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the double value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asDouble(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the double value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bfe671831c8cc2d3044ac4bf41297b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::JsonValue::getFloat </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the float value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asFloat(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f5bcbf5021d5858322e399fc4ec08ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::JsonValue::getFloat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the float value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asFloat(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the float value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="aba1fe9ee294aac3933379f1fbf876c5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::JsonValue::getInt </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the int value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asInt(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="aaee5958a3ebcb1b2df0603ac29d195c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::JsonValue::getInt </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the int value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asInt(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the int value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a1aa144425517cc19e8cd9efb1c656c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long cugl::JsonValue::getLong </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0L</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the long value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asLong(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b68e346db3bc5809eecc0f8044aeb5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long cugl::JsonValue::getLong </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>0L</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the long value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a numeric value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asLong(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the long value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a793c37fa7cb4b5e4e5fb256d889acfb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::JsonValue::getString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the string value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a string value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asString(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a60534197d8bd55ced45c81c3ba4097a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::JsonValue::getString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the string value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a string value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asString(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a83d7e7ee18439625defd71abbdc13132"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::JsonValue::getString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the string value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a string value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asString(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a72a633602406b58873929901d5e33adc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::JsonValue::getString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the string value of the child with the specified key.</p>
<p>If there is no child with the given key, or if that child cannot be represented as a string value, it returns the default value instead.</p>
<p>Note this is not the same behavior as get(key).asString(defaultValue), since it will not fail if the child is an array or object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultValue</td><td>The value to use if child does not exist or is not a string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the string value of the child with the specified key. </dd></dl>

</div>
</div>
<a class="anchor" id="a6769355b5037355b54ae9285fa8381a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::has </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a child with the specified name exists.</p>
<p>This method will always return false if the node is not an object type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key identifying the child</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a child with the specified name exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a1b42f9bf05cccc002d44a5e2769df5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::has </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a child with the specified name exists.</p>
<p>This method will always return false if the node is not an object type</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key identifying the child</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a child with the specified name exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c46ac15ddcce16242324ea9ce903bbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int cugl::JsonValue::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the index for this array/object value.</p>
<p>This method fails if there is no parent node.</p>
<dl class="section return"><dt>Returns</dt><dd>the index for this array/object value. </dd></dl>

</div>
</div>
<a class="anchor" id="acd684d09191480c7864ee33c047f8a44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> of the given type.</p>
<p>The value of this node will be the default value of the type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a225e55bd712a75ecdf7f306b31e8eaf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given string.</p>
<p>The node will have type StringType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (string) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a473b77867af51cf16f338449dcda0605"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::init </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given string.</p>
<p>The node will have type StringType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (string) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4915a2b664374437900c482a3703f3a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::init </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given boolean.</p>
<p>The node will have type BoolType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (boolean) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad984b0067dd1cbf460cbefe25795e91c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::init </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given number.</p>
<p>The node will have type NumberType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (numeric) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a248a9952a879edc85ac4678aeffb0b9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::init </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> with the given number.</p>
<p>The node will have type NumberType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The (numeric) value of this JSON node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a904fd5baf53648ceeb09c957ed56236c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::initArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> array.</p>
<p>The node will have type ArrayType. The node itself will have no value. The contents of the array are the children of this node.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4669f0818aba5bdd246173a3d6dd43d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::initNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new null <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> (e.g. it has no value).</p>
<p>The node will have type NullType.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a456e62246c253fda0a786cc7e9151d8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::initObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> object.</p>
<p>The node will have type ObjectType. The node itself will have no value. The contents of the object are the children of this node.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a13c84c6f73b24e5b466c9ad85db0d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::initWithJson </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> from the given JSON string.</p>
<p>This initializer will parse the JSON string and construct a full JSON tree for the string, if possible. The children are all owned by this node will be deleted when this node is deleted (provided there are no other references).</p>
<p>If there is a parsing error, this method will return false. Detailed information about the parsing error will be passed to an assert. Hence error messages are suppressed if asserts are turned off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a00592820366cb341c96d3a604ec21e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::initWithJson </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a new <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> from the given JSON string.</p>
<p>This initializer will parse the JSON string and construct a full JSON tree for the string, if possible. The children are all owned by this node will be deleted when this node is deleted (provided there are no other references).</p>
<p>If there is a parsing error, this method will return false. Detailed information about the parsing error will be passed to an assert. Hence error messages are suppressed if asserts are turned off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON string to parse.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the JSON node is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="abe2881807ccb54e7cb2a0f6efa948545"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertArray </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) array and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05d0b9b0fe5ef387c29c722e51a5bfbb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertArray </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) array and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d4f8107427a0afb17d128affee5defd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertArray </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) array and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4168abaecd84ec2bdff2a0b9fc56b08d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the given child at the given position in this array or object.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. If it is an object, it will use the current key of this object.</p>
<p>This method will fail if this node is not an array or object type. If it is an object type, it will fail if the key to the child is not unique.</p>
<p>This node will acquire ownership of the child, preventing it from being deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to add the child at </td></tr>
    <tr><td class="paramname">child</td><td>The child node to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bbd7de0639eccb764d9428a42f9a69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts the given child at the given position in this object.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<p>This node will acquire ownership of the child, preventing it from being deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to add the child at </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">child</td><td>The child node to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69507b6699aba1b94079e21d60cc8c75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inserts the given child at the given position in this object.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<p>This node will acquire ownership of the child, preventing it from being deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to add the child at </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">child</td><td>The child node to add </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac59731b3af7a1e5989819dfb8f1e927c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertNull </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with no value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26a4bbdbf2468fb83e3f3b6ac91b03a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertNull </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with no value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad43cb476b068b46611ea44eaddcaaf6a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertNull </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with no value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f081cea4bd6e388953ab304f2a55577"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertObject </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) object and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae19cb5b1fd18ed6389d368499f1a20bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertObject </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) object and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abd7f44877ec0a9553f1e4d9bbe08f4e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertObject </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new (empty) object and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a00e8399fffc5569d6df7bd93bd841d13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a boolean value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">value</td><td>The boolean value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d90b7eccc2a2b3340521e62166fdb14"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a boolean value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The boolean value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0300ebb8fb94edfe2afd7e212bfbdffa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a boolean value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The boolean value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a708497d94d5237d4849314eb76407392"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a long value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">value</td><td>The long value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa7eeb89c10220b62c7fd0c187199fdb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a long value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The long value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8de03b1f173a6e913f66abeddac30272"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a long value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The long value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac140925b676069a25642146cebe422e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a double value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">value</td><td>The double value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace5ee8010ac4a64a247ba2969e82b71e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a double value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The double value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac51d7a4ddbefb6c175db1f61f1328185"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a double value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The double value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a727d489082fe2eb57d577d66b6e28ed2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad76e60e5b8e43094e960adb10863d12c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right.</p>
<p>This method will fail if this node is not an array (e.g. it will even fail if it is an object, as the child will have no key).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae8969e7ee70c1a6905046d6f1fe7fd38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab616519631b2331ab980b9c1c3f14731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a771dfcaecc5564a3ee2037a1f14d5ced"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a32c86c5a872f9a68b9df8b77e5e2e9f1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::insertValue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a new child with a string value and inserts it in place.</p>
<p>The child will be added to the given position in the array, and all other children will be shifted to the right. It will also use the provided key to identify it.</p>
<p>This method will fail if this node is not an object type (e.g. it will even fail if the node is an array). It will also fail if the key to the child is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The position to insert the child </td></tr>
    <tr><td class="paramname">key</td><td>The key to identify the child </td></tr>
    <tr><td class="paramname">value</td><td>The string value for the child </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aebffab19c701475b627e3cdf06a56b9a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::isArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this node is an array.</p>
<p>If this method returns true, it is not safe to access the children by keys, as the keys may not be unique.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is an array. </dd></dl>

</div>
</div>
<a class="anchor" id="a1f370126ba61ca4222edc7fff0ae99a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::isBool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this node is a boolean value.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is a boolean value. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf284eb17b25e240a39608fd74f6b0a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this node has NULL type (e.g. it has no value)</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node has NULL type (e.g. it has no value) </dd></dl>

</div>
</div>
<a class="anchor" id="ab73a52f2084dfd237f0a8d18a8973176"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::isNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this node is a double or long value.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is a double or long value. </dd></dl>

</div>
</div>
<a class="anchor" id="a961bd69d43de4862031e3cd7a92b0282"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::isObject </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this node is an object.</p>
<p>If this method returns true, it is safe to access the children by either index or key.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is an array. </dd></dl>

</div>
</div>
<a class="anchor" id="a083a66a565193fd6bd537423c9de0d19"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::isString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this node is a string value.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is a string value. </dd></dl>

</div>
</div>
<a class="anchor" id="a937e6742f050000d66b29b5894b229a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::JsonValue::isValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this node is not NULL nor an array or object.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this node is not NULL nor an array or object. </dd></dl>

</div>
</div>
<a class="anchor" id="a403281b255603d26e7747f3a63cd9a32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::JsonValue::key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the key for this object value.</p>
<p>This method fails if there is no parent or the parent type is not ObjectType.</p>
<dl class="section return"><dt>Returns</dt><dd>the key for this object value. </dd></dl>

</div>
</div>
<a class="anchor" id="a2b9193ffe73e30dd3070e23664b0f1bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::removeChild </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child with the specified index and removes it from this node.</p>
<p>All other children will be shifted to the right. Returning the node allows the user to acquire ownership before it is deleted.</p>
<p>If the index is out of bounds, this method returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the child to remove</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the child with the specified index and removes it from this node. </p>

</div>
</div>
<a class="anchor" id="af588e919317d739edae0b9d8456511a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::removeChild </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child with the specified key and removes it from this node.</p>
<p>Returning the node allows the user to acquire ownership before it is deleted.</p>
<p>If there is no child with this key, this method returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key of the child to remove</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the child with the specified key and removes it from this node. </p>

</div>
</div>
<a class="anchor" id="a3690167611c8dcabe9b03ea107b6940b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_json_value.html">JsonValue</a>&gt; cugl::JsonValue::removeChild </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the child with the specified key and removes it from this node.</p>
<p>Returning the node allows the user to acquire ownership before it is deleted.</p>
<p>If there is no child with this key, this method returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The key of the child to remove</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the child with the specified key and removes it from this node. </p>

</div>
</div>
<a class="anchor" id="a564f223ce9656ee2b0bb6cacce5753a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of this node to the given string.</p>
<p>This method will fail if the node is not a value type or NULL. Using this method will set the type of the node to StringType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c81da96e5f4fcc45c6c9410e36f29dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of this node to the given string.</p>
<p>This method will fail if the node is not a value type or NULL. Using this method will set the type of the node to StringType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The string value to assign (may not be null) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5888562a73aa46d7040cb8ed7373c949"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::set </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of this node to the given number.</p>
<p>This method will fail if the node is not a value type or NULL. Using this method will set the type of the node to NumberType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The numeric value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68a9d1272680c1e87564e8ab49f6929b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::set </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of this node to the given number.</p>
<p>This method will fail if the node is not a value type or NULL. Using this method will set the type of the node to NumberType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The numeric value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a93dcf62c3a21f099b752bcdcba20aabb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::set </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the value of this node to the given boolean.</p>
<p>This method will fail if the node is not a value type or NULL. Using this method will set the type of the node to BoolType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The boolean value to assign </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1cbdf6422d20111f7bcfeca7f1711db5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::setKey </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this key for this object value.</p>
<p>This method fails if there is no parent or the parent type is not ObjectType. It also fails if this choice of key is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key for this object value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40986d5fdb35f137bed1e7d83a13d979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::setKey </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this key for this object value.</p>
<p>This method fails if there is no parent or the parent type is not ObjectType. It also fails if this choice of key is not unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key for this object value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a88fa443c760689fd7dea2f5b16ef8b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::JsonValue::setNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this node to NULL, erasing all values.</p>
<p>This method will fail if the node is not a value type or NULL. Using this method will set the type of the node to NullType. </p>

</div>
</div>
<a class="anchor" id="ab348e91e653ecdef8b6f821bb506702b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::JsonValue::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of children of this node</p>
<dl class="section return"><dt>Returns</dt><dd>the number of children of this node </dd></dl>

</div>
</div>
<a class="anchor" id="a4909be643b39f27bc1d27825690fefad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::JsonValue::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>format</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representation of this JSON.</p>
<p>This method returns a proper string representation that can be written to the file. Providing this string to the <a class="el" href="">allocJson</a> constructor is guaranteed to make a duplicate of this JSON tree.</p>
<p>The JSON may either be pretty-printed or condensed depending on the value of format. By default, we pretty-print all JSON strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format</td><td>Whether to pretty-print the JSON string</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this JSON. </dd></dl>

</div>
</div>
<a class="anchor" id="abc3eb1456f383976599824d24a47d700"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_json_value.html#acb13666c0569163d6a124f9247b423e8">Type</a> cugl::JsonValue::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of this node</p>
<dl class="section return"><dt>Returns</dt><dd>the type of this node </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/assets/<a class="el" href="_c_u_json_value_8h_source.html">CUJsonValue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
